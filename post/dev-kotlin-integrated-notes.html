<!DOCTYPE html><html lang="zh-TW" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>程式編寫 | 綜合整理 Kotlin 筆記 | 🐳 BlueWhaleYT</title><meta name="keywords" content="Kotlin"><meta name="author" content="BlueWhaleYT"><meta name="copyright" content="BlueWhaleYT"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="程式編寫 | 綜合整理 Kotlin 筆記"><meta name="application-name" content="程式編寫 | 綜合整理 Kotlin 筆記"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="程式編寫 | 綜合整理 Kotlin 筆記"><meta property="og:url" content="https://bluewhaleyt.github.io/post/dev-kotlin-integrated-notes.html"><meta property="og:site_name" content="🐳 BlueWhaleYT"><meta property="og:description" content="使用的軟件是 Fleet，由 JetBrains 所研發的。   入口點入口點就是程式一開始在哪裏執行。 fun main() &amp;amp;#123;     print(&amp;quot;hello world&amp;quot;) &amp;amp;#125;   Kotlin 的 main.kt 實際上是有類別的，它叫做 MainK"><meta property="og:locale" content="zh-TW"><meta property="og:image" content="https://i.imgur.com/66jn0VC.png"><meta property="article:author" content="BlueWhaleYT"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://i.imgur.com/66jn0VC.png"><meta name="description" content="使用的軟件是 Fleet，由 JetBrains 所研發的。   入口點入口點就是程式一開始在哪裏執行。 fun main() &amp;amp;#123;     print(&amp;quot;hello world&amp;quot;) &amp;amp;#125;   Kotlin 的 main.kt 實際上是有類別的，它叫做 MainK"><link rel="shortcut icon" href="https://i.ibb.co/zRvn96K/personal-icon.jpg"><link rel="canonical" href="https://bluewhaleyt.github.io/post/dev-kotlin-integrated-notes"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: undefined,
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: false,
  mainTone: {"mode":"both","api":"https://img2color-go.vercel.app/api?img=","cover_change":true},
  authorStatus: undefined,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查詢的內容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '複製成功',
    error: '複製錯誤',
    noSupport: '瀏覽器不支援'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '剛剛',
    min: '分鐘前',
    hour: '小時前',
    day: '天前',
    month: '個月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: BlueWhaleYT","link":"連結: ","source":"來源: 🐳 BlueWhaleYT","info":"著作權歸作者所有。商業轉載請聯絡作者獲得授權，非商業轉載請註明出處。","copySuccess":"複製成功，複製和轉載請標注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切換為繁體","cht_to_chs":"你已切換為簡體","day_to_night":"你已切換為深色模式","night_to_day":"你已切換為淺色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '🐳 BlueWhaleYT',
  title: '程式編寫 | 綜合整理 Kotlin 筆記',
  postAI: '',
  pageFillDescription: '入口點, 修改入口點或類別名稱, 輸入數值, 使用操控台輸入, 使用 GUI 視窗輸入, 套件與匯入, 套件類別命名衝突, 存取修飾子, 可繼承類, 對象與建構式, 單例模式 (Singleton), 伴生對象, 建構子建構, 主要建構子, 次要 x2F 多個建構子, 初始化程式, 運算符, 位元運算符, 變量及常量, 存取與變異, 函數, 函數類型, 單行表達式, 高階函數, 內聯函數, infix 函數, operator 函數, 匿名函數, 標準 x2F 作用域函數, let 函數, run 函數, apply 函數, also 函數, with 函數, 擴展函數, 範圍, 範圍函數, 陣列, 用 arrayOf() 函數建立基本陣列, 用 Array() 建立不同陣列, 二維陣列, 三維陣列, 集合, 集合類型, 有序集合 List (列表), 無序集合 Set (集合), 鍵值對集合 Map (映射), 集合函數操作, 列舉, 註解, 元資訊, 條件判斷, 決策邏輯, if 語句, else if 語句, 單行 if 表達式, 情況邏輯, 迴圈, while 迴圈, for 迴圈, forEach 迴圈, 智慧轉型, 空安全, 從陣列中清除空值, 空合併及 Elvis 運算符 ?, 安全調用符 ?., 非空斷言 !!, 委託, 委託屬性, lazy 屬性, observable 屬性, vetoable 屬性使用的軟件是由所研發的入口點入口點就是程式一開始在哪裏執行的實際上是有類別的它叫做因為的編譯器歸根到底都是最後轉換到修改入口點或類別名稱因為一開始預設是要修改的這就要用註解這個註解會直接修改輸入數值使用操控台輸入在不用這樣麻煩用來輸入數值至操控台可以直接用方法不過編譯器會推薦用因為這個可以檢查空指針內部實現代碼純粹是返回一個是跨平台不限於跨平台用的因為語法庫支援及編譯基本使用說明用戶輸入數值的目的用戶所輸入的值再按會賦值至用戶所輸入的值再按會賦值至顯示結果執行結果分割形式例如想在單一輸入的時候輸入多個數值可以用裏面接受的參數這裏寫的是代表以空格分割執行結果使用視窗輸入例如是用庫套件與匯入預設匯入了這些套件不支援靜態匯入只用便可以套件類別命名衝突不支援套件類別名稱重複需要用關鍵字重新定義存取修飾子修飾子所有類可存取預設所有類可存取當前類可存取當前類可存取當前類子類可存取當前類子類同一套件路徑下的類可存取無同一套件路徑下的類可存取預設同一模組中的類可存取無可繼承類預設寫的是不能繼承的如果要讓其他可繼承這個就要加關鍵字對象與建構式單例模式我們可以使用關鍵字來定義可以在其他地方使用來訪問其屬性和方法屬性和方法調用需要加上伴生對象我們可以使用關鍵字在類內部定義一個伴生物件伴生物件可以訪問類的私有成員就像是該類的靜態成員一樣但它不同於靜態成員因為它可以訪問類的非靜態成員屬性和方法調用需要加上建構子建構主要建構子次要多個建構子初始化程式用函數可以初始化建構子執行的程式執行結果運算符位元運算符按位取反取反後的數字會變成原數字的補數輸出函數會將數字的二進位表示中的每個位元取反也就是變成變成另外這個操作還會將數字的正負號反轉的二進位表示為當我們對這個數字進行取反操作時每個位元都會取反得到的結果為這個結果在二進位中也代表著數字左移將數字的二進位表示向左移動指定的位數左移操作會在右側填入相當於將該數字乘以的次方其中是左移的位數左移的數字是左移的位數是輸出將左移位相當於右移將數字的二進位表示向右移動指定的位數右移操作會在左側填入原數字的最高位元相當於將該數字除以的次方其中是右移的位數右移的數字是右移的位數是輸出將右移位相當於變量及常量我們可以使用變量和常量來存儲和管理數據變量是可以改變其值的存儲位置而常量則是一旦被賦值就無法更改的存儲位置賦值語句格式萬變不離其宗變量名稱數據類型初始值宣告變量使用關鍵字來定義可變變量宣告常量使用關鍵字來定義常量不可變變量存取與變異考慮到用還是還有一個考量就是變量但賦有的和屬性變量賦有的屬性一般而言如果不肯定變量能不能被修改就先用當有修改的用途就改用此外還有關鍵字看似與能混為一談與的相若一般情況下用不用是絕沒太大影響重點是變量必須是頂層級別或者或中的屬性是在運行時計算而則是編譯時計算預設的是私有變量當加上了變成就會成為公共變量例子編譯成功編譯錯誤編譯成功函數函數是一個重要的程式結構它可以接受輸入參數並返回一個結果我們可以使用關鍵字來定義一個函數函數預設返回的類型為即是的類型和方法是一樣的基本上可以省略不寫函數類型單行表達式如果函數只有一行程式碼可以使用單行表達式函數的語法簡化函數的定義這裏的等同於返回類型可省略高階函數函數可以作為參數傳遞給其他函數或者作為返回值返回接受個參數其中參數比較複雜這個運用了高階函數接受兩個參數然後再返回一個類型的結果至於是怎樣的結果就是視乎高階函數實現的邏輯假如我們用函數實現一個加法及乘法計算需要一對區塊區塊內需要傳入參數就以和分別是對入接著後寫的代碼就是要實現的邏輯執行結果內聯函數函數會在代碼編譯時將被調用處代碼直接嵌入到調用處的函數中過度使用會使字節碼膨脹一般如果是這樣的程式碼不會用如果沒有用來定義函數如果有用來定義函數直接把函數的代碼嵌入下來實際用途是用來減少創建額外對象及函數從而減少資源消耗亦都增加執行速度順序執行代碼的速度會較調用函數的速度快你寫的程式碼實際編譯後的程式碼把函數區塊內的程式碼嵌入下來為函數使用的參數設定就是不內聯的意思如果我們嘗試寫因為函數被內聯了如果嘗試傳回會在編譯器拋出所以這個時候就要用強制內聯函數不需要用的函數輸出函數就是重載運算符的函數例如對應的函數是錯誤假如我們嘗試把不支援的型別與例如相加會在編譯時拋出錯誤要令到這個運算符可以用其他類型進行加法就要用輸出運算符函數表運算符函數匿名函數匿名函數可使用定義並作為值賦值給變數執行結果標準作用域函數這些函數可以幫助我們簡化程式碼並提高可讀性對代碼邏輯沒有任何意義只是語法糖用途很廣泛而且看情況函數對象引用返回值是否擴展函數表達式是表達式是表達式不是調用毋須表達式不是把當作參數是是當前引用的對象例如可省略為常用於表達式作為顯式單個參數聲明的暫代名稱只可以為單個參數的函數才可用如果暫不使用參數可用作為佔位未使用的參數不會進行處理函數對非空型別對象執行表達式在這裡可以使用非空的變數把表達式作為變量引入到局部作用域中輸出函數跟函數用法相若但函數會傳回表達式函數沒有傳回值而且可以為特定對象編寫邏輯最後運算取得結果擴展對象配置並且計算結果輸出輸出非擴展在需要表達式的地方執行語句返回的值一定要放最後輸出函數可視為一種配置函數傳入一個接收者然後呼叫一系列函數來對接收者做設定函數附加效果適合針對同一原始物件透過副作用做事當看到的時候表示同時還要針對該對象物件執行此動作輸出函數一個對象的一組函數調用函數是函數的變形他們的功能與行為一樣接收者是使用的對象物件但的呼叫方式不同使用時要求引數作為其第一個參數傳入另外若執行的對象物件為則區塊不會進入反之函數則是會進去操作擴展函數允許我們為現有的類型添加新的函數而不需要修改原始類型的程式碼輸出這裏的是指的型別這個是一個接收者善用擴展函數可減少編寫複用工具函數轉換為後的程式碼實際上有一個隱藏的類別會產生根據檔案名稱如那就會在編譯過程生成大概的程式碼就是會在編譯過程寫入作為參數範圍範圍是一個連續的數值區間我們可以使用範圍來表示一系列連續的數字或字符在中我們可以使用運算符來創建一個範圍範圍的起始值和結束值可以是整數字符或其他可比較的型別升序輸出如果啟用了嵌入提示可以看到有的意思降序輸出而則有的意思降序不是這樣做沒有輸出編譯器會跟你說範圍是空的因為是異想天開的事略過及調整步長例如是偶數輸出直至輸出不計算範圍函數不一定只用在迴圈亦可以以函數方式使用執行結果陣列陣列又稱數組是一種常用的資料結構它可以儲存一組相同類型的元素用函數建立基本陣列空陣列一般陣列用建立不同陣列預設是空陣列設置了陣列大小為獲取陣列首項元素獲取陣列大小陣列的索引從開始所以代表陣列中的第一個元素二維陣列例如一個的二維陣列的值為執行結果的值為三維陣列例如一個的三維陣列的值為這個是假想三維空間的軸軸及軸測量指標其中軸有個元素軸有個元素軸有個元素以一個立方體來比喻的話我們可以把軸想像成立方體的寬度軸想像成高度軸想像成深度而的意思就是這個立方體有個寬度個高度和個深度執行結果的值為集合集合是在程式開發中非常重要的一個主題它們可以讓我們有效地儲存和操作多個元素集合與陣列一樣索引由開始即是第一個元素集合類型有序集合列表是一個有序的集合可以包含重複的元素我們可以使用索引來訪問和修改列表中的元素定義不可變列表定義可變列表舊輸出為新增一個元素為新輸出執行結果無序集合集合是一個不重複元素的集合並且沒有特定的順序執行結果相反如果用則會連同重複元素輸出執行結果鍵值對集合映射是一個鍵值對的集合每個元素都有一個唯一的鍵和對應的值我們可以使用鍵來獲取相應的值用關鍵字進行鍵值對格式鍵值鍵值舊輸出為新增屬性並設置為女性新輸出執行結果集合函數操作篩選出偶數把每個數字都加倍計算總和即執行結果返回的是型別對集合進行不同操作沒有指定返回型別累積函數第一個參數是用來疊加的返回值第二個參數是本次循環中列表的值與相似但可設定初始值列舉列舉是一組相關的常量的集合它們可以幫助我們更好地組織和表示程式中的數據在中我們可以使用關鍵字來定義一個列舉類基本列舉輸出列舉初始值可以像一般建構式擁有屬性和方法輸出輸出註解註解是一種用於在程式碼中添加元數據的特殊標記它們可以應用於類函數變數等元素上並提供額外的資訊給編譯器工具或其他程式碼分析工具使用內建註解註解用途用於將中的伴生對象中的函數或屬性轉換為中的靜態函數或靜態屬性用於在中生成重載函數的所有可能的組合標記已被棄用的函數類或屬性並提供一個建議的替代方案編寫自訂註解函數內容元資訊元資訊用途例子用於指定註解可以應用的元素類型如可以應用於類和函數上用於指定註解在編譯後的保留策略例如表示該註解在運行時仍然可用用於指定註解是否可以重複應用於同一個元素通常一個元素只能擁有一個特定註解的實例用於指示該註解應該包含在生成的文檔中通常一個元素只能擁有一個特定註解的實例但是如果你將註解應用於註解定義上則可以多次應用該註解於同一個元素這需要使用一個容器註解來包裹重複的註解例子執行結果條件判斷決策邏輯語句你已經成年了你還未成年語句單行表達式及格不及格情況邏輯表達式類似於使用的語句可以用於根據不同的值執行不同的程式邏輯星期一星期二星期三星期四星期五週末比的更勝一籌表達式還可以用於檢查範圍類型和其他條件迴圈迴圈執行結果迴圈執行結果迴圈可以運用集合與函數簡化語法代碼操作執行結果智慧轉型很聰明當我們使用關鍵字檢查一個變數是否為特定類型後會自動將該變數轉型為該類型在這裡自動將轉型為類型而則要手動轉型在這裡我們需要手動將轉型為類型空安全空安全是中一個非常重要的特性它可以幫助我們避免許多空指針異常從陣列中清除空值如果你想從可為空的或陣列中消除值你可以使用函數這個函數將返回一個新的集合其中不包含值輸出輸出空合併及運算符可以在變數為時提供一個默認值如果變數為則運算符將返回其右側的表達式作為結果否則返回變數本身輸出輸出安全調用符處理可為空的變數時我們需要使用安全調用運算符來訪問它的屬性或呼叫它的方法這樣可以避免空指針異常輸出通常會連同標準函數一起使用沒有輸出非空斷言可以在確定變數不為的情況下強制執行操作使用運算符需要謹慎使用因為它可能引發空指針異常只有在你確定變數不為的情況下才應該使用非空斷言運算符否則建議使用安全調用運算符來處理可為空的變數以避免空指針異常的風險委託指物件將一個請求委派給另一個物件來處理將其讀取和寫入操作委託給其他對象例如現在我想要一個新的支援的函數如果直接把其繼承就有失原意因為我只想要支援函數結果把都帶過來了要解決這個問題可以用介面現在這個就只可以用函數了亦可以用關鍵字委託哪一個去處理有些情況下我們可能不希望立即刪除被棄用的屬性因為有一些舊有的程式碼可能還在使用這個屬性為了向後兼容性我們可以將存取委託給新的屬性這樣舊有的程式碼仍然可以使用這個屬性同時建議開發者在新的程式碼中使用替代方案輸出委託屬性屬性這個委託屬性用於惰性初始化它只有在第一次訪問屬性時才會計算其值以後的訪問將直接返回已計算的值初始化執行執行即使第二次執行都不會再出現初始化執行結果初始化執行執行屬性這個委託屬性用於觀察屬性的變化它接收一個初始值和一個回調函數當屬性的值發生變化時將調用回調函數初始值結果執行結果結果初始值結果屬性這個委託屬性用於在設置屬性值之前進行驗證它接收一個初始值和一個驗證回調函數當設置屬性的新值時將調用驗證回調函數以確定是否接受該值如果驗證回調函數返回則不接受該值並保持原始值設置新值將通過驗證設置新值將被驗證拒絕執行結果',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023 年 12 月 03 日 12 時 36 分 40 秒',
  postMainColor: '#feca57',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/codethemes/code-dark.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><style type="text/css">
.CodeMirror-lines,.line,.code-output,.code,.token {
    font-size: 16px;
    line-height: 22px;
}
</style><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://i.ibb.co/zRvn96K/personal-icon.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">🐳 BlueWhaleYT</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜尋</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新評論</span></div><div class="aside-list"><span>正在載入中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Android/" style="font-size: 1.05rem; font-weight: 500; color: var(--anzhiyu-lighttext)">Android<sup>2</sup></a><a href="/tags/Desktop/" style="font-size: 1.05rem;">Desktop<sup>1</sup></a><a href="/tags/Express/" style="font-size: 1.05rem;">Express<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 1.05rem;">HTML<sup>1</sup></a><a href="/tags/JSON/" style="font-size: 1.05rem;">JSON<sup>1</sup></a><a href="/tags/Java/" style="font-size: 1.05rem;">Java<sup>2</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>2</sup></a><a href="/tags/Kotlin/" style="font-size: 1.05rem; font-weight: 500; color: var(--anzhiyu-lighttext)">Kotlin<sup>6</sup></a><a href="/tags/Lua/" style="font-size: 1.05rem;">Lua<sup>2</sup></a><a href="/tags/Markdown/" style="font-size: 1.05rem;">Markdown<sup>1</sup></a><a href="/tags/Node-js/" style="font-size: 1.05rem;">Node.js<sup>1</sup></a><a href="/tags/Roblox/" style="font-size: 1.05rem;">Roblox<sup>2</sup></a><a href="/tags/Swift/" style="font-size: 1.05rem;">Swift<sup>1</sup></a><a href="/tags/XML/" style="font-size: 1.05rem;">XML<sup>1</sup></a><a href="/tags/iOS/" style="font-size: 1.05rem;">iOS<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>歸檔</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">七月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/12/"><span class="card-archive-list-date">十二月 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/08/"><span class="card-archive-list-date">八月 2021</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%A8%8B%E5%BC%8F%E7%B7%A8%E5%AF%AB/" itemprop="url">程式編寫</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/Kotlin/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Kotlin</span></a></span></div></div><h1 class="post-title" itemprop="name headline">程式編寫 | 綜合整理 Kotlin 筆記</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">發表於</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-12-01T06:49:09.000Z" title="發表於 2023 年 12 月 01 日 14 時 49 分 09 秒">2023 年 12 月 01 日</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新於</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-12-03T04:36:40.586Z" title="更新於 2023 年 12 月 03 日 12 時 36 分 40 秒">2023 年 12 月 03 日</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字數總計:</span><span class="word-count" title="文章字数">7.6k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">閱讀時長:</span><span>31分鐘</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="程式編寫 | 綜合整理 Kotlin 筆記"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">閱讀量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://i.imgur.com/66jn0VC.png"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://i.imgur.com/X9zVUFU.png&quot;" data-lazy-src="https://i.imgur.com/66jn0VC.png" style="pointer-events: none;"><hr><article class="post-content" id="article-container" itemscope itemtype="https://bluewhaleyt.github.io/post/dev-kotlin-integrated-notes.html"><header><a class="post-meta-categories" href="/categories/%E7%A8%8B%E5%BC%8F%E7%B7%A8%E5%AF%AB/" itemprop="url">程式編寫</a><a href="/tags/Kotlin/" tabindex="-1" itemprop="url">Kotlin</a><h1 id="CrawlerTitle" itemprop="name headline">程式編寫 | 綜合整理 Kotlin 筆記</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">BlueWhaleYT</span><time itemprop="dateCreated datePublished" datetime="2023-12-01T06:49:09.000Z" title="發表於 2023 年 12 月 01 日 14 時 49 分 09 秒">2023 年 12 月 01 日</time><time itemprop="dateCreated datePublished" datetime="2023-12-03T04:36:40.586Z" title="更新於 2023 年 12 月 03 日 12 時 36 分 40 秒">2023 年 12 月 03 日</time></header><div class="note info simple"><p>使用的軟件是 Fleet，由 JetBrains 所研發的。</p>
</div>

<h1 id="入口點"><a href="#入口點" class="headerlink" title="入口點"></a>入口點</h1><p>入口點就是程式一開始在哪裏執行。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun main() &#123;
    print(&quot;hello world&quot;)
&#125;</code></pre>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://i.imgur.com/X9zVUFU.png&quot;" data-lazy-src="/post/dev-kotlin-integrated-notes/img1.png" alt="img1"></p>
<div class="note info simple"><p>Kotlin 的 <code>main.kt</code> 實際上是有類別的，它叫做 <code>MainKt</code>，因為 Kotlin 的編譯器歸根到底都是最後轉換到 Java</p>
</div>

<h2 id="修改入口點或類別名稱"><a href="#修改入口點或類別名稱" class="headerlink" title="修改入口點或類別名稱"></a>修改入口點或類別名稱</h2><p>因為一開始預設是 <code>MainKt</code>，要修改的這就要用 <code>@file:JvmName()</code> 註解，這個註解會直接修改 JVM。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@file:JvmName(&quot;Hello World Program&quot;)</code></pre>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://i.imgur.com/X9zVUFU.png&quot;" data-lazy-src="/post/dev-kotlin-integrated-notes/img2.png" alt="img2"></p>
<hr>
<h1 id="輸入數值"><a href="#輸入數值" class="headerlink" title="輸入數值"></a>輸入數值</h1><h2 id="使用操控台輸入"><a href="#使用操控台輸入" class="headerlink" title="使用操控台輸入"></a>使用操控台輸入</h2><p>在 Kotlin，不用 Java 這樣麻煩用 <code>Scanner</code> 來輸入數值至操控台 (console)，可以直接用 <code>readln()</code> 方法。不過，編譯器會<strong>推薦用 <code>readLineOrNull()</code></strong> ，因為這個可以檢查空指針，內部實現代碼純粹是返回一個 <code>String?</code>：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">public actual fun readlnOrNull(): String? &#x3D; readLine()</code></pre>

<div class="note info simple"><p><code>actual</code> 是跨平台（不限於 Compose 跨平台）用的，因為 Kotlin 語法庫支援 JVM 及 JS 編譯。</p>
</div>

<ol>
<li><p>基本使用</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">println(&quot;Enter two numbers&quot;)                &#x2F;&#x2F; 說明用戶輸入數值的目的

print(&quot;Enter a: &quot;) 
val a &#x3D; readlnOrNull()                      &#x2F;&#x2F; 用戶所輸入的值再按 Enter，會賦值至 a
print(&quot;Enter b: &quot;)
val b &#x3D; readlnOrNull()                      &#x2F;&#x2F; 用戶所輸入的值再按 Enter，會賦值至 b

println(&quot;Result: a: $a, b: $b&quot;)             &#x2F;&#x2F; 顯示結果</code></pre>
<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">Enter two numbers
Enter a: 5  
Enter b: 2
Result: a: 5, b: 2</code></pre>
</li>
<li><p>分割形式<br>例如想在單一輸入的時候，輸入多個數值，可以用 <code>split()</code> 裏面接受 <code>delimiters</code> 的 <code>vararg</code> 參數。</p>
<div class="note info simple"><p>這裏寫的是 <code>&quot; &quot;</code>，代表以空格分割。</p>
</div>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">println(&quot;Enter two numbers&quot;)

val (a, b) &#x3D; readln().split(&quot; &quot;)

println(&quot;Result: a: $a, b: $b&quot;)</code></pre>
<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">Enter two numbers
3 7
Result: a: 3, b: 7</code></pre></li>
</ol>
<h2 id="使用-GUI-視窗輸入"><a href="#使用-GUI-視窗輸入" class="headerlink" title="使用 GUI 視窗輸入"></a>使用 GUI 視窗輸入</h2><p>例如是用 Javax Swing 庫</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val num1 &#x3D; JOptionPane.showInputDialog(&quot;Enter first integer&quot;)
val num2 &#x3D; JOptionPane.showInputDialog(&quot;Enter second integer&quot;)

val result &#x3D; num1.toInt() + num2.toInt()
JOptionPane.showMessageDialog(null, &quot;sum: $result&quot;)</code></pre>

<hr>
<h1 id="套件與匯入"><a href="#套件與匯入" class="headerlink" title="套件與匯入"></a>套件與匯入</h1><p>Kotlin 預設匯入了這些套件</p>
<ul>
<li>Kotlin: <code>kotlin.*</code>、<code>kotlin.annotation.*</code>、<code>kotlin.collections.*</code>、<code>kotlin.comparisons.*</code>、<code>kotlin.io.*</code>、<code>kotlin.ranges.*</code>、<code>kotlin.sequences.*</code>、<code>kotlin.text.*</code></li>
<li>JVM: <code>java.lang.*</code>、<code>kotlin.jvm.*</code></li>
<li>JavaScript: <code>kotlin.js.*</code></li>
</ul>
<div class="note danger simple"><p>Kotlin 不支援靜態匯入 (<code>import static</code>)，只用 <code>import</code> 便可以。</p>
</div>

<h2 id="套件類別命名衝突"><a href="#套件類別命名衝突" class="headerlink" title="套件類別命名衝突"></a>套件類別命名衝突</h2><p>Kotlin 不支援套件類別名稱重複，需要用 <code>as</code> 關鍵字重新定義。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">import foo.a.Bar
import foo.b.Bar as BBar</code></pre>

<hr>
<h1 id="存取修飾子"><a href="#存取修飾子" class="headerlink" title="存取修飾子"></a>存取修飾子</h1><table>
<thead>
<tr>
<th>修飾子</th>
<th>Kotlin</th>
<th>Java</th>
</tr>
</thead>
<tbody><tr>
<td><code>public</code></td>
<td>所有類可存取 <strong>（預設）</strong></td>
<td>所有類可存取</td>
</tr>
<tr>
<td><code>private</code></td>
<td>當前類可存取</td>
<td>當前類可存取</td>
</tr>
<tr>
<td><code>protected</code></td>
<td>當前類、子類可存取</td>
<td>當前類、子類、同一套件路徑下的類可存取</td>
</tr>
<tr>
<td><code>default</code></td>
<td>無</td>
<td>同一套件路徑下的類可存取 <strong>（預設）</strong></td>
</tr>
<tr>
<td><code>internal</code></td>
<td>同一模組中的類可存取</td>
<td>無</td>
</tr>
</tbody></table>
<h2 id="可繼承類"><a href="#可繼承類" class="headerlink" title="可繼承類"></a>可繼承類</h2><p>Kotlin 預設寫的 <code>Class</code> 是不能繼承 (inherit) 的，如果要讓其他 <code>Class</code> 可繼承這個 <code>Class</code>，就要加 <code>open</code> 關鍵字。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">open class ClassA

class ClassB : ClassA()</code></pre>

<hr>
<h1 id="對象與建構式"><a href="#對象與建構式" class="headerlink" title="對象與建構式"></a>對象與建構式</h1><h2 id="單例模式-Singleton"><a href="#單例模式-Singleton" class="headerlink" title="單例模式 (Singleton)"></a>單例模式 (Singleton)</h2><p>我們可以使用 <code>object</code> 關鍵字來定義 Singleton，可以在其他地方使用 <code>SingletonObject</code> 來訪問其屬性和方法。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">object SingletonObject &#123;
    &#x2F;&#x2F; 屬性和方法
&#125;</code></pre>

<div class="note info simple"><p>Java 調用 Kotlin Singleton 需要加上 <code>INSTANCE</code>。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">SingletonObject.INSTANCE.xxx</code></pre></div>

<h2 id="伴生對象"><a href="#伴生對象" class="headerlink" title="伴生對象"></a>伴生對象</h2><p>我們可以使用 <code>companion object</code> 關鍵字在類內部定義一個伴生物件。伴生物件可以訪問類的私有成員，就像是該類的靜態成員一樣，但它不同於靜態成員，因為它可以訪問類的非靜態成員。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">class MyClass &#123;
    companion object &#123;
        &#x2F;&#x2F; 屬性和方法
    &#125;
&#125;</code></pre>

<div class="note info simple"><p>Java 調用 Kotlin Companion object 需要加上 <code>Companion</code>。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">MyClass.Companion.xxx</code></pre></div>

<h2 id="建構子建構"><a href="#建構子建構" class="headerlink" title="建構子建構"></a>建構子建構</h2><h3 id="主要建構子"><a href="#主要建構子" class="headerlink" title="主要建構子"></a>主要建構子</h3><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">class MyClass(
    val str: String
) &#123;
    &#x2F;&#x2F; ...
&#125;</code></pre>
<h3 id="次要-x2F-多個建構子"><a href="#次要-x2F-多個建構子" class="headerlink" title="次要 &#x2F; 多個建構子"></a>次要 &#x2F; 多個建構子</h3><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">class MyClass &#123;
    var prop1 &#x3D; &quot;&quot;
    var prop2 &#x3D; 0
    
    constructor(prop1: String) &#123;
        this.prop1 &#x3D; prop1
    &#125;
    
    constructor(prop2: Int) &#123;
        this.prop2 &#x3D; prop2
    &#125;
&#125;</code></pre>

<h3 id="初始化程式"><a href="#初始化程式" class="headerlink" title="初始化程式"></a>初始化程式</h3><p>用 <code>init</code> 函數可以初始化建構子執行的程式。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">class MyClass &#123;
    init &#123;
        println(&quot;$&#123;this.javaClass.name&#125; loaded&quot;)
    &#125;
&#125;
val myClass &#x3D; MyClass()</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">MyClass loaded</code></pre>

<hr>
<h1 id="運算符"><a href="#運算符" class="headerlink" title="運算符"></a>運算符</h1><h2 id="位元運算符"><a href="#位元運算符" class="headerlink" title="位元運算符"></a>位元運算符</h2><ol>
<li>按位取反 <code>inv</code>：取反後的數字會變成原數字的補數<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val num &#x3D; 10
val result &#x3D; num.inv()
print(result)                       &#x2F;&#x2F; 輸出：-11</code></pre>
<div class="note info simple"><p><code>inv()</code> 函數會將數字的二進位表示中的每個位元取反，也就是 <code>0</code> 變成 <code>1</code>，<code>1</code> 變成 <code>0</code>。另外，這個操作還會將數字的正負號反轉。<br><code>10</code> 的二進位表示為 <code>00001010</code>。當我們對這個數字進行取反操作時，每個位元都會取反，得到的結果為 <code>11110101</code>。這個結果在二進位中也代表著數字 <code>-11</code>。</p>
</div></li>
<li>左移 <code>shl</code> (<code>&lt;&lt;</code>)：將數字的二進位表示向左移動指定的位數。左移操作會在右側填入 <code>0</code>，相當於將該數字乘以 <code>2</code> 的 <code>n</code> 次方，其中 <code>n</code> 是左移的位數。<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val number &#x3D; 5                      &#x2F;&#x2F; 左移的數字是 5
val shift &#x3D; 2                       &#x2F;&#x2F; 左移的位數是 2
val result &#x3D; number shl shift
println(result)                     &#x2F;&#x2F; 輸出：20 (將 5 左移 2 位相當於 5 * (2^2) )</code></pre></li>
<li>右移 <code>shr</code> (<code>&gt;&gt;</code>)：將數字的二進位表示向右移動指定的位數。右移操作會在左側填入原數字的最高位元，相當於將該數字除以 <code>2</code> 的 <code>n</code> 次方，其中 <code>n</code> 是右移的位數。<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val number &#x3D; 20                     &#x2F;&#x2F; 右移的數字是 20
val shift &#x3D; 2                       &#x2F;&#x2F; 右移的位數是 2
val result &#x3D; number shr shift
println(result)                     &#x2F;&#x2F; 輸出：5 (將 20 右移 2 位相當於 20 &#x2F; (2^2) )</code></pre></li>
</ol>
<hr>
<h1 id="變量及常量"><a href="#變量及常量" class="headerlink" title="變量及常量"></a>變量及常量</h1><p>我們可以使用變量和常量來存儲和管理數據。變量是可以改變其值的存儲位置，而常量則是一旦被賦值就無法更改的存儲位置。</p>
<div class="note info simple"><p>賦值語句格式，萬變不離其宗</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">var 變量名稱: 數據類型 &#x3D; 初始值</code></pre></div>

<ol>
<li>宣告變量：使用關鍵字 <code>var</code> 來定義可變變量。<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">var age: Int &#x3D; 15</code></pre></li>
<li>宣告常量：使用關鍵字 <code>val</code> 來定義常量 (不可變變量)。<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val age: Int &#x3D; 15</code></pre></li>
</ol>
<h2 id="存取與變異"><a href="#存取與變異" class="headerlink" title="存取與變異"></a>存取與變異</h2><p>考慮到用 <code>var</code> 還是 <code>val</code>，還有一個考量就是 Getter &amp; Setter</p>
<ul>
<li><code>var</code>：<code>private</code> 變量，但賦有 <code>public</code> 的 <code>set()</code> 和 <code>get()</code> 屬性</li>
<li><code>val</code>：<code>private</code> 變量，賦有 <code>public</code> 的 <code>get()</code> 屬性</li>
</ul>
<div class="note info simple"><p>一般而言，如果不肯定變量能不能被修改，就先用 <code>val</code>，當有修改的用途就改用 <code>var</code>。</p>
</div>

<p>此外，還有 <code>const</code> 關鍵字，看似與 <code>val</code> 能混為一談</p>
<p><code>const</code> 與 Java 的 <code>static</code> 相若，一般情況下，用不用 <code>const</code> 是絕沒太大影響，重點是</p>
<div class="note info simple"><ol>
<li><code>const</code> 變量必須是頂層級別 (top-level) 或者 <code>object</code> 或 <code>companion object</code> 中的屬性</li>
<li><code>val</code> 是在運行時計算；而 <code>const</code> 則是編譯時計算。</li>
<li>預設的 <code>val</code> 是私有 (<code>private</code>) 變量，當加上了 <code>const</code> 變成 <code>const val</code> 就會成為公共 (<code>public</code>) 變量。</li>
</ol>
</div>

<p>例子：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val hello &#x3D; test()          &#x2F;&#x2F; 編譯成功
const val DATA &#x3D; test()     &#x2F;&#x2F; 編譯錯誤
const val NAME &#x3D; &quot;&quot;         &#x2F;&#x2F; 編譯成功

fun test() &#x3D; &quot;&quot;</code></pre>

<hr>
<h1 id="函數"><a href="#函數" class="headerlink" title="函數"></a>函數</h1><p>函數是一個重要的程式結構，它可以接受輸入參數並返回一個結果。我們可以使用 <code>fun</code> 關鍵字來定義一個函數。</p>
<div class="note info simple"><p>函數預設返回的類型為 <code>Unit</code>，即是 Java 的 <code>void</code> 類型。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun greet1(): Unit &#123;
    print(&quot;Good morning&quot;)
&#125;

fun greet2() &#123;
    print(&quot;Good morning&quot;)
&#125;</code></pre>
<p><code>greet1()</code> 和 <code>greet2()</code> 方法是一樣的，基本上 <code>Unit</code> 可以省略不寫。</p>
</div>

<h2 id="函數類型"><a href="#函數類型" class="headerlink" title="函數類型"></a>函數類型</h2><h3 id="單行表達式"><a href="#單行表達式" class="headerlink" title="單行表達式"></a>單行表達式</h3><p>如果函數<strong>只有一行程式碼</strong>，可以使用單行表達式函數的語法簡化函數的定義。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun multiply(a: Int, b: Int): Int &#x3D; a * b</code></pre>

<div class="note info simple"><ol>
<li><p>這裏的 <code>=</code> 等同於 <code>return</code></p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun multiply(a: Int, b: Int): Int &#123;
    return a * b
&#125;</code></pre>
</li>
<li><p>返回類型可省略</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun multiply(a: Int, b: Int) &#x3D; a * b</code></pre></li>
</ol>
</div>

<h3 id="高階函數"><a href="#高階函數" class="headerlink" title="高階函數"></a>高階函數</h3><p>函數可以作為參數傳遞給其他函數，或者作為返回值返回。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun calculate(a: Int, b: Int, operation: (Int, Int) -&gt; Int): Int &#123;
    return operation(a, b)
&#125;</code></pre>

<div class="note info simple"><p><code>calculate()</code> 接受 3 個參數，其中 <code>operation</code> 參數比較複雜，這個運用了高階函數，接受兩個參數然後再返回一個 <code>Int</code> 類型的結果，至於是怎樣的結果，就是視乎 <code>operation()</code> 高階函數實現的邏輯。</p>
<p>假如我們用 <code>calculate()</code> 函數實現一個加法及乘法計算，需要一對 <code>{}</code> 區塊，區塊內需要傳入參數，就以 <code>x</code> 和 <code>y</code> 分別是對入 <code>operation(Int, Int)</code>，接著 <code>-&gt;</code> 後寫的代碼就是要實現的邏輯。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val sum &#x3D; calculate(3, 5) &#123; x, y -&gt; x + y &#125;
val product &#x3D; calculate(8, 3) &#123; x, y -&gt; x * y &#125;

print(&quot;sum: $sum, product: $product&quot;)</code></pre>
<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">sum: 8, product: 24</code></pre></div>

<h4 id="內聯函數"><a href="#內聯函數" class="headerlink" title="內聯函數"></a>內聯函數</h4><p><code>inline</code> 函數會在代碼編譯時，將被調用處代碼直接嵌入到調用處的函數中</p>
<div class="note warning simple"><p>過度使用 <code>inline</code> 會使字節碼膨脹。</p>
</div>

<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">&#x2F;&#x2F; 一般如果是這樣的程式碼，不會用 inline
inline fun hello() &#x3D; print(&quot;Hello World&quot;)

&#x2F;&#x2F; 如果沒有用 inline 來定義 hello() 函數
fun main() &#123;
    hello()
&#125;

&#x2F;&#x2F; 如果有用 inline 來定義 hello() 函數
fun main() &#123;
    print(&quot;Hello World&quot;)    &#x2F;&#x2F; 直接把 hello() 函數的代碼嵌入下來
&#125;</code></pre>

<p>實際用途是用來減少創建額外對象及函數，從而減少資源消耗。亦都增加執行速度（順序執行代碼的速度會較調用函數的速度快）。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">inline fun hello(block: () -&gt; Unit) &#123;
    println(&quot;Hello World&quot;)
    block()
&#125;

&#x2F;&#x2F; 你寫的程式碼
fun main() &#123;
    hello &#123;
        println(&quot;123&quot;)
    &#125;
&#125;

&#x2F;&#x2F; 實際編譯後的程式碼
fun main() &#123;
    println(&quot;Hello World&quot;)
    println(&quot;123&quot;)          &#x2F;&#x2F; 把 hello() 函數區塊內的程式碼嵌入下來
&#125;</code></pre>

<p>為 <code>inline</code> 函數使用的參數設定</p>
<p><code>noinline</code>：就是不內聯的意思</p>
<p>如果我們嘗試寫</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">inline fun hello(block: () -&gt; Unit): () -&gt; Unit &#123;
    println(&quot;Hello World&quot;)
    return block
&#125;</code></pre>
<p>因為 <code>hello()</code> 函數被內聯了，如果嘗試傳回 <code>block</code>，會在編譯器拋出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://i.imgur.com/X9zVUFU.png&quot;" data-lazy-src="/post/dev-kotlin-integrated-notes/img6.png" alt="img6"></p>
<p>所以這個時候就要用 <code>noinline</code></p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">inline fun hello(noinline block: () -&gt; Unit): () -&gt; Unit &#123;
    println(&quot;Hello World&quot;)
    return block
&#125;</code></pre>

<p><code>crossinline</code>：強制內聯</p>
<h4 id="infix-函數"><a href="#infix-函數" class="headerlink" title="infix 函數"></a><code>infix</code> 函數</h4><p>不需要用 <code>()</code> 的函數</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">infix fun Int.add(count: Int) &#x3D; this + count

val result1 &#x3D; 5 add 3
println(&quot;Result: $result1&quot;)     &#x2F;&#x2F; 輸出：8</code></pre>

<h4 id="operator-函數"><a href="#operator-函數" class="headerlink" title="operator 函數"></a><code>operator</code> 函數</h4><p>就是重載運算符的函數，例如 <code>1 + 1</code>，對應的函數是 <code>plus()</code></p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val point &#x3D; Point(2, 3)
val a &#x3D; 1
val b &#x3D; a + point       &#x2F;&#x2F; 錯誤</code></pre>

<p>假如，我們嘗試把不支援的型別與例如 <code>Int</code> 相加，會在編譯時拋出錯誤：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://i.imgur.com/X9zVUFU.png&quot;" data-lazy-src="/post/dev-kotlin-integrated-notes/img5.png" alt="img5"></p>
<p>要令到這個 <code>+</code> 運算符可以用其他類型 e.g. <code>Point</code> 進行加法，就要用 <code>operator fun</code>。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">operator fun Int.plus(other: Point) &#x3D; this + other.x + other.y

val point &#x3D; Point(2, 3)
val a &#x3D; 1
val b &#x3D; a + point
print(&quot;b: $b&quot;)      &#x2F;&#x2F; 輸出 b: 6</code></pre>

<p>運算符函數表</p>
<table>
<thead>
<tr>
<th>運算符</th>
<th>函數</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td><code>plus()</code></td>
</tr>
<tr>
<td><code>-</code></td>
<td><code>minus()</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td><code>times()</code></td>
</tr>
<tr>
<td><code>/</code></td>
<td><code>div()</code></td>
</tr>
<tr>
<td><code>%</code></td>
<td><code>mod()</code> &#x2F; <code>rem()</code></td>
</tr>
<tr>
<td><code>++</code></td>
<td><code>inc()</code></td>
</tr>
<tr>
<td><code>!</code></td>
<td><code>not()</code></td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td><code>compareTo() &gt; 0</code></td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td><code>compareTo() &lt; 0</code></td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td><code>compareTo() &gt;= 0</code></td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td><code>compareTo &lt;= 0</code></td>
</tr>
<tr>
<td><code>in</code></td>
<td><code>contains()</code></td>
</tr>
</tbody></table>
<h3 id="匿名函數"><a href="#匿名函數" class="headerlink" title="匿名函數"></a>匿名函數</h3><p>匿名函數可使用 <code>fun()</code> 定義，並作為值賦值給變數。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val sum &#x3D; fun(a: Int, b: Int) &#x3D; a + b
val result &#x3D; sum(4, 6)

print(&quot;sum: $result&quot;)</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">sum: 10</code></pre>

<h3 id="標準-x2F-作用域函數"><a href="#標準-x2F-作用域函數" class="headerlink" title="標準 &#x2F; 作用域函數"></a>標準 &#x2F; 作用域函數</h3><p>這些函數可以幫助我們<strong>簡化程式碼並提高可讀性</strong>，對代碼邏輯沒有任何意義，只是語法糖。用途很廣泛，而且看情況。</p>
<table>
<thead>
<tr>
<th>函數</th>
<th>對象引用</th>
<th>返回值</th>
<th>是否擴展函數</th>
</tr>
</thead>
<tbody><tr>
<td><code>let</code></td>
<td><code>it</code></td>
<td>Lambda 表達式</td>
<td>是</td>
</tr>
<tr>
<td><code>run</code></td>
<td><code>this</code></td>
<td>Lambda 表達式</td>
<td>是</td>
</tr>
<tr>
<td><code>run</code></td>
<td>-</td>
<td>Lambda 表達式</td>
<td>不是，調用毋須 <code>Context</code></td>
</tr>
<tr>
<td><code>with</code></td>
<td><code>this</code></td>
<td>Lambda 表達式</td>
<td>不是，把 <code>Context</code> 當作參數</td>
</tr>
<tr>
<td><code>apply</code></td>
<td><code>this</code></td>
<td><code>Context</code></td>
<td>是</td>
</tr>
<tr>
<td><code>also</code></td>
<td><code>it</code></td>
<td><code>Context</code></td>
<td>是</td>
</tr>
</tbody></table>
<div class="note info simple"><ul>
<li><code>this</code>：當前引用的對象，例如 <code>this.text = ...</code> 可省略為 <code>text = ...</code>。</li>
<li><code>it</code>：常用於 Lambda 表達式，作為<strong>顯式單個參數聲明</strong>的暫代名稱，只可以為單個參數的函數，才可用 <code>it</code>。</li>
</ul>
<p>如果暫不使用參數，可用 <code>_</code> 作為佔位，未使用的參數，不會進行處理。</p>
</div>

<h4 id="let-函數"><a href="#let-函數" class="headerlink" title="let 函數"></a><code>let</code> 函數</h4><ol>
<li>對非空型別對象執行 Lambda 表達式<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val name: String? &#x3D; &quot;John&quot;
name?.let &#123;
    &#x2F;&#x2F; 在這裡可以使用非空的 name 變數
    println(&quot;Hello, $it!&quot;)
&#125;</code></pre></li>
<li>把表達式作為變量引入到局部作用域中<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val number &#x3D; 5
val doubled &#x3D; number.let &#123; it * 2 &#125;
println(doubled)            &#x2F;&#x2F; 輸出：10</code></pre></li>
</ol>
<h4 id="run-函數"><a href="#run-函數" class="headerlink" title="run 函數"></a><code>run</code> 函數</h4><p>跟 <code>apply</code> 函數用法相若，但 <code>run</code> 函數會傳回 Lambda 表達式，<code>apply</code> 函數沒有傳回值。而且<strong>可以為特定對象編寫邏輯</strong>，最後運算取得結果。</p>
<ol>
<li>擴展：對象配置並且計算結果<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val result &#x3D; &quot;Hello, Kotlin&quot;.run &#123;
    println(this)           &#x2F;&#x2F; 輸出：Hello, Kotlin
    length
&#125;
println(result)             &#x2F;&#x2F; 輸出：13</code></pre></li>
<li>非擴展：在需要表達式的地方執行語句<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val message &#x3D; run &#123;
    val greeting &#x3D; &quot;Hello&quot;
    val person &#x3D; &quot;Alice&quot;
    &quot;$greeting, $person!&quot;   &#x2F;&#x2F; 返回的值一定要放最後
&#125;
println(message)            &#x2F;&#x2F; 輸出：Hello, Alice!</code></pre></li>
</ol>
<h4 id="apply-函數"><a href="#apply-函數" class="headerlink" title="apply 函數"></a><code>apply</code> 函數</h4><p>可視為一種配置函數，傳入一個接收者，然後呼叫一系列函數來對接收者做設定。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">class Person &#123;
    var name: String? &#x3D; null
    var age: Int? &#x3D; null
&#125;

val person &#x3D; Person().apply &#123;
    name &#x3D; &quot;Alice&quot;
    age &#x3D; 25
&#125;</code></pre>

<h4 id="also-函數"><a href="#also-函數" class="headerlink" title="also 函數"></a><code>also</code> 函數</h4><p>附加效果，<code>also</code> 適合針對同一原始物件，透過副作用做事。當看到 <code>also</code> 的時候表示，同時還要針對該對象物件執行此動作。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val numbers &#x3D; mutableListOf(1, 2, 3)
val doubledNumbers &#x3D; numbers.also &#123;
    it.forEachIndexed &#123; index, value -&gt;
        it[index] &#x3D; value * 2
    &#125;
&#125;
println(doubledNumbers) &#x2F;&#x2F; 輸出：[2, 4, 6]</code></pre>

<h4 id="with-函數"><a href="#with-函數" class="headerlink" title="with 函數"></a><code>with</code> 函數</h4><p>一個對象的一組函數調用，<code>with</code> 函數是 <code>run</code> 函數的變形：他們的功能與行為一樣，接收者是使用 <code>with</code> 的對象物件。</p>
<div class="note warning simple"><p>但 <code>with</code> 的呼叫方式不同，使用 <code>with</code> 時，<strong>要求引數作為其第一個參數傳入</strong>，另外，若執行 <code>run</code> 的對象物件為 <code>null</code> ，則 <code>run</code> 區塊不會進入；反之， <code>with</code> 函數則是會進去操作。</p>
</div>

<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">data class Person(val name: String, val age: Int)

val person &#x3D; Person(&quot;Alice&quot;, 25)
with(person) &#123;
    println(&quot;Name: $name&quot;)
    println(&quot;Age: $age&quot;)
&#125;</code></pre>

<h3 id="擴展函數"><a href="#擴展函數" class="headerlink" title="擴展函數"></a>擴展函數</h3><p>允許我們<strong>為現有的類型添加新的函數</strong>，而不需要修改原始類型的程式碼。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun Int.isEven(): Boolean &#123;
    return this % 2 &#x3D;&#x3D; 0
&#125;

val number &#x3D; 5
println(number.isEven())        &#x2F;&#x2F; 輸出：false</code></pre>

<div class="note info simple"><p>這裏的 <code>this</code> 是指 <code>fun Int</code> 的 <code>Int</code> 型別，這個 <code>Int</code> 是一個接收者 (receiver)。</p>
<p>善用擴展函數可減少編寫 Utils 複用工具函數。</p>
</div>

<details class="folding-tag"><summary> 轉換為 Java 後的程式碼 </summary>
              <div class="content">
              <p>實際上有一個隱藏的類別會產生，根據檔案名稱如 <code>Extension.kt</code>，那就會在編譯過程生成 <code>ExtensionKt.class</code>，大概的 Java 程式碼就是：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ExtensionKt &#123;
    public static boolean isEven(receiver: Int) &#123; ... &#125;
&#125;</code></pre><p><code>receiver</code> 會在編譯過程寫入作為參數</p>
              </div>
            </details>

<h1 id="範圍"><a href="#範圍" class="headerlink" title="範圍"></a>範圍</h1><p>範圍 (Ranges) 是一個連續的數值區間，我們可以使用範圍來表示一系列連續的數字或字符。在 Kotlin 中，我們可以使用 <code>..</code> 運算符來創建一個範圍。範圍的起始值和結束值可以是整數、字符或其他可比較的型別。</p>
<ol>
<li><p>升序 (ascending)</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">for (i in 1..4) print(i)            &#x2F;&#x2F; 輸出 &quot;1234&quot;</code></pre>
<div class="note info simple"><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://i.imgur.com/X9zVUFU.png&quot;" data-lazy-src="/post/dev-kotlin-integrated-notes/img3.png" alt="img3"></p>
<p>如果啟用了嵌入提示 (Inlay Hint)，可以看到 <code>..</code> 有 <code>&lt;=</code> 的意思。</p>
</div>
</li>
<li><p>降序 (descending)</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">for (i in 4 downTo 1) print(i)      &#x2F;&#x2F; 輸出 &quot;4321&quot;</code></pre>
<div class="note info simple"><p>而 <code>downTo</code> 則有 <code>&gt;=</code> 的意思。</p>
</div>
<div class="note danger simple"><p>降序不是這樣做：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">for (i in 4..1) print(i)            &#x2F;&#x2F; 沒有輸出</code></pre>

<p>編譯器會跟你說範圍是空的，因為 <code>4 &lt;= 1</code> 是異想天開的事。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://i.imgur.com/X9zVUFU.png&quot;" data-lazy-src="/post/dev-kotlin-integrated-notes/img4.png" alt="img4"></p>
</div>
</li>
<li><p>略過及調整步長 <code>step</code><br>例如是偶數</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">for (i in 2..10 step 2) print(i)    &#x2F;&#x2F; 輸出：246810</code></pre>
</li>
<li><p>直至 <code>until</code></p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">for (i in 1 until 10) print(i)      &#x2F;&#x2F; 輸出：123456789 (不計算 10)</code></pre></li>
</ol>
<h2 id="範圍函數"><a href="#範圍函數" class="headerlink" title="範圍函數"></a>範圍函數</h2><p>不一定只用在迴圈，亦可以以函數方式使用</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val descendingNumbers &#x3D; 5.downTo(1)
val evenNumbers &#x3D; (2..10).step(2)

println(&quot;Descending numbers:&quot;)
for (number in descendingNumbers) &#123;
    println(number)
&#125;

println(&quot;Even numbers:&quot;)
for (number in evenNumbers) &#123;
    println(number)
&#125;</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">Descending numbers:
5
4
3
2
1
Even numbers:
2
4
6
8
10</code></pre>

<hr>
<h1 id="陣列"><a href="#陣列" class="headerlink" title="陣列"></a>陣列</h1><p>陣列 (又稱數組) 是一種常用的資料結構，它可以儲存一組相同類型的元素。</p>
<h2 id="用-arrayOf-函數建立基本陣列"><a href="#用-arrayOf-函數建立基本陣列" class="headerlink" title="用 arrayOf() 函數建立基本陣列"></a>用 <code>arrayOf()</code> 函數建立基本陣列</h2><ol>
<li>空陣列<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val empty &#x3D; arrayOf&lt;String&gt;()</code></pre></li>
<li>一般陣列<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val numbers &#x3D; arrayOf(1, 2, 3, 4, 5)</code></pre></li>
</ol>
<h2 id="用-Array-建立不同陣列"><a href="#用-Array-建立不同陣列" class="headerlink" title="用 Array() 建立不同陣列"></a>用 <code>Array()</code> 建立不同陣列</h2><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val names &#x3D; Array(3) &#123; &quot;&quot; &#125;                          &#x2F;&#x2F; 預設是空陣列，設置了陣列大小為 3
names[0] &#x3D; &quot;Alice&quot;
names[1] &#x3D; &quot;Bob&quot;
names[2] &#x3D; &quot;Carol&quot;

println(&quot;Array of names: $names&quot;)
println(&quot;The first item of names: $&#123;names[0]&#125;&quot;)      &#x2F;&#x2F; 獲取 names 陣列首項元素
println(&quot;The size of names array: $&#123;names.size&#125;&quot;)    &#x2F;&#x2F; 獲取 names 陣列大小
</code></pre>

<div class="note info simple"><p>陣列的索引從 <code>0</code> 開始，所以 <code>names[0]</code> 代表陣列中的第一個元素。</p>
</div>

<h3 id="二維陣列"><a href="#二維陣列" class="headerlink" title="二維陣列"></a>二維陣列</h3><p>例如一個 <code>2 x 2</code> 的二維陣列</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val matrix &#x3D; Array(2) &#123; IntArray(2) &#125;
matrix[0][0] &#x3D; 1
matrix[0][1] &#x3D; 2
matrix[1][0] &#x3D; 3
matrix[1][1] &#x3D; 4

val element &#x3D; matrix[1][0]
println(&quot;matrix[1][0] 的值為 $element&quot;)</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">matrix[1][0] 的值為 3</code></pre>

<h3 id="三維陣列"><a href="#三維陣列" class="headerlink" title="三維陣列"></a>三維陣列</h3><p>例如一個 <code>2 x 3 x 4</code> 的三維陣列</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val cube &#x3D; Array(2) &#123; Array(3) &#123; IntArray(4) &#125; &#125;
cube[0][0][0] &#x3D; 1
cube[0][1][2] &#x3D; 2
cube[1][2][3] &#x3D; 3

val element &#x3D; cube[0][1][2]
println(&quot;cube[0][1][2] 的值為 $element&quot;)</code></pre>

<div class="note info simple"><p>這個 <code>2 x 3 x 4</code> 是假想三維空間的 <code>x</code> 軸、<code>y</code> 軸及 <code>z</code> 軸測量指標，其中 <code>x</code> 軸有 2 個元素，<code>y</code> 軸有 3 個元素，<code>z</code> 軸有 4 個元素。</p>
<p>以一個立方體來比喻的話，我們可以把 <code>x</code> 軸想像成立方體的寬度，<code>y</code> 軸想像成高度，<code>z</code> 軸想像成深度。而 <code>2 x 3 x 4</code> 的意思就是這個立方體有 2 個寬度、3 個高度和 4 個深度。</p>
</div>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">cube[0][1][2] 的值為 2</code></pre>

<hr>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合 (Collections) 是在程式開發中非常重要的一個主題，它們可以讓我們有效地儲存和操作多個元素。</p>
<div class="note info simple"><p>集合與陣列一樣，索引由 <code>0</code> 開始，即是第一個元素。</p>
</div>

<h2 id="集合類型"><a href="#集合類型" class="headerlink" title="集合類型"></a>集合類型</h2><h3 id="有序集合-List-列表"><a href="#有序集合-List-列表" class="headerlink" title="有序集合 List (列表)"></a>有序集合 <code>List</code> (列表)</h3><p>是一個有序的集合，可以包含重複的元素。我們可以使用索引來訪問和修改列表中的元素。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val numbers &#x3D; listOf(1, 2, 3, 4, 5)                             &#x2F;&#x2F; 定義不可變列表
val mutableNumbers &#x3D; mutableListOf(1, 2, 3, 4, 5)               &#x2F;&#x2F; 定義可變列表

println(&quot;List of numbers: $numbers&quot;)
println(&quot;List of mutableNumbers: $mutableNumbers&quot;)              &#x2F;&#x2F; 舊輸出

println(&quot;The first item of numbers: $&#123;numbers[0]&#125;&quot;)

mutableNumbers.add(6)                                           &#x2F;&#x2F; 為 mutableNumbers 新增一個元素為 6
println(&quot;New number for mutableNumbers: $&#123;mutableNumbers[5]&#125;&quot;)
println(&quot;List of mutableNumbers: $mutableNumbers&quot;)              &#x2F;&#x2F; 新輸出</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">List of numbers: [1, 2, 3, 4, 5]
List of mutableNumbers: [1, 2, 3, 4, 5]
The first item of numbers: 1
The newly added number for mutableNumbers: 6
List of mutableNumbers: [1, 2, 3, 4, 5, 6]</code></pre>

<h3 id="無序集合-Set-集合"><a href="#無序集合-Set-集合" class="headerlink" title="無序集合 Set (集合)"></a>無序集合 <code>Set</code> (集合)</h3><p>是一個不重複元素的集合，並且沒有特定的順序。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val fruits &#x3D; setOf(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;, &quot;orange&quot;)
val mutableFruits &#x3D; mutableSetOf(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;, &quot;orange&quot;)

println(&quot;Set of fruits: $fruits&quot;)
println(&quot;Set of mutableFruits: $mutableFruits&quot;)</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">Set of fruits: [apple, banana, orange]
Set of mutableFruits: [apple, banana, orange]</code></pre>

<p>相反，如果用 <code>List</code>，則會連同重複元素輸出：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val fruits &#x3D; listOf(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;, &quot;orange&quot;)
val mutableFruits &#x3D; mutableListOf(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;, &quot;orange&quot;)

println(&quot;List of fruits: $fruits&quot;)
println(&quot;List of mutableFruits: $mutableFruits&quot;)</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">List of fruits: [apple, banana, orange, orange]
List of mutableFruits: [apple, banana, orange, orange]</code></pre>

<h3 id="鍵值對集合-Map-映射"><a href="#鍵值對集合-Map-映射" class="headerlink" title="鍵值對集合 Map (映射)"></a>鍵值對集合 <code>Map</code> (映射)</h3><p>是一個鍵值對 (key-value) 的集合，每個元素都有一個唯一的鍵和對應的值。我們可以使用鍵來獲取相應的值。</p>
<div class="note info simple"><p>用 <code>to</code> 關鍵字進行鍵值對，格式：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val map &#x3D; mapOf(鍵 1 to 值 1, 鍵 2 to 值 2, ...)</code></pre></div>

<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val person &#x3D; mapOf(
    &quot;name&quot; to &quot;Steve&quot;,
    &quot;age&quot; to 15
)
val mutablePerson &#x3D; mutableMapOf(
    &quot;name&quot; to &quot;Heidi&quot;,
    &quot;age&quot; to 23
)

println(&quot;Map of person: $person&quot;)
println(&quot;Map of mutablePerson: $mutablePerson&quot;)     &#x2F;&#x2F; 舊輸出

println(&quot;The name of person: $&#123;person[&quot;name&quot;]&#125;&quot;)

mutablePerson[&quot;gender&quot;] &#x3D; &quot;F&quot;                       &#x2F;&#x2F; 為 mutablePerson 新增 gender 屬性，並設置為 &quot;F&quot; (女性)
println(&quot;Map of mutablePerson: $mutablePerson&quot;)     &#x2F;&#x2F; 新輸出</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">Map of person: &#123;name&#x3D;Steve, age&#x3D;15&#125;
Map of mutablePerson: &#123;name&#x3D;Heidi, age&#x3D;23&#125;
The name of person: Steve
Map of mutablePerson: &#123;name&#x3D;Heidi, age&#x3D;23, gender&#x3D;F&#125;</code></pre>

<h2 id="集合函數操作"><a href="#集合函數操作" class="headerlink" title="集合函數操作"></a>集合函數操作</h2><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val numbers &#x3D; listOf(1, 2, 3, 4, 5)
    
val evenNumbers &#x3D; numbers.filter &#123; it % 2 &#x3D;&#x3D; 0 &#125;            &#x2F;&#x2F; 篩選出偶數
val doubleNumbers &#x3D; numbers.map &#123; it * 2 &#125;                  &#x2F;&#x2F; 把每個數字都加倍
val sum &#x3D; numbers.reduce &#123; acc, i -&gt; acc + i &#125;              &#x2F;&#x2F; 計算總和 (即 1 + 2 + 3 + 4 + 5)

println(&quot;evenNumbers: $evenNumbers&quot;)
println(&quot;doubleNumbers: $doubleNumbers&quot;)
println(&quot;sum: $sum&quot;)</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">evenNumbers: [2, 4]
doubleNumbers: [2, 4, 6, 8, 10]
sum: 15</code></pre>

<div class="note info simple"><ul>
<li><code>filter</code>：返回的是 <code>Boolean</code> 型別</li>
<li><code>map</code>：對集合進行不同操作，沒有指定返回型別</li>
<li><code>reduce</code>：累積函數，第一個參數 <code>acc</code> (accumulation) 是用來疊加的返回值，第二個參數 <code>i</code> 是本次循環中列表的值</li>
<li><code>fold</code>：與 <code>reduce</code> 相似，但可設定初始值</li>
</ul>
</div>

<hr>
<h1 id="列舉"><a href="#列舉" class="headerlink" title="列舉"></a>列舉</h1><p>列舉是一組相關的常量的集合，它們可以幫助我們更好地組織和表示程式中的數據。在 Kotlin 中，我們可以使用 <code>enum class</code> 關鍵字來定義一個列舉類。</p>
<ol>
<li><p>基本列舉</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">enum class Direction &#123;
    NORTH, SOUTH, EAST, WEST
&#125;

val direction &#x3D; Direction.NORTH
println(direction)      &#x2F;&#x2F; 輸出：NORTH</code></pre>
</li>
<li><p>列舉初始值：可以像一般建構式擁有屬性和方法。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">enum class Color(val rgb: Int) &#123;
    RED(0xFF0000),
    GREEN(0x00FF00),
    BLUE(0x0000FF);

    fun printRgb() &#123;
        println(&quot;RGB value: $rgb&quot;)
    &#125;
&#125;

val color &#x3D; Color.RED
println(color.rgb)      &#x2F;&#x2F; 輸出：16711680
color.printRgb()        &#x2F;&#x2F; 輸出：RGB value: 16711680</code></pre></li>
</ol>
<hr>
<h1 id="註解"><a href="#註解" class="headerlink" title="註解"></a>註解</h1><p>註解 (Annotations) 是一種用於在程式碼中添加元數據（metadata）的特殊標記。它們可以應用於類、函數、變數等元素上，並提供額外的資訊給編譯器、工具或其他程式碼分析工具。</p>
<ol>
<li><p>使用 Kotlin 內建註解</p>
<table>
<thead>
<tr>
<th>註解</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>@JvmStatic</code></td>
<td>用於將 Kotlin 中的伴生對象（companion object）中的函數或屬性轉換為 Java 中的靜態函數或靜態屬性。</td>
</tr>
<tr>
<td><code>@JvmOverloads</code></td>
<td>用於在 Kotlin 中生成重載函數的所有可能的組合。</td>
</tr>
<tr>
<td><code>@Deprecated</code></td>
<td>標記已被棄用的函數、類或屬性，並提供一個建議的替代方案。</td>
</tr>
</tbody></table>
</li>
<li><p>編寫自訂註解</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">annotation class MyAnnotation

@MyAnnotation
class MyClass &#123;
    @MyAnnotation
    fun myFunction() &#123;
        &#x2F;&#x2F; 函數內容
    &#125;
&#125;</code></pre></li>
</ol>
<h2 id="元資訊"><a href="#元資訊" class="headerlink" title="元資訊"></a>元資訊</h2><table>
<thead>
<tr>
<th>元資訊</th>
<th>用途</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Target</code></td>
<td>用於指定註解可以應用的元素類型</td>
<td>如 <code>@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION)</code> 可以應用於類和函數上</td>
</tr>
<tr>
<td><code>@Retension</code></td>
<td>用於指定註解在編譯後的保留策略</td>
<td>例如 <code>@Retention(AnnotationRetention.RUNTIME)</code> 表示該註解在運行時仍然可用</td>
</tr>
<tr>
<td><code>@Repeatable</code></td>
<td>用於指定註解是否可以重複應用於同一個元素。通常，一個元素只能擁有一個特定註解的實例</td>
<td></td>
</tr>
<tr>
<td><code>@MustBeDocumented</code></td>
<td>用於指示該註解應該包含在生成的 API 文檔中</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><code>@Repeatable</code><br>通常，一個元素只能擁有一個特定註解的實例。但是，如果你將 <code>@Repeatable</code> 註解應用於註解定義上，則可以多次應用該註解於同一個元素。這需要使用一個容器註解來包裹重複的註解。<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Repeatable
annotation class MyAnnotation(val name: String)

@MyAnnotation(&quot;A&quot;)
@MyAnnotation(&quot;B&quot;)
class MyClass &#123;
    &#x2F;&#x2F; ...
&#125;</code></pre></li>
</ul>
<p>例子</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Target(AnnotationTarget.CONSTRUCTOR, AnnotationTarget.LOCAL_VARIABLE)
@Retention(AnnotationRetention.SOURCE)
@MustBeDocumented
annotation class MyAnnotation

class MyClass @MyAnnotation constructor(val count: Int) &#123;
    fun display()&#123;
        println(&quot;Constructor annotated&quot;)
        println(&quot;Count is $count&quot;)
    &#125;
&#125;

fun main() &#123;
    val obj &#x3D; MyClass(5)
    obj.display()
    @MyAnnotation val str &#x3D; &quot;Hello&quot; 
    println(&quot;Local parameter annotated&quot;)
    println(str)
&#125;</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">Constructor annotated
Count is 5
Local parameter annotated
Hello</code></pre>

<hr>
<h1 id="條件判斷"><a href="#條件判斷" class="headerlink" title="條件判斷"></a>條件判斷</h1><h2 id="決策邏輯"><a href="#決策邏輯" class="headerlink" title="決策邏輯"></a>決策邏輯</h2><h3 id="if-語句"><a href="#if-語句" class="headerlink" title="if 語句"></a><code>if</code> 語句</h3><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val age &#x3D; 18
if (age &gt;&#x3D; 18) &#123;
    println(&quot;你已經成年了&quot;)
&#125; else &#123;
    println(&quot;你還未成年&quot;)
&#125;</code></pre>

<h3 id="else-if-語句"><a href="#else-if-語句" class="headerlink" title="else if 語句"></a><code>else if</code> 語句</h3><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val grade &#x3D; 75
if (grade &gt;&#x3D; 90) &#123;
    println(&quot;A&quot;)
&#125; else if (grade &gt;&#x3D; 80) &#123;
    println(&quot;B&quot;)
&#125; else if (grade &gt;&#x3D; 70) &#123;
    println(&quot;C&quot;)
&#125; else &#123;
    println(&quot;D&quot;)
&#125;</code></pre>

<h3 id="單行-if-表達式"><a href="#單行-if-表達式" class="headerlink" title="單行 if 表達式"></a>單行 <code>if</code> 表達式</h3><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val score &#x3D; 80
val result &#x3D; if (score &gt;&#x3D; 60) &quot;及格&quot; else &quot;不及格&quot;
println(result)</code></pre>

<h2 id="情況邏輯"><a href="#情況邏輯" class="headerlink" title="情況邏輯"></a>情況邏輯</h2><p><code>when</code> 表達式類似於 Java 使用的 <code>switch</code> 語句，可以用於根據不同的值執行不同的程式邏輯。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val dayOfWeek &#x3D; 3
when (dayOfWeek) &#123;
    1 -&gt; println(&quot;星期一&quot;)
    2 -&gt; println(&quot;星期二&quot;)
    3 -&gt; println(&quot;星期三&quot;)
    4 -&gt; println(&quot;星期四&quot;)
    5 -&gt; println(&quot;星期五&quot;)
    else -&gt; println(&quot;週末&quot;)
&#125;</code></pre>

<p><code>when</code> 比 Java 的 <code>switch</code> 更勝一籌，表達式還可以用於檢查範圍、類型和其他條件。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val names &#x3D; listOf(&quot;John&quot;, &quot;Sarah&quot;, &quot;Tim&quot;, &quot;Maggie&quot;) 
when (x) &#123;
    in names -&gt; print(&quot;I know that name!&quot;)
    !in 1..10 -&gt; print(&quot;Argument was not in the range from 1 to 10&quot;)
    is String -&gt; print(x.length)
&#125;</code></pre>

<h1 id="迴圈"><a href="#迴圈" class="headerlink" title="迴圈"></a>迴圈</h1><h2 id="while-迴圈"><a href="#while-迴圈" class="headerlink" title="while 迴圈"></a><code>while</code> 迴圈</h2><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">var i &#x3D; 0
while (i &lt; 5) &#123;
    i++
    println(i)
&#125;</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">1
2
3
4
5</code></pre>

<h2 id="for-迴圈"><a href="#for-迴圈" class="headerlink" title="for 迴圈"></a><code>for</code> 迴圈</h2><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">for (i in 1..5) println(i)</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">1
2
3
4
5</code></pre>

<h2 id="forEach-迴圈"><a href="#forEach-迴圈" class="headerlink" title="forEach 迴圈"></a><code>forEach</code> 迴圈</h2><p>可以運用集合 (Collections) 與<code>forEach</code> 函數簡化 <code>for</code> 語法代碼操作。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val list &#x3D; listOf(1, 2, 3, 4, 5)
list.forEach &#123;
    println(it)
&#125;</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">1
2
3
4
5</code></pre>

<hr>
<h1 id="智慧轉型"><a href="#智慧轉型" class="headerlink" title="智慧轉型"></a>智慧轉型</h1><p>Kotlin 很聰明，當我們使用 <code>is</code> 關鍵字檢查一個變數是否為特定類型後，Kotlin 會自動將該變數轉型為該類型。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun printLength(obj: Any) &#123;
    if (obj is String) &#123;
        &#x2F;&#x2F; 在這裡，Kotlin 自動將 obj 轉型為 String 類型
        println(obj.length)
    &#125;
&#125;</code></pre>

<p>而 Java 則要手動轉型</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public void printLength(Object obj) &#123;
    if (obj instanceof String) &#123;
        &#x2F;&#x2F; 在這裡，我們需要手動將 obj 轉型為 String 類型
        String str &#x3D; (String) obj;
        System.out.println(str.length());
    &#125;
&#125;</code></pre>

<hr>
<h1 id="空安全"><a href="#空安全" class="headerlink" title="空安全"></a>空安全</h1><p>空安全是 Kotlin 中一個非常重要的特性，它可以幫助我們避免許多空指針異常（<code>NullPointerException</code>）。</p>
<h2 id="從陣列中清除空值"><a href="#從陣列中清除空值" class="headerlink" title="從陣列中清除空值"></a>從陣列中清除空值</h2><p>如果你想從可為空的 <code>Iterable</code> 或陣列中消除 <code>null</code> 值，你可以使用 <code>filterNotNull()</code> 函數。這個函數將返回一個新的集合，其中不包含 <code>null</code> 值。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val listWithNulls: List&lt;Int?&gt; &#x3D; listOf(1, 2, null, 4, null, 6)
val listWithoutNulls &#x3D; listWithNulls.filterNotNull()

println(listWithNulls)                  &#x2F;&#x2F; 輸出：[1, 2, null, 4, null, 6]
println(listWithoutNulls)               &#x2F;&#x2F; 輸出：[1, 2, 4, 6]</code></pre>

<h2 id="空合併及-Elvis-運算符"><a href="#空合併及-Elvis-運算符" class="headerlink" title="空合併及 Elvis 運算符 ?:"></a>空合併及 Elvis 運算符 <code>?:</code></h2><p>可以在變數為 <code>null</code> 時提供一個默認值。如果變數為 <code>null</code>，則 Elvis 運算符將返回其右側的表達式作為結果，否則返回變數本身。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val name: String? &#x3D; null
val length1 &#x3D; name?.length
val length2 &#x3D; name?.length ?: &quot;0&quot;

println(&quot;Length 1: $length1&quot;)           &#x2F;&#x2F; 輸出：null
println(&quot;Length 2: $length2&quot;)           &#x2F;&#x2F; 輸出：0</code></pre>

<h2 id="安全調用符"><a href="#安全調用符" class="headerlink" title="安全調用符 ?."></a>安全調用符 <code>?.</code></h2><p>處理可為空的變數時，我們需要使用安全調用運算符（<code>?.</code>）來訪問它的屬性或呼叫它的方法。這樣可以避免空指針異常。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val name: String? &#x3D; null
val length &#x3D; name?.length

println(&quot;Length: $length&quot;)              &#x2F;&#x2F; 輸出：null</code></pre>

<p>通常會連同 <code>let</code> 標準函數一起使用</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val name: String? &#x3D; null
name?.let &#123;
    println(&quot;Length: $&#123;it.length&#125;&quot;)     &#x2F;&#x2F; 沒有輸出
&#125;</code></pre>

<h2 id="非空斷言"><a href="#非空斷言" class="headerlink" title="非空斷言 !!"></a>非空斷言 <code>!!</code></h2><p>可以在確定變數不為 <code>null</code> 的情況下強制執行操作。</p>
<div class="note warning simple"><p>使用 <code>!!</code> 運算符需要謹慎使用，因為它可能引發空指針異常 (<code>KotlinNullPointerException</code>)。</p>
<p>只有在你確定變數不為 <code>null</code> 的情況下才應該使用非空斷言運算符 <code>!!</code>。否則，建議使用安全調用運算符 <code>?.</code> 來處理可為空的變數，以避免空指針異常的風險。</p>
</div>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://i.imgur.com/X9zVUFU.png&quot;" data-lazy-src="/post/dev-kotlin-integrated-notes/img7.png" alt="img7"></p>
<hr>
<h1 id="委託"><a href="#委託" class="headerlink" title="委託"></a>委託</h1><p>指物件將一個請求委派給另一個物件來處理，將其讀取和寫入操作委託給其他對象。</p>
<ol>
<li><p>例如現在我想要一個新的 <code>OnlyHelloClass</code> 支援 <code>AllClass</code> 的 <code>sayHello()</code> 函數，如果直接把其繼承，就有失原意，因為我只想要支援 <code>sayHello()</code> 函數，結果把 <code>sayGoodbye()</code> 都帶過來了。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">open class AllClass &#123;
    fun sayHello() &#x3D; println(&quot;Hello&quot;)
    fun sayGoodbye() &#x3D; println(&quot;Goodbye&quot;)
&#125;
class OnlyHelloClass : AllClass()</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://i.imgur.com/X9zVUFU.png&quot;" data-lazy-src="/post/dev-kotlin-integrated-notes/img8.png" alt="img8"><br>要解決這個問題，可以用介面（interface）</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">interface HelloDelegate &#123;
    fun sayHello() &#x3D; AllClass().sayHello()
&#125;
class OnlyHelloClass : HelloDelegate</code></pre>
<p>現在這個 <code>OnlyHelloClass</code> 就只可以用 <code>sayHello()</code> 函數了。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://i.imgur.com/X9zVUFU.png&quot;" data-lazy-src="/post/dev-kotlin-integrated-notes/img9.png" alt="img9"><br>亦可以用 <code>by</code> 關鍵字委託哪一個 <code>Class</code> 去處理：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">interface HelloDelegate &#123;
    fun sayHello() &#x3D; AllClass().sayHello()
&#125;

open class AllClass: HelloDelegate &#123;
    override fun sayHello() &#x3D; println(&quot;Hello&quot;)
    fun sayGoodbye() &#x3D; println(&quot;Goodbye&quot;)
&#125;

class OnlyHelloClass(private val delegate: HelloDelegate): HelloDelegate by delegate

fun main() &#123;
    OnlyHelloClass(AllClass()).sayHello()
&#125;</code></pre>
</li>
<li><p>有些情況下，我們可能不希望立即刪除被棄用的屬性，因為有一些舊有的程式碼可能還在使用這個屬性。為了向後兼容性，我們可以將存取委託給新的屬性，這樣舊有的程式碼仍然可以使用這個屬性，同時建議開發者在新的程式碼中使用替代方案。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">class DelegateTest &#123;
    var newName &#x3D; &quot;New Name&quot;
    @Deprecated(&quot;Use &#39;newName&#39; instead&quot;, ReplaceWith(&quot;newName&quot;))
    var oldName by this::newName
&#125;

val test &#x3D; DelegateTest()
test.oldName &#x3D; &quot;Old Name&quot;
println(test.newName)         &#x2F;&#x2F; 輸出：Old Name</code></pre></li>
</ol>
<h2 id="委託屬性"><a href="#委託屬性" class="headerlink" title="委託屬性"></a>委託屬性</h2><h3 id="lazy-屬性"><a href="#lazy-屬性" class="headerlink" title="lazy 屬性"></a><code>lazy</code> 屬性</h3><p>這個委託屬性用於<strong>惰性初始化</strong>。它只有在第一次訪問屬性時才會計算其值，以後的訪問將直接返回已計算的值。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val result by lazy &#123;
    println(&quot;初始化&quot;)
&#125;
println(&quot;執行: $result&quot;)
println(&quot;執行: $result&quot;)            &#x2F;&#x2F; 即使第二次執行，都不會再出現 &quot;初始化&quot;</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">初始化
執行: kotlin.Unit
執行: kotlin.Unit</code></pre>

<h3 id="observable-屬性"><a href="#observable-屬性" class="headerlink" title="observable 屬性"></a><code>observable</code> 屬性</h3><p>這個委託屬性用於觀察屬性的變化。它接收一個初始值和一個回調函數，當屬性的值發生變化時，將調用回調函數。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">class ObservableTest &#123;
    var name by Delegates.observable(&quot;初始值&quot;) &#123; property, oldValue, newValue -&gt;  
        println(&quot;結果: $oldValue -&gt; $newValue&quot;)
    &#125;
&#125;
val observableTest &#x3D; ObservableTest() 
observableTest.name &#x3D; &quot;first&quot;
observableTest.name &#x3D; &quot;second&quot;

print(observableTest)</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">結果: 初始值 -&gt; first
結果: first -&gt; second</code></pre>

<h3 id="vetoable-屬性"><a href="#vetoable-屬性" class="headerlink" title="vetoable 屬性"></a><code>vetoable</code> 屬性</h3><p>這個委託屬性用於在設置屬性值之前進行驗證。它接收一個初始值和一個驗證回調函數，當設置屬性的新值時，將調用驗證回調函數以確定是否接受該值。如果驗證回調函數返回 <code>false</code>，則不接受該值並保持原始值。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">var value by Delegates.vetoable(0) &#123; _, oldValue, newValue -&gt;
    newValue &gt; oldValue
&#125;

value &#x3D; 5           &#x2F;&#x2F; 設置新值，將通過驗證
println(value)

value &#x3D; 2           &#x2F;&#x2F; 設置新值，將被驗證拒絕
println(value)</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">5
5</code></pre></article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://i.imgur.com/X9zVUFU.png&quot;" data-lazy-src="https://i.ibb.co/zRvn96K/personal-icon.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://i.imgur.com/X9zVUFU.png&quot;" data-lazy-src="https://i.ibb.co/zRvn96K/personal-icon.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">BlueWhaleYT</div><div class="post-copyright__author_desc">荒誕的極樂世界</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://bluewhaleyt.github.io/post/dev-kotlin-integrated-notes.html">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://bluewhaleyt.github.io/post/dev-kotlin-integrated-notes.html')">程式編寫 | 綜合整理 Kotlin 筆記</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://bluewhaleyt.github.io/post/dev-kotlin-integrated-notes.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本部落格所有文章除特別聲明外，均採用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 許可協議。轉載請註明來自 <a href="https://bluewhaleyt.github.io" target="_blank">🐳 BlueWhaleYT</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/Kotlin/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>Kotlin<span class="tagsPageCount">6</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://i.ibb.co/zRvn96K/personal-icon.jpg" data-sites="facebook,twitter"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/roblox-dev-create-plugins.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://i.imgur.com/X9zVUFU.png&quot;" data-lazy-src="https://i.imgur.com/UKkO3yo.png" onerror="onerror=null;src='https://i.imgur.com/X9zVUFU.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Roblox 開發 | 建立插件</div></div></a></div><div class="next-post pull-right"><a href="/post/jetpack-compose-dev-keystore-release.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://i.imgur.com/X9zVUFU.png&quot;" data-lazy-src="/" onerror="onerror=null;src='https://i.imgur.com/X9zVUFU.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Jetpack Compose 開發 | 解決卡頓的關鍵：使用 release 版本運行</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>相關推薦</span></div><div class="relatedPosts-list"><div><a href="/post/android-dev-jetbrains-dokka.html" title="Android 開發 | Jetbrains 研發的 Dokka API 文檔"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://i.imgur.com/X9zVUFU.png&quot;" data-lazy-src="https://i.imgur.com/x0NbbG2.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023 年 07 月 10 日</div><div class="title">Android 開發 | Jetbrains 研發的 Dokka API 文檔</div></div></a></div><div><a href="/post/android-dev-sora-editor-lib-notes.html" title="Android 開發 | Sora Editor 編輯器函式庫"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://i.imgur.com/X9zVUFU.png&quot;" data-lazy-src="https://i.imgur.com/oqr8QYp.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022 年 12 月 09 日</div><div class="title">Android 開發 | Sora Editor 編輯器函式庫</div></div></a></div><div><a href="/post/jetpack-compose-dev-custom-design-system-notes.html" title="Jetpack Compose 開發 | 實作自訂設計系統"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://i.imgur.com/X9zVUFU.png&quot;" data-lazy-src="https://i.imgur.com/NETPgOw.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023 年 10 月 14 日</div><div class="title">Jetpack Compose 開發 | 實作自訂設計系統</div></div></a></div><div><a href="/post/dev-migrate-to-kotlin-from-java.html" title="程式編寫 | 由 Java 遷移到 Kotlin 的基礎"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://i.imgur.com/X9zVUFU.png&quot;" data-lazy-src="https://i.imgur.com/2ZQ3zHY.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022 年 12 月 21 日</div><div class="title">程式編寫 | 由 Java 遷移到 Kotlin 的基礎</div></div></a></div><div><a href="/post/jetpack-compsoe-dev-compose-multiplatform-notes.html" title="Jetpack Compose 開發 | 跨平台項目開發筆記"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://i.imgur.com/X9zVUFU.png&quot;" data-lazy-src="https://i.imgur.com/UmTOcOp.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023 年 06 月 26 日</div><div class="title">Jetpack Compose 開發 | 跨平台項目開發筆記</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div id="google_translate_element"></div><script type="text/javascript">function googleTranslateElementInit() {
  new google.translate.TranslateElement({pageLanguage: 'zh-TW', includedLanguages: 'ja,ko,en,zh-TW,zh-CN'}, 'google_translate_element');
}</script><script type="text/javascript" src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://i.imgur.com/X9zVUFU.png&quot;" data-lazy-src="https://i.ibb.co/zRvn96K/personal-icon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">你說的都對。</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">BlueWhaleYT</h1><div class="author-info__desc">荒誕的極樂世界</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/BlueWhaleYT" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目錄</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%A5%E5%8F%A3%E9%BB%9E"><span class="toc-number">1.</span> <span class="toc-text">入口點</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%85%A5%E5%8F%A3%E9%BB%9E%E6%88%96%E9%A1%9E%E5%88%A5%E5%90%8D%E7%A8%B1"><span class="toc-number">1.1.</span> <span class="toc-text">修改入口點或類別名稱</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BC%B8%E5%85%A5%E6%95%B8%E5%80%BC"><span class="toc-number">2.</span> <span class="toc-text">輸入數值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%93%8D%E6%8E%A7%E5%8F%B0%E8%BC%B8%E5%85%A5"><span class="toc-number">2.1.</span> <span class="toc-text">使用操控台輸入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-GUI-%E8%A6%96%E7%AA%97%E8%BC%B8%E5%85%A5"><span class="toc-number">2.2.</span> <span class="toc-text">使用 GUI 視窗輸入</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A5%97%E4%BB%B6%E8%88%87%E5%8C%AF%E5%85%A5"><span class="toc-number">3.</span> <span class="toc-text">套件與匯入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A5%97%E4%BB%B6%E9%A1%9E%E5%88%A5%E5%91%BD%E5%90%8D%E8%A1%9D%E7%AA%81"><span class="toc-number">3.1.</span> <span class="toc-text">套件類別命名衝突</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%8F%96%E4%BF%AE%E9%A3%BE%E5%AD%90"><span class="toc-number">4.</span> <span class="toc-text">存取修飾子</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E7%B9%BC%E6%89%BF%E9%A1%9E"><span class="toc-number">4.1.</span> <span class="toc-text">可繼承類</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%8D%E8%B1%A1%E8%88%87%E5%BB%BA%E6%A7%8B%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">對象與建構式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%96%AE%E4%BE%8B%E6%A8%A1%E5%BC%8F-Singleton"><span class="toc-number">5.1.</span> <span class="toc-text">單例模式 (Singleton)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%B4%E7%94%9F%E5%B0%8D%E8%B1%A1"><span class="toc-number">5.2.</span> <span class="toc-text">伴生對象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E6%A7%8B%E5%AD%90%E5%BB%BA%E6%A7%8B"><span class="toc-number">5.3.</span> <span class="toc-text">建構子建構</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%BB%BA%E6%A7%8B%E5%AD%90"><span class="toc-number">5.3.1.</span> <span class="toc-text">主要建構子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AC%A1%E8%A6%81-x2F-%E5%A4%9A%E5%80%8B%E5%BB%BA%E6%A7%8B%E5%AD%90"><span class="toc-number">5.3.2.</span> <span class="toc-text">次要 &#x2F; 多個建構子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A8%8B%E5%BC%8F"><span class="toc-number">5.3.3.</span> <span class="toc-text">初始化程式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%81%8B%E7%AE%97%E7%AC%A6"><span class="toc-number">6.</span> <span class="toc-text">運算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E5%85%83%E9%81%8B%E7%AE%97%E7%AC%A6"><span class="toc-number">6.1.</span> <span class="toc-text">位元運算符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%8A%E9%87%8F%E5%8F%8A%E5%B8%B8%E9%87%8F"><span class="toc-number">7.</span> <span class="toc-text">變量及常量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%8F%96%E8%88%87%E8%AE%8A%E7%95%B0"><span class="toc-number">7.1.</span> <span class="toc-text">存取與變異</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B8"><span class="toc-number">8.</span> <span class="toc-text">函數</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B8%E9%A1%9E%E5%9E%8B"><span class="toc-number">8.1.</span> <span class="toc-text">函數類型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%96%AE%E8%A1%8C%E8%A1%A8%E9%81%94%E5%BC%8F"><span class="toc-number">8.1.1.</span> <span class="toc-text">單行表達式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%9A%8E%E5%87%BD%E6%95%B8"><span class="toc-number">8.1.2.</span> <span class="toc-text">高階函數</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A7%E8%81%AF%E5%87%BD%E6%95%B8"><span class="toc-number">8.1.2.1.</span> <span class="toc-text">內聯函數</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#infix-%E5%87%BD%E6%95%B8"><span class="toc-number">8.1.2.2.</span> <span class="toc-text">infix 函數</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#operator-%E5%87%BD%E6%95%B8"><span class="toc-number">8.1.2.3.</span> <span class="toc-text">operator 函數</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B8"><span class="toc-number">8.1.3.</span> <span class="toc-text">匿名函數</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%99%E6%BA%96-x2F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%87%BD%E6%95%B8"><span class="toc-number">8.1.4.</span> <span class="toc-text">標準 &#x2F; 作用域函數</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#let-%E5%87%BD%E6%95%B8"><span class="toc-number">8.1.4.1.</span> <span class="toc-text">let 函數</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#run-%E5%87%BD%E6%95%B8"><span class="toc-number">8.1.4.2.</span> <span class="toc-text">run 函數</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#apply-%E5%87%BD%E6%95%B8"><span class="toc-number">8.1.4.3.</span> <span class="toc-text">apply 函數</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#also-%E5%87%BD%E6%95%B8"><span class="toc-number">8.1.4.4.</span> <span class="toc-text">also 函數</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#with-%E5%87%BD%E6%95%B8"><span class="toc-number">8.1.4.5.</span> <span class="toc-text">with 函數</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%B4%E5%B1%95%E5%87%BD%E6%95%B8"><span class="toc-number">8.1.5.</span> <span class="toc-text">擴展函數</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AF%84%E5%9C%8D"><span class="toc-number">9.</span> <span class="toc-text">範圍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AF%84%E5%9C%8D%E5%87%BD%E6%95%B8"><span class="toc-number">9.1.</span> <span class="toc-text">範圍函數</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%A3%E5%88%97"><span class="toc-number">10.</span> <span class="toc-text">陣列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8-arrayOf-%E5%87%BD%E6%95%B8%E5%BB%BA%E7%AB%8B%E5%9F%BA%E6%9C%AC%E9%99%A3%E5%88%97"><span class="toc-number">10.1.</span> <span class="toc-text">用 arrayOf() 函數建立基本陣列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8-Array-%E5%BB%BA%E7%AB%8B%E4%B8%8D%E5%90%8C%E9%99%A3%E5%88%97"><span class="toc-number">10.2.</span> <span class="toc-text">用 Array() 建立不同陣列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%B6%AD%E9%99%A3%E5%88%97"><span class="toc-number">10.2.1.</span> <span class="toc-text">二維陣列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%B6%AD%E9%99%A3%E5%88%97"><span class="toc-number">10.2.2.</span> <span class="toc-text">三維陣列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">11.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E9%A1%9E%E5%9E%8B"><span class="toc-number">11.1.</span> <span class="toc-text">集合類型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88-List-%E5%88%97%E8%A1%A8"><span class="toc-number">11.1.1.</span> <span class="toc-text">有序集合 List (列表)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%84%A1%E5%BA%8F%E9%9B%86%E5%90%88-Set-%E9%9B%86%E5%90%88"><span class="toc-number">11.1.2.</span> <span class="toc-text">無序集合 Set (集合)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%8D%B5%E5%80%BC%E5%B0%8D%E9%9B%86%E5%90%88-Map-%E6%98%A0%E5%B0%84"><span class="toc-number">11.1.3.</span> <span class="toc-text">鍵值對集合 Map (映射)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%87%BD%E6%95%B8%E6%93%8D%E4%BD%9C"><span class="toc-number">11.2.</span> <span class="toc-text">集合函數操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%97%E8%88%89"><span class="toc-number">12.</span> <span class="toc-text">列舉</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A8%BB%E8%A7%A3"><span class="toc-number">13.</span> <span class="toc-text">註解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E8%B3%87%E8%A8%8A"><span class="toc-number">13.1.</span> <span class="toc-text">元資訊</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A2%9D%E4%BB%B6%E5%88%A4%E6%96%B7"><span class="toc-number">14.</span> <span class="toc-text">條件判斷</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%BA%E7%AD%96%E9%82%8F%E8%BC%AF"><span class="toc-number">14.1.</span> <span class="toc-text">決策邏輯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#if-%E8%AA%9E%E5%8F%A5"><span class="toc-number">14.1.1.</span> <span class="toc-text">if 語句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#else-if-%E8%AA%9E%E5%8F%A5"><span class="toc-number">14.1.2.</span> <span class="toc-text">else if 語句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%96%AE%E8%A1%8C-if-%E8%A1%A8%E9%81%94%E5%BC%8F"><span class="toc-number">14.1.3.</span> <span class="toc-text">單行 if 表達式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%83%85%E6%B3%81%E9%82%8F%E8%BC%AF"><span class="toc-number">14.2.</span> <span class="toc-text">情況邏輯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%B4%E5%9C%88"><span class="toc-number">15.</span> <span class="toc-text">迴圈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#while-%E8%BF%B4%E5%9C%88"><span class="toc-number">15.1.</span> <span class="toc-text">while 迴圈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-%E8%BF%B4%E5%9C%88"><span class="toc-number">15.2.</span> <span class="toc-text">for 迴圈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#forEach-%E8%BF%B4%E5%9C%88"><span class="toc-number">15.3.</span> <span class="toc-text">forEach 迴圈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%99%BA%E6%85%A7%E8%BD%89%E5%9E%8B"><span class="toc-number">16.</span> <span class="toc-text">智慧轉型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A9%BA%E5%AE%89%E5%85%A8"><span class="toc-number">17.</span> <span class="toc-text">空安全</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%9E%E9%99%A3%E5%88%97%E4%B8%AD%E6%B8%85%E9%99%A4%E7%A9%BA%E5%80%BC"><span class="toc-number">17.1.</span> <span class="toc-text">從陣列中清除空值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E5%90%88%E4%BD%B5%E5%8F%8A-Elvis-%E9%81%8B%E7%AE%97%E7%AC%A6"><span class="toc-number">17.2.</span> <span class="toc-text">空合併及 Elvis 運算符 ?:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E8%AA%BF%E7%94%A8%E7%AC%A6"><span class="toc-number">17.3.</span> <span class="toc-text">安全調用符 ?.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E7%A9%BA%E6%96%B7%E8%A8%80"><span class="toc-number">17.4.</span> <span class="toc-text">非空斷言 !!</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A7%94%E8%A8%97"><span class="toc-number">18.</span> <span class="toc-text">委託</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E8%A8%97%E5%B1%AC%E6%80%A7"><span class="toc-number">18.1.</span> <span class="toc-text">委託屬性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lazy-%E5%B1%AC%E6%80%A7"><span class="toc-number">18.1.1.</span> <span class="toc-text">lazy 屬性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#observable-%E5%B1%AC%E6%80%A7"><span class="toc-number">18.1.2.</span> <span class="toc-text">observable 屬性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vetoable-%E5%B1%AC%E6%80%A7"><span class="toc-number">18.1.3.</span> <span class="toc-text">vetoable 屬性</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/jetpack-compose-dev-keystore-release.html" title="Jetpack Compose 開發 | 解決卡頓的關鍵：使用 release 版本運行">Jetpack Compose 開發 | 解決卡頓的關鍵：使用 release 版本運行</a><time datetime="2023-12-08T06:18:35.000Z" title="發表於 2023 年 12 月 08 日 14 時 18 分 35 秒">2023 年 12 月 08 日</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/dev-kotlin-integrated-notes.html" title="程式編寫 | 綜合整理 Kotlin 筆記"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://i.imgur.com/X9zVUFU.png&quot;" data-lazy-src="https://i.imgur.com/66jn0VC.png" onerror="this.onerror=null;this.src='https://i.imgur.com/X9zVUFU.png'" alt="程式編寫 | 綜合整理 Kotlin 筆記"/></a><div class="content"><a class="title" href="/post/dev-kotlin-integrated-notes.html" title="程式編寫 | 綜合整理 Kotlin 筆記">程式編寫 | 綜合整理 Kotlin 筆記</a><time datetime="2023-12-01T06:49:09.000Z" title="發表於 2023 年 12 月 01 日 14 時 49 分 09 秒">2023 年 12 月 01 日</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/roblox-dev-create-plugins.html" title="Roblox 開發 | 建立插件"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://i.imgur.com/X9zVUFU.png&quot;" data-lazy-src="https://i.imgur.com/UKkO3yo.png" onerror="this.onerror=null;this.src='https://i.imgur.com/X9zVUFU.png'" alt="Roblox 開發 | 建立插件"/></a><div class="content"><a class="title" href="/post/roblox-dev-create-plugins.html" title="Roblox 開發 | 建立插件">Roblox 開發 | 建立插件</a><time datetime="2023-11-15T10:31:16.000Z" title="發表於 2023 年 11 月 15 日 18 時 31 分 16 秒">2023 年 11 月 15 日</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/roblox-dev-get-started-notes.html" title="Roblox 開發 | 入手編寫筆記"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://i.imgur.com/X9zVUFU.png&quot;" data-lazy-src="https://i.imgur.com/fnyocqo.png" onerror="this.onerror=null;this.src='https://i.imgur.com/X9zVUFU.png'" alt="Roblox 開發 | 入手編寫筆記"/></a><div class="content"><a class="title" href="/post/roblox-dev-get-started-notes.html" title="Roblox 開發 | 入手編寫筆記">Roblox 開發 | 入手編寫筆記</a><time datetime="2023-11-05T02:01:05.000Z" title="發表於 2023 年 11 月 05 日 10 時 01 分 05 秒">2023 年 11 月 05 日</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/jetpack-compose-dev-custom-design-system-notes.html" title="Jetpack Compose 開發 | 實作自訂設計系統"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://i.imgur.com/X9zVUFU.png&quot;" data-lazy-src="https://i.imgur.com/NETPgOw.png" onerror="this.onerror=null;this.src='https://i.imgur.com/X9zVUFU.png'" alt="Jetpack Compose 開發 | 實作自訂設計系統"/></a><div class="content"><a class="title" href="/post/jetpack-compose-dev-custom-design-system-notes.html" title="Jetpack Compose 開發 | 實作自訂設計系統">Jetpack Compose 開發 | 實作自訂設計系統</a><time datetime="2023-10-14T05:51:52.000Z" title="發表於 2023 年 10 月 14 日 13 時 51 分 52 秒">2023 年 10 月 14 日</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2023 By <a class="footer-bar-link" href="/" title="BlueWhaleYT" target="_blank">BlueWhaleYT</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" href="/null"></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/" title="tag"><div class="headline">標籤</div><div class="length-num">15</div></a><a href="/categories/" title="category"><div class="headline">分類</div><div class="length-num">7</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="顯示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>顯示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://i.imgur.com/X9zVUFU.png&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://i.imgur.com/X9zVUFU.png&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Android/" style="font-size: 0.88rem; font-weight: 500; color: var(--anzhiyu-lighttext)">Android<sup>2</sup></a><a href="/tags/Desktop/" style="font-size: 0.88rem;">Desktop<sup>1</sup></a><a href="/tags/Express/" style="font-size: 0.88rem;">Express<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 0.88rem;">HTML<sup>1</sup></a><a href="/tags/JSON/" style="font-size: 0.88rem;">JSON<sup>1</sup></a><a href="/tags/Java/" style="font-size: 0.88rem;">Java<sup>2</sup></a><a href="/tags/JavaScript/" style="font-size: 0.88rem;">JavaScript<sup>2</sup></a><a href="/tags/Kotlin/" style="font-size: 0.88rem; font-weight: 500; color: var(--anzhiyu-lighttext)">Kotlin<sup>6</sup></a><a href="/tags/Lua/" style="font-size: 0.88rem;">Lua<sup>2</sup></a><a href="/tags/Markdown/" style="font-size: 0.88rem;">Markdown<sup>1</sup></a><a href="/tags/Node-js/" style="font-size: 0.88rem;">Node.js<sup>1</sup></a><a href="/tags/Roblox/" style="font-size: 0.88rem;">Roblox<sup>2</sup></a><a href="/tags/Swift/" style="font-size: 0.88rem;">Swift<sup>1</sup></a><a href="/tags/XML/" style="font-size: 0.88rem;">XML<sup>1</sup></a><a href="/tags/iOS/" style="font-size: 0.88rem;">iOS<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="閱讀模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="簡繁轉換">繁</button><button id="darkmode" type="button" title="淺色和深色模式轉換"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="單欄和雙欄切換"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="設定"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目錄"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到頂部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜尋</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  資料庫載入中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜尋文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script src="https://cdn.cbd.int/prismjs@1.29.0/prism.js"></script><script src="https://cdn.cbd.int/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script><script src="https://cdn.cbd.int/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script src="/js/custom.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div><!-- hexo injector body_end start --><script src="https://unpkg.com/kotlin-playground@1" data-server data-version></script>
<script>

if(typeof ktpgOptions !== 'undefined'){
    KotlinPlayground('.kotlin-code',ktpgOptions)
}else{
    KotlinPlayground('.kotlin-code')
}
window.addEventListener('pjax:complete', event => {
    if(typeof ktpgOptions !== 'undefined'){
        KotlinPlayground('.kotlin-code',ktpgOptions)
    }else{
        KotlinPlayground('.kotlin-code')
    }
});
</script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>