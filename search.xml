<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Jetpack Compose | 客製化主題實作筆記</title>
    <url>/post/jetpack-compose-dev-custom-theme-implementation-notes.html</url>
    <content><![CDATA[<p>在編寫 Jetpack Compose 程式時，常常會使用到質感設計 2 或質感設計 3 的設計框架，作為應用程式的基本設計風格。這是因為質感設計 2 和質感設計 3 提供了許多簡潔明瞭的組件，官方建議在構建 Jetpack Compose 程式時，盡量使用這些框架進行開發。</p>
<p>然而，一些知名的大型公司可能會選擇採用與質感設計不同的設計風格，來<strong>展現他們自家應用程式的獨特性</strong>。這也反映了應用程式的多樣性，避免出現與其他應用程式相似的情況。有些公司會<strong>在質感設計的框架基礎上進行改革</strong>，有些則會<strong>從頭開始自己撰寫設計框架</strong>。</p>
<p>不可否認的是，官方為 Jetpack Compose 所撰寫的質感設計主題都是使用他們自家開發的 API。因此，我們可以<strong>參考原始的質感設計實現程式碼，來撰寫自己的設計主題</strong>。這樣我們就可以擁有自己定制的設計風格了。</p>
<hr>
<table>
<thead>
<tr>
<th>明亮主題</th>
<th>黑暗主題</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/post/jetpack-compose-dev-custom-theme-implementation-notes/img1.png" alt="Showcase = Light mode"></td>
<td><img src="/post/jetpack-compose-dev-custom-theme-implementation-notes/img2.png" alt="Showcase = Dark mode"></td>
</tr>
</tbody></table>
<p>以上是製成品，這篇筆記會記下有關自訂主題的實現方式。</p>
<hr>
<h1 id="參照-MaterialTheme-程式碼"><a href="#參照-MaterialTheme-程式碼" class="headerlink" title="參照 MaterialTheme 程式碼"></a>參照 <code>MaterialTheme</code> 程式碼</h1><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">object MaterialTheme &#123;
    val colorScheme: ColorScheme
        @Composable
        @ReadOnlyComposable
        get() &#x3D; LocalColorScheme.current

    val typography: Typography
        @Composable
        @ReadOnlyComposable
        get() &#x3D; LocalTypography.current

    val shapes: Shapes
        @Composable
        @ReadOnlyComposable
        get() &#x3D; LocalShapes.current
&#125;</code></pre>

<p>預設的質感設計 3 提供了三個設計指標</p>
<ul>
<li><code>colorScheme</code>: 要應用的色彩配置</li>
<li><code>typography</code>: 要應用的字型及字體</li>
<li><code>shapes</code>: 要應用的形狀，如形狀的弧度</li>
</ul>
<p>然後你會發現。。。<strong>其實沒有內置像素密度、尺寸 (dimension)、間距 (spacing) 等常用指標</strong>，有見及此，我們可以自己參照原型，寫一個更好用的主題。</p>
<hr>
<h1 id="實作自訂主題"><a href="#實作自訂主題" class="headerlink" title="實作自訂主題"></a>實作自訂主題</h1><p>姑且命名新主題為 <strong>「BabyWhale」</strong>。</p>
<h2 id="多範疇指標建立"><a href="#多範疇指標建立" class="headerlink" title="多範疇指標建立"></a>多範疇指標建立</h2><h3 id="色彩調色指標"><a href="#色彩調色指標" class="headerlink" title="色彩調色指標"></a>色彩調色指標</h3><p>建立一個 <code>BabyWhaleColor.kt</code>，這個檔案是定義不同主題的顏色配置，例如是淺色和深色主題。</p>
<p>這裏是一個簡單的顏色色板，作用大概是</p>
<ul>
<li><code>Blue</code>: Primary 主色</li>
<li><code>Cyan</code>: Info 提示色</li>
<li><code>Green</code>: Success 成功色</li>
<li><code>Orange</code>: Warning 警告色</li>
<li><code>Red</code>: Error 錯誤&#x2F;危險色</li>
</ul>
<p><code>500</code> 是供淺色主題用的，而 <code>300</code> 則是深色主題。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val Blue_500 &#x3D; Color(0xFF3366FF)
val Blue_300 &#x3D; Color(0xFF84A9FF)

val Cyan_500 &#x3D; Color(0xFF3CC6FC)
val Cyan_300 &#x3D; Color(0xFF89EDFE)

val Green_500 &#x3D; Color(0xFF98E01D)
val Green_300 &#x3D; Color(0xFFCFF575)

val Orange_500 &#x3D; Color(0xFFFFAF3F)
val Orange_300 &#x3D; Color(0xFFFFD88B)

val Red_500 &#x3D; Color(0xFFFF4130)
val Red_300 &#x3D; Color(0xFFFFA182)

val White &#x3D; Color.White
val Black &#x3D; Color.Black</code></pre>

<div class="note info simple"><p>我是使用 <a href="https://colors.eva.design/">Eva Design System</a> 來生成以上的調色，為了較簡單，這裏只採用 <code>500</code> 和 <code>300</code> 色調碼，如果想要再完整的，基本上就是 <code>100</code> 至 <code>900</code> 全都使用。</p>
<p><img src="/post/jetpack-compose-dev-custom-theme-implementation-notes/img3.png" alt="Eva Design System"></p>
</div>

<p>寫一個數據類定義要用的顏色指標，然後把顏色向分予不同的主題模式。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Immutable
data class BabyWhaleColors(
    val primary: Color,
    val info: Color,
    val success: Color,
    val warning: Color,
    val error: Color,
    val background: Color,
    val onBackground: Color,
    val onPrimary: Color
)

val LightColorScheme &#x3D; BabyWhaleColors(
    primary &#x3D; Blue_500,
    info &#x3D; Cyan_500,
    success &#x3D; Green_500,
    warning &#x3D; Orange_500,
    error &#x3D; Red_500,
    background &#x3D; White,
    onBackground &#x3D; Black,
    onPrimary &#x3D; White
)

val DarkColorScheme &#x3D; BabyWhaleColors(
    primary &#x3D; Blue_300,
    info &#x3D; Cyan_300,
    success &#x3D; Green_300,
    warning &#x3D; Orange_300,
    error &#x3D; Red_300,
    background &#x3D; Black,
    onBackground &#x3D; White,
    onPrimary &#x3D; Black
)

val LocalBabyWhaleColors &#x3D; staticCompositionLocalOf &#123; LightColorScheme &#125;</code></pre>

<h3 id="字型指標"><a href="#字型指標" class="headerlink" title="字型指標"></a>字型指標</h3><p>建立一個 <code>BabyWhaleTypography.kt</code>，用來管理主題的應用字型</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Immutable
data class BabyWhaleTypography(
    val headline: TextStyle,
    val title: TextStyle,
    val subtitle: TextStyle,
    val body: TextStyle,
    val label: TextStyle
)

val babyWhaleTypography &#x3D; BabyWhaleTypography(
    headline &#x3D; TextStyle(
        fontSize &#x3D; 27.sp,
        fontFamily &#x3D; FontFamily.SansSerif,
        fontWeight &#x3D; FontWeight.Black,
    ),
    title &#x3D; TextStyle(
        fontSize &#x3D; 21.sp,
        fontFamily &#x3D; FontFamily.SansSerif,
        fontWeight &#x3D; FontWeight.Bold,
    ),
    subtitle &#x3D; TextStyle(
        fontSize &#x3D; 19.sp,
        fontFamily &#x3D; FontFamily.SansSerif,
        fontWeight &#x3D; FontWeight.Normal,
    ),
    body &#x3D; TextStyle(
        fontSize &#x3D; 18.sp,
        fontFamily &#x3D; FontFamily.SansSerif,
        fontWeight &#x3D; FontWeight.Normal,
    ),
    label &#x3D; TextStyle(
        fontSize &#x3D; 16.sp,
        fontFamily &#x3D; FontFamily.SansSerif,
        fontWeight &#x3D; FontWeight.Bold,
    ),
)

val LocalBabyWhaleTypography &#x3D; staticCompositionLocalOf &#123; babyWhaleTypography &#125;</code></pre>

<h3 id="形狀指標"><a href="#形狀指標" class="headerlink" title="形狀指標"></a>形狀指標</h3><p>建立一個 <code>BabyWhaleShape.kt</code></p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Immutable
data class BabyWhaleShape(
    val extraSmall: RoundedCornerShape &#x3D; RoundedCornerShape(4.dp),
    val small: RoundedCornerShape &#x3D; RoundedCornerShape(8.dp),
    val medium: RoundedCornerShape &#x3D; RoundedCornerShape(16.dp),
    val large: RoundedCornerShape &#x3D; RoundedCornerShape(24.dp),
    val extraLarge: RoundedCornerShape &#x3D; RoundedCornerShape(28.dp)
)

val LocalBabyWhaleShape &#x3D; staticCompositionLocalOf &#123; BabyWhaleShape() &#125;</code></pre>

<h3 id="自訂間距指標"><a href="#自訂間距指標" class="headerlink" title="自訂間距指標"></a>自訂間距指標</h3><p>新建 <code>BabyWhaleSpacing.kt</code></p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">data class BabyWhaleSpacing(
    val small: Dp &#x3D; 8.dp,
    val medium: Dp &#x3D; 16.dp,
    val large: Dp &#x3D; 24.dp
)

val LocalBabyWhaleSpacing &#x3D; staticCompositionLocalOf &#123; BabyWhaleSpacing() &#125;</code></pre>

<h2 id="套用指標至主題"><a href="#套用指標至主題" class="headerlink" title="套用指標至主題"></a>套用指標至主題</h2><p>把指標全都寫好後，就可以新建 <code>BabyWhaleTheme.kt</code> ，把主題相關的邏輯通通寫進去。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">object BabyWhaleTheme &#123;
    val colors: BabyWhaleColors
        @ReadOnlyComposable
        @Composable
        get() &#x3D; LocalBabyWhaleColors.current
    val typography: BabyWhaleTypography
        @ReadOnlyComposable
        @Composable
        get() &#x3D; LocalBabyWhaleTypography.current
    val shapes: BabyWhaleShape
        @ReadOnlyComposable
        @Composable
        get() &#x3D; LocalBabyWhaleShape.current
    val spacing: BabyWhaleSpacing
        @ReadOnlyComposable
        @Composable
        get() &#x3D; LocalBabyWhaleSpacing.current
&#125;</code></pre>

<p>然後寫 <code>BabyWhaleTheme()</code> 主要用的主題應用函數</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Composable
fun BabyWhaleTheme(
    isDarkMode: Boolean &#x3D; isSystemInDarkTheme(),
    typography: BabyWhaleTypography &#x3D; BabyWhaleTheme.typography,
    shapes: BabyWhaleShape &#x3D; BabyWhaleTheme.shapes,
    spacing: BabyWhaleSpacing &#x3D; BabyWhaleTheme.spacing,
    content: @Composable () -&gt; Unit
) &#123;
    val colorScheme &#x3D; if (isDarkMode) DarkColorScheme else LightColorScheme
    CompositionLocalProvider(
        LocalBabyWhaleColors provides colorScheme,
        LocalBabyWhaleTypography provides typography,
        LocalBabyWhaleShape provides shapes,
        LocalBabyWhaleSpacing provides spacing
    ) &#123;
        Box(
            modifier &#x3D; Modifier
                .background(colorScheme.background)
                .fillMaxSize()
        ) &#123;
            content()
        &#125;
    &#125;
&#125;</code></pre>

<details class="folding-tag"><summary> 主題函式庫提供方法 </summary>
              <div class="content">
              <p>如果你是想將主題封裝成依附元件，供不同項目使用，用法其實就像 <code>MaterialTheme</code> 一樣。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Composable
fun AppTheme(
    isDarkMode: Boolean &#x3D; isSystemInDarkTheme,
    content: @Composable () -&gt; Unit
) &#123;
    BabyWhaleTheme(
        isDarkMode &#x3D; isDarkMode,
        content &#x3D; content
    )
&#125;</code></pre>
              </div>
            </details>

<h2 id="自訂組件"><a href="#自訂組件" class="headerlink" title="自訂組件"></a>自訂組件</h2><p>因為 Jetpack Compose 內置提供的大部份組件都是使用質感設計為基礎的，所以如果你要寫一個與這個自訂主題相容的組件，就必須要自己另外再寫，這裏展示例如寫一個不同級別程度的按鈕</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">enum class BabyWhaleButtonType &#123;
    Primary, Info, Success, Warning, Error
&#125;

@Composable
internal fun getTypeColor(type: BabyWhaleButtonType) &#x3D; when (type) &#123;
    BabyWhaleButtonType.Primary -&gt; BabyWhaleTheme.colors.primary
    BabyWhaleButtonType.Info -&gt; BabyWhaleTheme.colors.info
    BabyWhaleButtonType.Success -&gt; BabyWhaleTheme.colors.success
    BabyWhaleButtonType.Warning -&gt; BabyWhaleTheme.colors.warning
    BabyWhaleButtonType.Error -&gt; BabyWhaleTheme.colors.error
&#125;

@Composable
fun BabyWhaleButton(
    modifier: Modifier &#x3D; Modifier,
    type: BabyWhaleButtonType &#x3D; BabyWhaleButtonType.Primary,
    onClick: () -&gt; Unit,
    content: @Composable () -&gt; Unit
) &#123;
    Button(
        modifier &#x3D; modifier,
        onClick &#x3D; onClick,
        colors &#x3D; ButtonDefaults.buttonColors(
            containerColor &#x3D; getTypeColor(type &#x3D; type),
            contentColor &#x3D; BabyWhaleTheme.colors.onPrimary
        )
    ) &#123;
        content()
    &#125;
&#125;</code></pre>

<p>用法：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">class MainActivity : ComponentActivity() &#123;
    override fun onCreate(savedInstanceState: Bundle?) &#123;
        super.onCreate(savedInstanceState)
        setContent &#123;
            BabyWhaleTheme &#123;
                Column &#123;
                    val types &#x3D; BabyWhaleButtonType.entries     &#x2F;&#x2F; 注意：需要 Kotlin 1.9.10 版本
                    types.forEach &#123;
                        BabyWhaleButton(
                            type &#x3D; it,
                            onClick &#x3D; &#123; &#x2F;*TODO*&#x2F; &#125;
                        ) &#123;
                            Text(text &#x3D; &quot;$&#123;it.name&#125; Button&quot;)
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>]]></content>
      <categories>
        <category>學習筆記</category>
        <category>Jetpack Compose</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
