<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android | CICD 工作流程及報告測試</title>
    <url>/post/android-dev-android-ci-cd.html</url>
    <content><![CDATA[<p>編程及開發，有一個尤關重要的工序就是進行實作工作流程，例如把程式碼的測試報告交託到 Github 工作流程，供用戶或其他開發者使用。</p>
<div class="note warning simple"><p>工作流程應用及用途廣泛，不限於於 Android 程式開發的範疇，<strong>但不同的範疇如網頁編寫、軟件開發都有不同的工作流程的配置</strong>。</p>
</div>

<hr>
<h1 id="什麼是-CICD"><a href="#什麼是-CICD" class="headerlink" title="什麼是 CICD"></a>什麼是 CICD</h1><p>CICD 這個字其實要分拆出來兩個部分 CI 及 CD。CICD 代表<strong>持續整合和持續交付</strong> (Continuous Integration and Continuous Delivery)。它是一種軟體開發實踐方法，旨在自動化軟體的建置、測試和部署過程。</p>
<ul>
<li>CI (持續整合): 開發人員將他們的程式碼<strong>頻繁地整合到共享的版本控制庫</strong>中，以便及早發現和解決衝突或問題。這樣可以確保團隊成員的程式碼<strong>相互協調</strong>，並<strong>提高開發效率</strong>。</li>
<li>CD (持續交付): 在程式碼經過持續整合後，<strong>自動進行測試和部署</strong>，以便快速且可靠地將軟體交付到生產環境中。這種<strong>自動化過程可以減少人為錯誤並提高交付速度</strong>。</li>
</ul>
<p>而通常要流程自動化，就會用到 Github 提供的一個功能：Github Workflow</p>
<hr>
<h1 id="建立一個工作流程執行檔"><a href="#建立一個工作流程執行檔" class="headerlink" title="建立一個工作流程執行檔"></a>建立一個工作流程執行檔</h1><p>有兩種方法</p>
<ol>
<li>利用 Github 平台，你可以按 setup a workflow yourself 由零開始建立，或者找到 Android CI 按 Configure 使用 Android 程式流程配置執行模版檔案<br><img src="/post/android-dev-android-ci-cd/img1.png" alt="使用 Github 建立流程執行檔"></li>
<li>直接在 IDE (整合開發環境) 軟件，如 Android Studio 建立，你可以在項目的根位置新增 <code>.github/workflows/android.yml</code>，例如 <code>android.yml</code>，或者任意檔案名稱，但是資料夾結構和名稱就要一樣。</li>
</ol>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>工作流程有五大部分：</p>
<ol>
<li>Event（事件）：事件是觸發 Workflow 執行的觸發器。常見的事件包括 push（推送程式碼到版本控制庫）、pull_request（發起拉取請求）、schedule（定期觸發）等。當發生指定的事件時，Workflow 就會開始執行。</li>
<li>Jobs（工作）：工作是 Workflow 中的單個單元，用於執行特定的任務。一個 Workflow 可以包含一個或多個工作。每個工作通常都是並行執行的，並且可以在不同的運行環境（如不同的作業系統、不同的容器等）中執行。</li>
<li>Steps（步驟）：步驟是工作中的具體操作步驟，用於定義需要執行的指令和命令。每個步驟都是獨立的，可以在同一工作中按順序執行，也可以在不同工作之間共享資源和數據。</li>
<li>Actions（動作）：動作是事先定義好的可重複使用的操作，用於執行特定的任務。GitHub 提供了許多內建的動作，如建置應用程式、執行測試、部署到雲端等。您也可以自定義自己的動作，或使用其他人分享的動作。</li>
<li>Runners（執行者）是 GitHub Workflow 中用於執行工作的運行環境。它們可以理解為虛擬或實體的主機或容器，用於運行工作中的步驟和動作。<br>GitHub 提供了兩種類型的 Runners：<ul>
<li>Self-hosted Runners（自託管執行者）：這種執行者是由您自己託管的運行環境，可以是實體主機、虛擬機器或容器。您可以在自己的環境中設定和管理這些執行者，以滿足特定的需求和限制。自託管執行者可以與您的內部系統和資源進行交互，並提供更大的靈活性和控制權。</li>
<li>GitHub-hosted Runners（GitHub 托管執行者）：這種執行者是由 GitHub 托管的運行環境，提供了預先配置和管理的虛擬機器或容器。您可以選擇使用這些執行者，並無需擔心配置和管理的細節。GitHub 托管執行者具有多個運行環境選項，包括不同的作業系統（如 Ubuntu、Windows、macOS）和硬體配置（如不同的處理器和內存）。</li>
</ul>
</li>
</ol>
<ul>
<li>使用執行者，您可以在 Workflow 中指定運行環境，並在這些環境中執行步驟和動作。這使您能夠控制和配置工作的運行環境，以確保應用程式在所需的平台上正確運行和測試。另外，執行者還可以與其他 GitHub 功能（如密鑰、存取權杖等）進行集成，以實現更安全的執行環境。</li>
</ul>
<p>在檔案表頭，需要先定義工作流程的名稱，例如是 Android CI</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">name: Android CI</code></pre>

<div class="note danger simple"><p>CICD 工作流程的 yml 配置執行檔<strong>需要嚴謹的語法及縮排</strong>。</p>
</div>

<h3 id="定義事件"><a href="#定義事件" class="headerlink" title="定義事件"></a>定義事件</h3><p>接下來就要定義事件，我們可以用 <code>on</code> 定義事件，例如最常用的是 <code>pull_request</code> 和 <code>push</code> 事件。</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">on:
  pull_request: 
    branches: [ master ]
  push:
    branches: [ master ]</code></pre>

<h3 id="定義工作"><a href="#定義工作" class="headerlink" title="定義工作"></a>定義工作</h3><p>你需要選擇要使用的操作系統進行構建，這裏可以直接選用 <code>ubuntu-latest</code>，這樣接下來要執行的工作都會使用 Ubuntu 最新版本的操作系統運行。</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">jobs:
  build:
    runs-on: ubuntu-latest</code></pre>

<h4 id="定義步驟"><a href="#定義步驟" class="headerlink" title="定義步驟"></a>定義步驟</h4><p>接下來你可以使用 Github Workflow 編輯器旁邊的 Marketplace 提供的擬定步驟</p>
<p><img src="/post/android-dev-android-ci-cd/img2.png" alt="Github Workflow 的 Marketplace"></p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions&#x2F;checkout@v4.1.0

      - name: Setup Java JDK
        uses: actions&#x2F;setup-java@v3.13.0

      - name: Build with Gradle
        run: .&#x2F;gradlew build

      - name: Upload a Build artifact
        uses: actions&#x2F;upload-artifact@v3.1.3
        with:
          name: app-debug.apk
          path: app&#x2F;build&#x2F;outputs&#x2F;apk&#x2F;debug&#x2F;app-debug.apk</code></pre>

<div class="note info simple"><p>如果你的項目使用更高的 JDK 版本，如 JDK 11 或 JDK 17，需要手動修改 JDK 配置</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">- name: Setup Java JDK
  uses: actions&#x2F;setup-java@v3.13.0
  with:
    java-version: &#39;17&#39;
    distribution: &#39;temurin&#39; # JDK，如 oracle, temurin 等
    cache: gradle</code></pre></div>]]></content>
      <categories>
        <category>實驗內容</category>
        <category>Android 開發</category>
      </categories>
      <tags>
        <tag>YAML</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android | 建立密鑰庫並以發佈模式運行程序</title>
    <url>/post/android-dev-keystore-and-release-mode.html</url>
    <content><![CDATA[<p>密鑰庫 (Keystore) 是一個<strong>存儲密鑰和證書的安全文件</strong>，Keystore 被用於對應用程式進行簽名，以確保應用程式的完整性和安全性。它包含了一個私鑰和與之相對應的公鑰。</p>
<p>在開發階段，我們通常會使用調試密鑰庫 (Debug Keystore)，它是由 Android SDK 自動生成的，並且不需要我們主動管理。Debug Keystore 用於在開發期間對應用程式進行簽名，方便我們在<strong>測試和調試應用程式時使用</strong>。</p>
<p>當我們要將應用程式發布到 Google Play 商店或其他渠道時，我們需要使用發佈密鑰庫 (Release Keystore)。Release Keystore 是<strong>由開發者自己生成的</strong>，並且需要妥善保管。它將用於對應用程式<strong>進行正式簽名</strong>，以確保應用程式的安全性和真實性。</p>
<div class="note info simple"><p>在 Jetpack Compose 架構中，使用發佈模式啟動應用程式會較調試模式顯著為快，因為發佈模式優化了編譯及 Compose 重組速度。</p>
</div>

<hr>
<h1 id="構建及簽署應用程式"><a href="#構建及簽署應用程式" class="headerlink" title="構建及簽署應用程式"></a>構建及簽署應用程式</h1><p>要進行 <code>release</code> 版本，最重要的就是要範為應用程式簽署，在 Android Studio，上面選單列的 <code>Build</code> 找 <code>Generate Signed Bundle / APK</code></p>
<p>它會問你選擇 AAB (Android App Bundle) 或是 APK，這裏選擇 APK</p>
<p><img src="/post/android-dev-keystore-and-release-mode/img1.png" alt="img1"></p>
<p>如果你之前已經有建立了的 Keystore 就按 Choose existing… 不然就按 Create new</p>
<p><img src="/post/android-dev-keystore-and-release-mode/img2.png" alt="img2"></p>
<h2 id="建立-Keystore"><a href="#建立-Keystore" class="headerlink" title="建立 Keystore"></a>建立 Keystore</h2><p>建立一個 Keystore 需要填妥表格，包括以下項目</p>
<p><img src="/post/android-dev-keystore-and-release-mode/img3.png" alt="img3"></p>
<ul>
<li><code>Key store path</code>: Keystore 檔案 (副檔名為 <code>.keystore</code>) 存放位置，通常如果是獨立只為獨有應用程式用的 Keystore，這個檔案路徑可以存放到專案的根目錄位置 e.g. <code>AndroidStudioProjects/MyApp/myapp_release.keystore</code></li>
<li><code>Password</code>: 設置 Keystore 的密碼</li>
</ul>
<p>而 <code>Key</code> 有幾項需要注意：</p>
<ul>
<li><code>Alias</code>: Key 的名稱，可以用 <code>key</code> 為前綴 e.g. <code>keyMyApp</code>，不規定。</li>
<li><code>Password</code>: 設置 Key 的密碼，如沒有太大問題，這裏可以都使用 Keystore 密碼</li>
<li><code>Validity</code>: 以年數作計算，預設是 <code>25</code>，就是 Key 的有效期為 25 年</li>
</ul>
<p>而 <code>Certificate</code> 細項中：</p>
<ul>
<li><code>First and Last Name</code>: 用戶名稱</li>
</ul>
<p>其餘的按需要就填。</p>
<h2 id="完成-Keystore"><a href="#完成-Keystore" class="headerlink" title="完成 Keystore"></a>完成 Keystore</h2><p>例如完成好的 Keystore，再按 Next</p>
<p><img src="/post/android-dev-keystore-and-release-mode/img4.png" alt="img4"></p>
<p>這裏會問 Keystore 應用到 <code>debug</code> 或是 <code>release</code>，選擇 <code>release</code>，按 Create</p>
<p><img src="/post/android-dev-keystore-and-release-mode/img5.png" alt="img5"></p>
<hr>
<h1 id="配置-release-構建代碼"><a href="#配置-release-構建代碼" class="headerlink" title="配置 release 構建代碼"></a>配置 <code>release</code> 構建代碼</h1><p>在 <code>app</code> 模塊的 <code>build.gradle.kts</code> 加入代碼：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">buildTypes &#123;
    signingConfigs &#123;
        create(&quot;release&quot;) &#123;
            keyAlias &#x3D; &quot;XXX&quot;
            keyPassword &#x3D; &quot;XXX&quot;         &#x2F;&#x2F; Key 密碼
            storeFile &#x3D; file(&quot;XXX&quot;)
            storePassword &#x3D; &quot;XXX&quot;       &#x2F;&#x2F; Keystore 密碼
        &#125;
    &#125;
    release &#123;
        isMinifyEnabled &#x3D; false
        proguardFiles(
            getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),
            &quot;proguard-rules.pro&quot;
        )
        signingConfig &#x3D; signingConfigs.getByName(&quot;release&quot;)
    &#125;
&#125;</code></pre>

<p><code>storeFile</code> 是 Keystore 檔案存放路徑，例子 </p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">storeFile &#x3D; file(&quot;&#x2F;Users&#x2F;bluewhaleyt&#x2F;AndroidStudioProjects&#x2F;MyApp&#x2F;myapp_release.keystore&quot;)</code></pre>

<div class="note danger simple"><p>由於 Keystore 是私密的敏感資料，例如所設定的密碼不應公開，你可以在 <code>~/.gradle/gradle.properties</code> 檔案內把 Keystore 設定存入在內：</p>
<pre class="line-numbers language-none"><code class="language-none">RELEASE_KEY_ALIAS&#x3D;XXX
RELEASE_KEY_PASSWORD&#x3D;XXX
RELEASE_STORE_FILE_PATH&#x3D;XXX
RELEASE_STORE_PASSWORD&#x3D;XXX</code></pre>

<p>然後在 <code>build.gradle.kts</code> 使用 <code>gradle.properties</code> 內的 Keystore 設定</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">keyAlias RELEASE_KEY_ALIAS
keyPassword RELEASE_KEY_PASSWORD
storeFile file(RELEASE_STORE_FILE_PATH)
storePassword RELEASE_STORE_PASSWORD</code></pre></div>

<hr>
<h1 id="使用-release-構建程式"><a href="#使用-release-構建程式" class="headerlink" title="使用 release 構建程式"></a>使用 <code>release</code> 構建程式</h1><p>把專案 <code>app</code> 的 <code>Build Variant</code> 更改為 <code>release</code> 版本</p>
<div class="note info simple"><p>一旦改 <code>app</code> 的 <code>Build Variant</code> (構建模式)，其他的模塊都會用該構建模式，即一併使用 <code>release</code> 模式。</p>
</div>

<p><img src="/post/android-dev-keystore-and-release-mode/img6.png" alt="img6"></p>
<p>現在 Run 程式就是用 <code>release</code> 模式了</p>
]]></content>
      <categories>
        <category>Android 開發</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Android | NDK 及 C++ Native 程式開發筆記</title>
    <url>/post/android-dev-ndk-cpp-project-notes.html</url>
    <content><![CDATA[<p>C++ 是一種中階程式語言，主要用於遊戲和視覺開發。它也是眾所周知的難以理解的程式語法之一。對於初學者來說，C++ 可以這樣開始：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;

int main(int argc, char * argv[]) &#123;
    std::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl;
    return 0;
&#125;</code></pre>

<p>這種語言與 Android 開發密切相關，因為大多數手機遊戲都是用 C++ 進行編寫和開發的。作為開發 Android 程式的我們，也可以使用 Android Studio 來寫 C++ Native 程式，就像跨領域使用 Java 和 C++ 一樣。</p>
<hr>
<h1 id="初建-C-Native-項目"><a href="#初建-C-Native-項目" class="headerlink" title="初建 C++ Native 項目"></a>初建 C++ Native 項目</h1><p>基本上，如果你是用 Android Studio，可以使用 C++ Native 項目模板建立 C++ Native 程式。</p>
<p><img src="/post/android-dev-ndk-cpp-project-notes/img1.png" alt="C++ 項目模板"></p>
<p>這裏它會要你選擇使用什麼 C++ 版本，通常選擇 Toolchain Default 便可。</p>
<p><img src="/post/android-dev-ndk-cpp-project-notes/img2.png" alt="選擇 C++ 版本"></p>
<h2 id="項目-app-模塊-build-gradle"><a href="#項目-app-模塊-build-gradle" class="headerlink" title="項目 app 模塊 build.gradle"></a>項目 <code>app</code> 模塊 <code>build.gradle</code></h2><p>在 <code>app</code> 模塊的 <code>build.gradle</code> 內的 <code>android</code> 區塊多定義了使用 C++ 函式庫的配置：</p>
<pre class="line-numbers language-gradle" data-language="gradle"><code class="language-gradle">externalNativeBuild &#123;
    cmake &#123;
        path file(&#39;src&#x2F;main&#x2F;cpp&#x2F;CMakeLists.txt&#39;)
        version &#39;3.22.1&#39;
    &#125;
&#125;</code></pre>

<h2 id="項目樹狀結構變更"><a href="#項目樹狀結構變更" class="headerlink" title="項目樹狀結構變更"></a>項目樹狀結構變更</h2><p>因為這是一個 C++ Native 項目，所以它會較一般的 Android 項目多附加了一些預設元素，如果你沒有 C++ Native 模板或 Android Studio，可考慮以下樹狀結構變更。</p>
<p><img src="/post/android-dev-ndk-cpp-project-notes/img3.png" alt="樹狀結構變更"></p>
<p>在 app 目錄會多新增了一個 <code>cpp</code> 資料夾，顧名思義，這個資料夾是用來管理及編寫 C++ 語言。</p>
<h3 id="CMake-建構指令碼"><a href="#CMake-建構指令碼" class="headerlink" title="CMake 建構指令碼"></a>CMake 建構指令碼</h3><p>CMake 建構指令碼是一個純文字檔案，檔案名必須為 <code>CMakeLists.txt</code>。就是負責為 C 或 C++ 程式定義要用的函式庫，相當於 Java 的 <code>build.gradle</code>。</p>
<p>根據這個模板，預設的 <code>CMakeLists.txt</code> 內容是這樣的：</p>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"># For more information about using CMake with Android Studio, read the
# documentation: https:&#x2F;&#x2F;d.android.com&#x2F;studio&#x2F;projects&#x2F;add-native-code.html.
# For more examples on how to use CMake, see https:&#x2F;&#x2F;github.com&#x2F;android&#x2F;ndk-samples.

# Sets the minimum CMake version required for this project.
cmake_minimum_required(VERSION 3.22.1)

# Declares the project name. The project name can be accessed via $&#123; PROJECT_NAME&#125;,
# Since this is the top level CMakeLists.txt, the project name is also accessible
# with $&#123;CMAKE_PROJECT_NAME&#125; (both CMake variables are in-sync within the top level
# build script scope).
project(&quot;cppapptest&quot;)

# Creates and names a library, sets it as either STATIC
# or SHARED, and provides the relative paths to its source code.
# You can define multiple libraries, and CMake builds them for you.
# Gradle automatically packages shared libraries with your APK.
#
# In this top level CMakeLists.txt, $&#123;CMAKE_PROJECT_NAME&#125; is used to define
# the target library name; in the sub-module&#39;s CMakeLists.txt, $&#123;PROJECT_NAME&#125;
# is preferred for the same purpose.
#
# In order to load a library into your app from Java&#x2F;Kotlin, you must call
# System.loadLibrary() and pass the name of the library defined here;
# for GameActivity&#x2F;NativeActivity derived applications, the same library name must be
# used in the AndroidManifest.xml file.
add_library($&#123;CMAKE_PROJECT_NAME&#125; SHARED
        # List C&#x2F;C++ source files with relative paths to this CMakeLists.txt.
        native-lib.cpp)

# Specifies libraries CMake should link to your target library. You
# can link libraries from various origins, such as libraries defined in this
# build script, prebuilt third-party libraries, or Android system libraries.
target_link_libraries($&#123;CMAKE_PROJECT_NAME&#125;
        # List libraries link to the target library
        android
        log)</code></pre>

<h3 id="Java-與-C-鏈結產生"><a href="#Java-與-C-鏈結產生" class="headerlink" title="Java 與 C++ 鏈結產生"></a>Java 與 C++ 鏈結產生</h3><p>這個模板預設提供了一個 <code>native-lib.cpp</code> 檔案。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;jni.h&gt;
#include &lt;string&gt;

extern &quot;C&quot; JNIEXPORT jstring JNICALL
Java_com_bluewhaleyt_cppapptest_MainActivity_stringFromJNI(
        JNIEnv* env,
        jobject &#x2F;* this *&#x2F;) &#123;
    std::string hello &#x3D; &quot;Hello from C++&quot;;
    return env-&gt;NewStringUTF(hello.c_str());
&#125;</code></pre>

<p>而在 <code>MainActivity.java</code> 多新增了一個載入 <code>native-lib</code> C++ 本機函式庫的程式碼，而及一個 <code>native</code> 關鍵字而成的 C++ 調用函數：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">static &#123;
    System.loadLibrary(&quot;cppapptest&quot;);
&#125;

public native String stringFromJNI();</code></pre>

<hr>
<h1 id="Java-本機介面-JNI"><a href="#Java-本機介面-JNI" class="headerlink" title="Java 本機介面 (JNI)"></a>Java 本機介面 (JNI)</h1><p>JNI 是一個編程框架，透過 Java 虛擬機 (JVM) 調用函式庫，或其他本機程序，本機程序一般使用 C、C++ 或匯編語言 (Assembly) 編寫，從而被編譯為爾件及系統操作的程序。</p>
<p>在以上模板，你可以看到，定義一個 JNI 方法，需要這麼長的程式碼：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">extern &quot;C&quot; JNIEXPORT jstring JNICALL
Java_ClassName_functionName(
    JNIEnv* env,
    jobject &#x2F;* this *&#x2F;
) &#123; ... &#125;</code></pre>

<div class="note info simple"><p>在這個範例中，<code>ClassName</code> 是項目的 Java <code>MainActivity</code> 類別 <code>com_bluewhaleyt_cppapptest_MainActivity</code></p>
</div>

<p>而在 Java 程式調用 C++ 函數 <code>functionName()</code>，就要另外定義一個附有 <code>native</code> 關鍵字的相應函數：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public native String functionName();</code></pre>

<p>特別要說說 C++ 程式碼：</p>
<ul>
<li><code>extern &quot;C&quot;</code>: 是一個限制使用 C 語言作為命名規則，即該函數將會採用 C 語言進行定義。</li>
<li><code>JNIEXPORT</code> 及 <code>JNICALL</code>: 是定義 JNI 函數的修飾詞。</li>
<li><code>jstring</code>: 是指明函數傳回類型是 Java 的 <code>String</code> 型別</li>
<li><code>JNIEnv</code>: 是一個指向 JNI 環境的指標，提供了在本地程式碼中調用 Java 方法、訪問 Java 對象等操作的方法。</li>
<li><code>jobject</code>: 是一個代表 Java 對象的類型。它可以是任何 Java 對象的參考，並且可以在本地程式碼中用於訪問該對象的屬性和方法。</li>
</ul>
<div class="note info simple"><p>基本上這個 JNI 定義方法不用手動敲的，可以直接用 Android Studio 的自動完成方案：</p>
<p>只要在 Java 定義一個 <code>native</code> 方法：</p>
<p><img src="/post/android-dev-ndk-cpp-project-notes/img4.png" alt="C++ 自動完成方案"></p>
<p>然後就會在 C++ 檔案生成了程式碼：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">extern &quot;C&quot;
JNIEXPORT void JNICALL
Java_com_bluewhaleyt_cppapptest_MainActivity_myTestFunc(JNIEnv *env, jobject thiz) &#123;
    &#x2F;&#x2F; TODO: implement myTestFunc()
&#125;</code></pre>

<p>所以你大可以不用學會怎樣寫 JNI 方法，只要理解便可。</p>
</div>

<hr>
<h1 id="動態鏈接庫-so"><a href="#動態鏈接庫-so" class="headerlink" title="動態鏈接庫 (.so)"></a>動態鏈接庫 (<code>.so</code>)</h1><p>把編譯並匯出後的 <code>.apk</code> 檔案修改為 <code>.zip</code> 檔案解壓縮，開啟 lib 資料夾就可以看到 <code>.so</code> 檔案。</p>
<p>Android Studio 的 C++ Native 模板預設支援及提供以下 NDK 架構:</p>
<p><img src="/post/android-dev-ndk-cpp-project-notes/img5.png" alt="NDK .so"></p>
]]></content>
      <categories>
        <category>實驗內容</category>
        <category>Android 開發</category>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>NDK</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetpack Compose | APK 插件化筆記</title>
    <url>/post/android-dev-plugin-system-implementation-notes.html</url>
    <content><![CDATA[<p>在以往使用 XML 架構的插件化方式，我們需要依賴 <code>AndroidManifest.xml</code> 多個附加插件的 <code>Activity</code>，再透過反射 (Reflection) API 把插件提供的 <code>Activity</code> 開放予主項目程式導入，使得 Android 碎片化。</p>
<p>現在來到新型 Jetpack Compose 架構，因為 Compose 基本上要編寫的 UI 都是一個可組合項 (<code>Composable</code>)，所以事情變得簡單多了。</p>
<div class="note info simple"><p>這個方法仍可應用於傳統的 XML 架構佈局。</p>
</div>

<hr>
<h1 id="插件的配置"><a href="#插件的配置" class="headerlink" title="插件的配置"></a>插件的配置</h1><p>在這個範例中，我們會製作一個 <code>plugin-amazingbutton</code> 插件，提供一個漸變色按鈕作範例。</p>
<p>要記得 <code>plugin-*</code> 模塊 <code>build.gradle.kts</code> 是 Application 而不是 Library 製式，因為插件最終會以 APK 形成。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">plugins &#123;
    alias(libs.plugins.androidApplication)
    alias(libs.plugins.kotlinGradlePlugin)
&#125;</code></pre>

<p>如果你的插件 APK 是可以開啟的，可以在 <code>plugin-*</code> 模塊的 <code>AndroidManifest.xml</code> 設定應用程式基本配置。</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;
&lt;manifest xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt;

    &lt;application
        android:icon&#x3D;&quot;@android:mipmap&#x2F;sym_def_app_icon&quot;
        android:label&#x3D;&quot;PluginSystemTest - AmazingButton Plugin&quot;&gt;

        &lt;activity
            android:name&#x3D;&quot;.MainActivity&quot;
            android:exported&#x3D;&quot;true&quot;&gt;
            &lt;intent-filter&gt;
                &lt;action android:name&#x3D;&quot;android.intent.action.MAIN&quot; &#x2F;&gt;
                &lt;category android:name&#x3D;&quot;android.intent.category.LAUNCHER&quot; &#x2F;&gt;
            &lt;&#x2F;intent-filter&gt;
        &lt;&#x2F;activity&gt;

    &lt;&#x2F;application&gt;

&lt;&#x2F;manifest&gt;</code></pre>

<h2 id="插件提供的可組合組件"><a href="#插件提供的可組合組件" class="headerlink" title="插件提供的可組合組件"></a>插件提供的可組合組件</h2><p>在這個範例中，這個 <code>plugin-amazingbutton</code> 插件會提供一個製作漸變色按鈕的函式。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">class AmazingButton &#123;
    val AmazingButton: (@Composable () -&gt; Unit) &#x3D; &#123;
        GradientButton(
            text &#x3D; &quot;Button text&quot;,
            gradient &#x3D; Brush.horizontalGradient(listOf(Color(0xFF28D8A3), Color(0xFF00BEB2)))
        )
    &#125;
&#125;

@Composable
private fun GradientButton(
    text: String,
    gradient : Brush,
    modifier: Modifier &#x3D; Modifier,
    onClick: () -&gt; Unit &#x3D; &#123; &#125;,
) &#123;
    Button(
        modifier &#x3D; modifier,
        colors &#x3D; ButtonDefaults.buttonColors(containerColor &#x3D; Color.Transparent),
        contentPadding &#x3D; PaddingValues(),
        onClick &#x3D; &#123; onClick() &#125;,
    ) &#123;
        Box(
            modifier &#x3D; Modifier
                .background(gradient)
                .padding(12.dp)
                .then(modifier),
            contentAlignment &#x3D; Alignment.Center,
        ) &#123;
            Text(text &#x3D; text)
        &#125;
    &#125;
&#125;</code></pre>

<div class="note info simple"><p>你可能會問，為什麼 <code>AmazingButton</code> 不是用平時的函式方式建立，而是用 Lambda 方式建立呢？</p>
<p>因為 Jetpack Compose 的可組合函式經過 JVM 編譯後會生成附加 2 個參數項：<code>Composer</code> 及 <code>Int</code>。如果沿用以下這個方式定義可組合項，可能會因為導致傳入參數錯誤而無法成功重組。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Composable
fun AmazingButton() &#123;
    &#x2F;&#x2F; ...
&#125;</code></pre>

<p>如果你用的是這個方式建立，那麼反射做法：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val method: Method &#x3D;
    plugin.getDeclaredMethod(
        &quot;AmazingButton&quot;,
        Composer::class.java,
        Int::class.java
    )
method.isAccessible &#x3D; true
val obj &#x3D; plugin.getDeclaredConstructor().newInstance()</code></pre></div>

<hr>
<h1 id="獲取檔案存取請求"><a href="#獲取檔案存取請求" class="headerlink" title="獲取檔案存取請求"></a>獲取檔案存取請求</h1><p>在 <code>app</code> 模塊的 <code>AndroidManifest.xml</code> 記得加上使用權限設定：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;uses-permission android:name&#x3D;&quot;android.permission.READ_EXTERNAL_STORAGE&quot; &#x2F;&gt;
&lt;uses-permission android:name&#x3D;&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; &#x2F;&gt;
&lt;uses-permission android:name&#x3D;&quot;android.permission.MANAGE_EXTERNAL_STORAGE&quot; &#x2F;&gt;

&lt;application
    android:requestLegacyExternalStorage&#x3D;&quot;true&quot; &#x2F;&gt;</code></pre>

<h2 id="允許存取所有檔案"><a href="#允許存取所有檔案" class="headerlink" title="允許存取所有檔案"></a>允許存取所有檔案</h2><div class="note warning simple"><p>所有檔案存取 (All File Access) 權限只限於 SDK 30 (Android 11) 或以上使用。</p>
</div>

<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@RequiresApi(Build.VERSION_CODES.R)
fun requestAllFileAccess(
    context: Context
) &#123;
    if (!Environment.isExternalStorageManager()) &#123;
        val intent &#x3D; Intent(Settings.ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION)
        val uri &#x3D; Uri.fromParts(&quot;package&quot;, context.packageName, null)
        intent.setData(uri)
        context.startActivity(intent)
    &#125;
&#125;</code></pre>

<h2 id="管理權限的內容容器"><a href="#管理權限的內容容器" class="headerlink" title="管理權限的內容容器"></a>管理權限的內容容器</h2><p>這個內容容器是用來簡易對權限處理的佈局進行操作，理想用法如下：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">Container &#123; permissionGranted -&gt;
    if (permissionGranted) -&gt; Comp1() else Comp2()
&#125;</code></pre>

<p><code>Container</code> 可組合函式會處理好關於權限讀取的程序，我們還會預設把 <code>plugins</code> 資料夾建立到 <code>storage/emulated/0/&lt;程式名稱&gt;/</code> 路徑內。</p>
<details class="folding-tag"><summary> 瀏覽 Container 可組合函式程式碼 </summary>
              <div class="content">
              <pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Composable
fun Container(
    content: @Composable ColumnScope.(
        permissionGranted: Boolean, pluginsDir: File
    ) -&gt; Unit
) &#123;
    val context &#x3D; LocalContext.current
    val permissions &#x3D; arrayOf(
        Manifest.permission.READ_EXTERNAL_STORAGE,
        Manifest.permission.WRITE_EXTERNAL_STORAGE
    )
    val readWritePermissionGranted &#x3D; permissions.all &#123;
        ContextCompat.checkSelfPermission(context, it) &#x3D;&#x3D; PackageManager.PERMISSION_GRANTED
    &#125;
    val permissionsGranted &#x3D; if (Build.VERSION.SDK_INT &gt;&#x3D; Build.VERSION_CODES.S) &#123;
        Environment.isExternalStorageManager() &amp;&amp; readWritePermissionGranted
    &#125; else readWritePermissionGranted

    val launcher &#x3D; rememberLauncherForActivityResult(
        contract &#x3D; ActivityResultContracts.RequestMultiplePermissions(),
        onResult &#x3D; &#123;

        &#125;
    )

    LaunchedEffect(Unit) &#123;
        launcher.launch(permissions)
    &#125;

    if (Build.VERSION.SDK_INT &gt;&#x3D; Build.VERSION_CODES.R) &#123;
        requestAllFileAccess(context)
        val pluginsDir &#x3D; File(Environment.getExternalStorageDirectory().absolutePath + &quot;&#x2F;PluginSystemTest&#x2F;plugins&#x2F;&quot;)
        if (permissionsGranted) &#123;
            pluginsDir.takeIf &#123; !it.exists()
                it.mkdirs()
            &#125;
        &#125;
        Column(
            modifier &#x3D; Modifier.padding(16.dp)
        ) &#123;
            content(permissionsGranted, pluginsDir)
        &#125;
    &#125;
&#125;</code></pre>
              </div>
            </details>

<hr>
<h1 id="下載插件-APK-安裝檔"><a href="#下載插件-APK-安裝檔" class="headerlink" title="下載插件 APK 安裝檔"></a>下載插件 APK 安裝檔</h1><h2 id="測試用途：直接編譯-plugin-並匯出"><a href="#測試用途：直接編譯-plugin-並匯出" class="headerlink" title="測試用途：直接編譯 plugin-* 並匯出"></a>測試用途：直接編譯 <code>plugin-*</code> 並匯出</h2><p>你可以直接把其匯出，獲取插件 APK 安裝檔，再手動存放到目標路徑運行，<strong>但只僅作初始測試用途</strong>。</p>
<h2 id="實際用途：把插件-APK-安裝檔存放到-URL-或伺服器端"><a href="#實際用途：把插件-APK-安裝檔存放到-URL-或伺服器端" class="headerlink" title="實際用途：把插件 APK 安裝檔存放到 URL 或伺服器端"></a>實際用途：把插件 APK 安裝檔存放到 URL 或伺服器端</h2><ol>
<li>你可以把插件 APK 安裝檔存放到檔案存放平台，再獲取其下載鏈結，藉由 <code>DownloadManager</code> 把檔案下載並存放到目標路徑。</li>
</ol>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;uses-permission android:name&#x3D;”android.permission.INTERNET”&#x2F;&gt;</code></pre>

<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun downloadFile(context: Context, url: String, file: File) &#123;
    val request &#x3D; DownloadManager.Request(Uri.parse(url))
    request.apply &#123;
        setDestinationUri(file.toUri())
        setTitle(file.name)
        setDescription(&quot;Downloading...&quot;)
    &#125;

    val downloadManager &#x3D; context.getSystemService(Context.DOWNLOAD_SERVICE) as DownloadManager
    downloadManager.enqueue(request)
&#125;</code></pre>
<ol start="2">
<li>自已架設伺服器</li>
</ol>
<hr>
<h1 id="顯示並遍歷已下載插件"><a href="#顯示並遍歷已下載插件" class="headerlink" title="顯示並遍歷已下載插件"></a>顯示並遍歷已下載插件</h1><p>基本上就是遍歷檔案路徑的所有檔案，但唯獨只顯示所有屬於 APK 安裝檔的檔案。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Composable
fun MainScreen() &#123;
    Container &#123; permissionGranted, pluginsDir -&gt;
        if (permissionGranted) &#123;
            LazyColumn &#123;
                pluginsDir.listFiles()?.let &#123;
                    items(it) &#123; file -&gt;
                        if (file.extension &#x3D;&#x3D; &quot;apk&quot;) &#123;
                            FileItem(file &#x3D; file)
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;

@Composable
fun FileItem(
    modifier: Modifier &#x3D; Modifier,
    file: File
) &#123;
    Row(
        modifier &#x3D; modifier
            .fillMaxWidth()
            .clip(MaterialTheme.shapes.extraLarge)
            .background(MaterialTheme.colorScheme.surfaceContainer)
            .padding(16.dp)
    ) &#123;
        Icon(
            imageVector &#x3D; Icons.Outlined.Android,
            contentDescription &#x3D; null,
            tint &#x3D; MaterialTheme.colorScheme.primary
        )
        Spacer(modifier &#x3D; Modifier.width(16.dp))
        Column &#123;
            Text(text &#x3D; file.nameWithoutExtension, style &#x3D; MaterialTheme.typography.titleLarge)
            Text(text &#x3D; file.path, style &#x3D; MaterialTheme.typography.bodyMedium.copy(color &#x3D; LocalContentColor.current.copy(0.38f)))
        &#125;
    &#125;
&#125;</code></pre>

<h1 id="載入插件"><a href="#載入插件" class="headerlink" title="載入插件"></a>載入插件</h1><h2 id="載入插件安裝檔"><a href="#載入插件安裝檔" class="headerlink" title="載入插件安裝檔"></a>載入插件安裝檔</h2><p>我們會透過用 Java 類加載器 (<code>DexClassLoader</code>) 動態載入要使用的插件 APK。另外，我們會為插件存放 Dex 檔案，用於存儲編譯後的 Java 程式碼和資源。當加載插件時，<code>DexClassLoader</code> 會需要在指定的路徑中尋找並加載 Dex 檔案。如果不創建 Dex 目錄，或會導致應用程式在執行時出現錯誤或異常情況。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">object PluginManager &#123;

    var pluginClassLoader: DexClassLoader? &#x3D; null

    fun loadPluginFromFile(
        context: Context,
        file: File,
    ): DexClassLoader? &#123;
        val filesDir &#x3D; context.externalCacheDir
        val apkFile &#x3D; File(filesDir?.absolutePath, file.name)
        file.copyTo(apkFile, true)

        val dexFile &#x3D; File(filesDir, &quot;dex&quot;)
        if (!dexFile.exists()) &#123;
            dexFile.mkdirs()
        &#125;

        pluginClassLoader &#x3D; DexClassLoader(
            apkFile.absolutePath,
            apkFile.absolutePath,
            null,
            context.classLoader
        )
        return pluginClassLoader
    &#125;

&#125;</code></pre>

<h2 id="載入插件的程式"><a href="#載入插件的程式" class="headerlink" title="載入插件的程式"></a>載入插件的程式</h2><p>在這個範例中，我們會透過點擊一個按鈕來載入插件提供的漸變色按鈕。</p>
<p>我們可以宣告兩個狀態：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">var pluginApplySuccess by mutableStateOf(false)
var pluginCompose by mutableStateOf&lt;@Composable () -&gt; Unit&gt;(&#123;&#125;)</code></pre>

<ul>
<li><code>pluginApplySuccess</code>: 用來更新插件成功載入與否的狀態</li>
<li><code>pluginCompose</code>: 用來顯示載入插件後的可組合項</li>
</ul>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun loadAmazingButton(context: Context) &#123;
    if (pluginApplySuccess) return

    val pluginsDir &#x3D; Environment.getExternalStorageDirectory().absolutePath + &quot;&#x2F;PluginSystemTest&#x2F;plugins&#x2F;&quot;
    val pluginFile &#x3D; PluginManager.loadPluginFromFile(context, File(&quot;$pluginsDir&#x2F;plugin-amazingbutton.apk&quot;))
    val plugin &#x3D; pluginFile?.loadClass(&quot;com.bluewhaleyt.plugin.amazingbutton.AmazingButton&quot;)
    
    plugin?.let &#123;
        val method &#x3D; plugin.getDeclaredMethod(&quot;getAmazingButton&quot;)
        method.isAccessible &#x3D; true
        val obj &#x3D; plugin.getDeclaredConstructor().newInstance()
        pluginCompose &#x3D; method.invoke(obj) as (@Composable () -&gt; Unit)
        pluginApplySuccess &#x3D; true
    &#125;
&#125;</code></pre>

<div class="note danger simple"><p>經過 JVM 編譯後的 <code>AmazingButton</code> Lambda <code>get()</code> 屬性會變成 Java 的 <code>getAmazingButton()</code> 方法。</p>
</div>

<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Composable
fun MainScreen() &#123;
    val context &#x3D; LocalContext.current
    Container &#123; permissionGranted, pluginsDir -&gt;
        if (permissionGranted) &#123;
            Button(
                onClick &#x3D; &#123;
                    loadAmazingButton(context)
                &#125;
            ) &#123;
                Text(text &#x3D; &quot;Load AmazingButton&quot;)
            &#125;
            AnimatedContent(
                targetState &#x3D; pluginCompose,
                label &#x3D; &quot;Plugin content&quot;
            ) &#123; pluginContent -&gt;
                Column(
                    modifier &#x3D; Modifier
                        .fillMaxWidth()
                        .clip(MaterialTheme.shapes.extraLarge)
                        .background(color &#x3D; MaterialTheme.colorScheme.primaryContainer)
                        .padding(16.dp)
                ) &#123;
                    Text(text &#x3D; &quot;Plugins loaded area&quot;)
                    pluginContent()
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>]]></content>
      <categories>
        <category>實驗內容</category>
        <category>Android 開發</category>
        <category>學習筆記</category>
        <category>Jetpack Compose</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Android | 多功能的 sora-editor 函式庫綜合使用筆記</title>
    <url>/post/android-dev-sora-editor-library-notes.html</url>
    <content><![CDATA[<div class="note warning simple"><p>這篇筆記是純粹為個人而寫的筆記，因為 sora-editor 函式庫太多 API，然而目前為止還沒有正式的 API 文檔，所以唯有自己記下。如果內容有用，我會考慮加上英文翻譯，但我的英文很爛，謝謝。</p>
</div>

<p>sora-editor 是一個多功能的 Android 代碼編輯器庫，這個庫提供了許多功能，包括語法高亮、自動完成等編輯器常用的特性。</p>
<h1 id="基礎入門"><a href="#基礎入門" class="headerlink" title="基礎入門"></a>基礎入門</h1><h2 id="匯入依附元件"><a href="#匯入依附元件" class="headerlink" title="匯入依附元件"></a>匯入依附元件</h2><p>基本上這個函式庫的核心是 <code>editor</code> 模組，它是負責編輯器組件的實現功能。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">dependencies &#123;
    implementation(platform(&quot;io.github.Rosemoe.sora-editor:bom:0.22.2&quot;))
    
    &#x2F;&#x2F; 啟用 Editor 基本模組庫
    implementation(&quot;io.github.Rosemoe.sora-editor:editor&quot;)

    &#x2F;&#x2F; 啟用 Java 語言模組庫
    implementation(&quot;io.github.Rosemoe.sora-editor:language-java&quot;)
    
    &#x2F;&#x2F; 啟用 TextMate 語法高亮模組庫
    implementation(&quot;io.github.Rosemoe.sora-editor:language-textmate&quot;)
    
    &#x2F;&#x2F; 其他處於開發階段的試驗性模組庫，有興趣可以使用
    &#x2F;&#x2F; 啟用語言伺服器協定 (LSP) 的 Editor 模組庫
    implementation(&quot;io.github.Rosemoe.sora-editor:editor-lsp&quot;)
    
    &#x2F;&#x2F; 啟用 Tree-Sitter 語法高亮模組庫
    implementation(&quot;io.github.Rosemoe.sora-editor:language-treesitter&quot;)
&#125;</code></pre>

<h2 id="定義基本組件至佈局"><a href="#定義基本組件至佈局" class="headerlink" title="定義基本組件至佈局"></a>定義基本組件至佈局</h2><ol>
<li>編輯器<div class="note info simple"><p><code>CodeEditor</code> 視圖通常只會用於「全螢幕」，只可以把 <code>layout_width</code> 和 <code>layout_height</code> 設為絕對值或 <code>match_parent</code>。</p>
</div>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;io.github.rosemoe.sora.widget.CodeEditor
    android:id&#x3D;&quot;@+id&#x2F;editor&quot;
    android:layout_width&#x3D;&quot;match_parent&quot;
    android:layout_height&#x3D;&quot;match_parent&quot; &#x2F;&gt;</code></pre></li>
<li>符號插入工具項<br>另外，為了用戶方便使用你的編輯器程式，你可以在 <code>CodeEditor</code> 下方新增一個符號插入工具項，要注意的是，需要加上 <code>HorizontalScrollView</code> 來對工具項進行水平捲動。<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;HorizontalScrollView
    android:layout_width&#x3D;&quot;match_parent&quot;
    android:layout_height&#x3D;&quot;40dp&quot;&gt;
    &lt;io.github.rosemoe.sora.widget.SymbolInputView
        android:id&#x3D;&quot;@+id&#x2F;symbol_input_view&quot;
        android:layout_width&#x3D;&quot;match_parent&quot;
        android:layout_height&#x3D;&quot;match_parent&quot; &#x2F;&gt;
&lt;&#x2F;HorizontalScrollView&gt;</code></pre>
預設的 <code>SymbolInputView</code> 是沒有任何符號提供的，需要手動加入<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val displayText &#x3D; listOf(&quot;→&quot;, &quot;&#123;&quot;, &quot;&#125;&quot;, &quot;(&quot;, &quot;)&quot;, &quot;[&quot;, &quot;]&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;,&quot;, &quot;.&quot;, &quot;;&quot;, &quot;\&quot;&quot;, &quot;&#39;&quot;, &quot;?&quot;, &quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;&#x2F;&quot;, &quot;&#x3D;&quot;)
val insertText  &#x3D; listOf(&quot;\t&quot;, &quot;&#123;&#125;&quot;, &quot;&#125;&quot;, &quot;()&quot;, &quot;)&quot;, &quot;[]&quot;, &quot;]&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;,&quot;, &quot;.&quot;, &quot;;&quot;, &quot;\&quot;&quot;, &quot;&#39;&quot;, &quot;?&quot;, &quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;&#x2F;&quot;, &quot;&#x3D;&quot;)

symbolInputView.apply &#123;
    bindEditor(codeEditor)
    addSymbols(displayText, insertText);
&#125;</code></pre>
<div class="note info simple"><p><code>displayText</code> 用來顯示的符號，而 <code>insertText</code> 用來插入的符號</p>
</div></li>
</ol>
<h2 id="設置字體"><a href="#設置字體" class="headerlink" title="設置字體"></a>設置字體</h2><p>在 <code>app/src/main</code> 新建一個 <code>assets</code> 資料夾，再在裏面新建一個 <code>fonts</code> 資料夾，自己把要用的字體檔案放進去。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val font &#x3D; Typeface.createFromAsset(context.assets, &quot;fonts&#x2F;JetBrainsMono.ttf&quot;)
editor.apply &#123;
    typefaceText &#x3D; font
    typefaceLineNumber &#x3D; font
&#125;</code></pre>

<div class="note danger simple"><p><code>CodeEditor</code> 內建的 <code>isLigatureEnabled</code> <strong>只支援字體連字特性</strong>，如常見的 JetBrains Mono 字型 (別下載 NL (No-ligatures) 是沒有連字特性)</p>
</div>

<h2 id="獲取游標點選的文字"><a href="#獲取游標點選的文字" class="headerlink" title="獲取游標點選的文字"></a>獲取游標點選的文字</h2><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun CodeEditor.getSelectedText(): String &#123;
    val cursor &#x3D; this.cursor
    return this.text.subContent(
        cursor.leftLine,
        cursor.leftColumn,
        cursor.rightLine,
        cursor.rightColumn
    ).toString()
&#125;</code></pre>

<div class="note info simple"><p>例如把點選文字轉成大寫：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">editor.apply &#123;
    commitText(getSelectedText().uppercase())
&#125;</code></pre></div>

<h2 id="獲取目前行的文字"><a href="#獲取目前行的文字" class="headerlink" title="獲取目前行的文字"></a>獲取目前行的文字</h2><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun CodeEditor.getLineNumber() &#x3D; this.cursor.leftLine
fun CodeEditor.getLineNumberText(line: Int &#x3D; 0) &#x3D; this.text.getLineString(line)

val currentLineText &#x3D; editor.getLineNumberText(editor.getLineNumber())</code></pre>

<hr>
<h1 id="進階特性"><a href="#進階特性" class="headerlink" title="進階特性"></a>進階特性</h1><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p><code>CodeEditor</code> 提供了許多對於編輯器的行為及事件，當要註冊一個事件，就要用 <code>subscribeEvent()</code> 函數。</p>
<h3 id="內容變動事件"><a href="#內容變動事件" class="headerlink" title="內容變動事件"></a>內容變動事件</h3><p>我們可以使用 <code>ContentChangeEvent</code> 監聽編輯器的文本內容變動</p>
<div class="tabs" id="code_contentchangeevent_kotlin"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="code_contentchangeevent_kotlin-1">Kotlin</button><button type="button" class="tab " data-href="code_contentchangeevent_kotlin-2">Java</button></ul><div class="tab-contents"><div class="tab-item-content active" id="code_contentchangeevent_kotlin-1"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">editor.subscribeEvent(ContentChangeEvent::class.java) &#123; _, _ -&gt;
    &#x2F;&#x2F; ...      
&#125;</code></pre></div><div class="tab-item-content" id="code_contentchangeevent_kotlin-2"><pre class="line-numbers language-java" data-language="java"><code class="language-java">editor.subscribeEvent(ContentChangeEvent.class, new EventReceiver&lt;ContentChangeEvent&gt;() &#123;
    @Override
    public void onReceive(@NonNull ContentChangeEvent event, @NonNull Unsubscribe unsubscribe) &#123;
        &#x2F;&#x2F; ...
    &#125;
&#125;);</code></pre></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>

<h3 id="實體鍵盤鍵綁定事件"><a href="#實體鍵盤鍵綁定事件" class="headerlink" title="實體鍵盤鍵綁定事件"></a>實體鍵盤鍵綁定事件</h3><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">editor.subscribeEvent(KeyBindingEvent::class.java) &#123; event, _ -&gt;
    if ((event.keyCode &#x3D;&#x3D; KeyEvent.KEYCODE_P) &amp;&amp; event.isShiftPressed) &#123;
        Toast.makeText(context, &quot;Shift + P action&quot;, Toast.LENGTH_SHORT).show()
    &#125;
&#125;</code></pre>

<h2 id="文本搜尋與取代"><a href="#文本搜尋與取代" class="headerlink" title="文本搜尋與取代"></a>文本搜尋與取代</h2><p><code>CodeEditor</code> 內建一個 <code>Searcher</code> 進行文本搜尋，你有兩個方法把搜尋器加入到程式：</p>
<ol>
<li>把搜尋元件加入到懸浮動作頂部列 (<code>ActionBar</code>)，這點 <code>CodeEditor</code> 的 <code>beginSearchMode()</code> 已經會做這件事<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">editor.beginSearchMode()</code></pre></li>
<li>直接用輸入組件 e.g. <code>EditText</code><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">searchInput.addTextChangedListener(object : TextWatcher) &#123;
    override fun beforeTextChanged(charSequence: CharSequence, i: Int, i1: Int, i2: Int) &#123;&#125;
    override fun onTextChanged(charSequence: CharSequence, i: Int, i1: Int, i2: Int) &#123;&#125;
    override fun afterTextChanged(editable: Editable) &#123;
        if (editable.isNotEmpty()) &#123;
            try &#123;
                editor.searcher.search(
                    editable.toString, EditorSearcher.SearchOptions(false, false)
                )
            &#125; catch (e: PatternSyntaxException) &#123;
                e.printStacktrace()
            &#125;
        &#125; else editor.searcher.stopSearch()
    &#125;
&#125;</code></pre>
<div class="note info simple"><p><code>EditorSearcher.SearchOptions()</code> 有兩個重載，</p>
<ol>
<li>這個情況下的接受兩個 <code>boolean</code> 參數，<code>EditorSearcher.SearchOptions(false, false)</code> 必須接受兩個參數，第一個是 <code>ignoreCase</code>，即判斷大小寫須相符的準則，第二個是 <code>useRegex</code>，即使用正則表示式與否。</li>
<li>如果想實現啟用或不啟用全字拼寫須相符、大小寫須相符之類的，這個重載是接受 <code>@IntRange(from = 1, to = 3) int type, boolean ignoreCase</code> 可考慮以下代碼：<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val type &#x3D; when &#123;
    regex -&gt; SearchOptions.TYPE_REGULAR_EXPRESSION
    wholeWord -&gt; SearchOptions.TYPE_WHOLE_WORD
    else -&gt; SearchOptions.TYPE_NORMAL
&#125;
val searchOptions &#x3D; EditorSearcher.SearchOptions(type, ignoreCase)</code></pre></li>
</ol>
</div></li>
</ol>
<p>至於取代的實現方式，會用到 <code>replaceThis()</code> 或 <code>replaceAll()</code></p>
<ul>
<li><code>replaceThis()</code>: 取代當前所輸入的字符至編輯器</li>
<li><code>replaceAll()</code>: 一併取代所輸入的字符至編輯器</li>
</ul>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">editor.searcher.apply &#123;
    replaceThis(replaceInput.text.toString())
    replaceAll(replaceInput.text.toString())
&#125;</code></pre>

<h2 id="診斷程序"><a href="#診斷程序" class="headerlink" title="診斷程序"></a>診斷程序</h2><p><code>CodeEditor</code> 並沒有提供診斷程式程序，這個功能你要自行編寫代碼實現，但提供了設置診斷程序的提示和指標器。</p>
<p>支援的嚴重程度 (Severity) 如下：</p>
<ul>
<li><code>SEVERITY_ERROR</code> ：紅色，代表錯誤</li>
<li><code>SEVERITY_WARNING</code>：黃色，代表警告</li>
<li><code>SEVERITY_TYPO</code>：綠色，代表錯別字</li>
</ul>
<div class="tabs" id="code_diagnostics_kotlin"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="code_diagnostics_kotlin-1">Kotlin</button><button type="button" class="tab " data-href="code_diagnostics_kotlin-2">Java</button></ul><div class="tab-contents"><div class="tab-item-content active" id="code_diagnostics_kotlin-1"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">editor.apply &#123;
    diagnostics &#x3D; DiagnosticsContainer()
    setDiagnostic(36, 44, DiagnosticRegion.SEVERITY_ERROR, &quot;Error&quot;, &quot;Message&quot;,
        listOf(
            Quickfix(&quot;Fix&quot;, 0L, null),
            Quickfix(&quot;Other&quot;, 0L, null)
        )
    )
&#125;

private fun CodeEditor.setDiagnostic(startIndex: Int, endIndex: Int, type: Short, briefMessage: String, detailedMessage: String, list: List&lt;Quickfix&gt;) &#123;
    diagnostics?.addDiagnostic(
        DiagnosticRegion(startIndex, endIndex, type, 0L,
            DiagnosticDetail(briefMessage, detailedMessage, list, null)
        )
    )
&#125;</code></pre></div><div class="tab-item-content" id="code_diagnostics_kotlin-2"><pre class="line-numbers language-java" data-language="java"><code class="language-java">editor.setDiagnostics(new DiagnosticsContainer());

setDiagnostic(36, 44, DiagnosticRegion.SEVERITY_ERROR, &quot;Error&quot;, &quot;Message&quot;, List.of(
    new Quickfix(&quot;Fix&quot;, 0L, null),
    new Quickfix(&quot;Other&quot;, 0L, null)
));

private void setDiagnostic(int startIndex, int endIndex, short type, String briefMessage, String detailedMessage, List&lt;Quickfix&gt; list) &#123;
    getDiagnostics().addDiagnostic(
        new DiagnosticRegion(startIndex, endIndex, type, 0L,
                new DiagnosticDetail(briefMessage, detailedMessage, list, null)
        )
    );
&#125;</code></pre>
<div class="note info simple"><p><code>QuickFix</code> 的點擊事件是 <code>Runnable</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">new Quickfix(&quot;Fix&quot;, 0L, new Runnable() &#123;
    @Override
    public void run() &#123;
        &#x2F;&#x2F; ...
    &#125;
&#125;)</code></pre></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>

<h2 id="Textmate-語法高亮模組庫"><a href="#Textmate-語法高亮模組庫" class="headerlink" title="Textmate 語法高亮模組庫"></a>Textmate 語法高亮模組庫</h2><div class="note info simple"><p>有關主題檔案及語法檔案可在<a href="https://github.com/BlueWhaleYT/TextMate-Resources">我的 Github 資源下載</a>。</p>
</div>

<p>假如配置如下：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">private val settings: TextmateSettings &#x3D; TextmateSettings(
    themesDirectory &#x3D; &quot;textmate&#x2F;themes&#x2F;&quot;,
    languageDirectory &#x3D; &quot;textmate&#x2F;languages&#x2F;&quot;,
    languageGrammarBaseFile &#x3D; &quot;textmate&#x2F;languages&#x2F;languages.json&quot;
)</code></pre>

<h3 id="載入可應用主題檔案"><a href="#載入可應用主題檔案" class="headerlink" title="載入可應用主題檔案"></a>載入可應用主題檔案</h3><div class="note danger simple"><p>如果一併把所有主題檔案都載入到 <code>ThemeRegistry</code>，可能會影響效能，較好的做法應該是有需要載入時才載入。</p>
</div>

<div class="tabs" id="textmate_load_themes"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="textmate_load_themes-1">載入單個主題檔案</button><button type="button" class="tab " data-href="textmate_load_themes-2">載入所有主題檔案</button></ul><div class="tab-contents"><div class="tab-item-content active" id="textmate_load_themes-1"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun loadTheme(
    filePath: String,
    charset: Charset? &#x3D; null
) &#123;
    fileProviderRegistry.addFileProvider(AssetsFileResolver(context.assets))
    themeRegistry.loadTheme(
        ThemeModel(
            IThemeSource.fromInputStream(
                fileProviderRegistry.tryGetInputStream(filePath), filePath, charset
            )
        )
    )
&#125;</code></pre></div><div class="tab-item-content" id="textmate_load_themes-2"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun loadThemes(
    filePaths: Array&lt;String&gt;,
    charset: Charset? &#x3D; null
) &#123;
    var i &#x3D; 0
    while (i &lt; filePaths.size) &#123;
        val filePath &#x3D; settings.themesDirectory + filePaths[i]
        loadTheme(filePath, charset)
        i++
    &#125;
&#125;</code></pre></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>

<h3 id="載入可應用語法檔案"><a href="#載入可應用語法檔案" class="headerlink" title="載入可應用語法檔案"></a>載入可應用語法檔案</h3><div class="tabs" id="textmate_load_languages"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="textmate_load_languages-1">載入語法分析庫修錄的語法</button><button type="button" class="tab " data-href="textmate_load_languages-2">以 DSL 載入多個語法</button></ul><div class="tab-contents"><div class="tab-item-content active" id="textmate_load_languages-1"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun loadLanguages() &#x3D; grammarRegistry.loadGrammars(settings.languageGrammarBaseFile)</code></pre></div><div class="tab-item-content" id="textmate_load_languages-2"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun loadLanguageWithDSL(languageDefinitionListBuilder: LanguageDefinitionListBuilder) &#x3D; grammarRegistry.loadGrammars(languageDefinitionListBuilder)

&#x2F;&#x2F; example
loadLanguageWithDSL(languages &#123;
    language(&quot;java&quot;) &#123;
        grammar &#x3D; &quot;$&#123;settings.languageDirectory&#125;&#x2F;java&#x2F;syntaxes&#x2F;java.tmLanguage.json&quot;
        defaultScopeName()
        languageConfiguration &#x3D; &quot;$&#123;settings.languageDirectory&#125;&#x2F;java&#x2F;language-configuration.json&quot;
    &#125;
    language(&quot;python&quot;) &#123;
        grammar &#x3D; &quot;$&#123;settings.languageDirectory&#125;&#x2F;python&#x2F;syntaxes&#x2F;python.tmLanguage.json&quot;
        defaultScopeName()
        languageConfiguration &#x3D; &quot;$&#123;settings.languageDirectory&#125;&#x2F;python&#x2F;language-configuration.json&quot;
    &#125;
&#125;)</code></pre></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>

<h3 id="應用已載入主題"><a href="#應用已載入主題" class="headerlink" title="應用已載入主題"></a>應用已載入主題</h3><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun applyTheme(filePath: String) &#x3D; themeRegistry.setTheme(settings.themesDirectory + filePath)</code></pre>

<h3 id="應用已載入語法"><a href="#應用已載入語法" class="headerlink" title="應用已載入語法"></a>應用已載入語法</h3><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun applyLanguage(filePath: String, source: String) &#123;
    ensureTextMateTheme()
    val language: TextMateLanguage
    val editorLanguage &#x3D; editor.editorLanguage

    if (editorLanguage is TextMateLanguage) &#123;
        language &#x3D; editorLanguage
        language.updateLanguage(source)
    &#125; else &#123;
        language &#x3D; TextMateLanguage.create(source, true)
    &#125;
    editor.setEditorLanguage(language)
&#125;</code></pre>

<div class="note info simple"><p>這裏的 <code>ensureTextMateTheme()</code> 純粹是用作確保這個調用 <code>applyLanguage()</code> 當前所用的主題配置是屬於 TextMate 主題的，因為 <strong><code>TextMateLanguage</code> 所實現的語法高亮只能與相應的 <code>TextMateColorScheme</code> 使用</strong>。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun ensureTextMateTheme() &#123;
    var editorColorScheme: EditorColorScheme? &#x3D; editor.colorScheme
    if (editorColorScheme !is TextMateColorScheme) &#123;
        editorColorScheme &#x3D; TextMateColorScheme.create(themeRegistry)
        editor.colorScheme &#x3D; editorColorScheme
    &#125;
&#125;</code></pre></div>

<p>用法如下：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val themeDark &#x3D; &quot;dark&#x2F;material-palenight.json&quot;
val themeLight &#x3D; &quot;light&#x2F;material-lighter.json&quot;
val themes &#x3D; arrayOf(themeDark, themeLight)
val theme &#x3D; if (isDarkMode) themeDark else themeLight

loadThemes(themes)
loadLanguages()
applyTheme(theme)
applyLanguage(theme, &quot;source.java&quot;)</code></pre>

<div class="note info simple"><p><code>source.java</code> 是一個 <code>scopeName</code> 的值，代表現在應用的是 Java 語法。</p>
<pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;
  &#x2F;&#x2F; ...
  &quot;version&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;atom&#x2F;language-java&#x2F;commit&#x2F;29f977dc42a7e2568b39bb6fb34c4ef108eb59b3&quot;,
  &quot;name&quot;: &quot;Java&quot;,
  &quot;scopeName&quot;: &quot;source.java&quot;,       &#x2F;&#x2F; 想要應用的程式語言，留意 scopeName 值
  &quot;patterns&quot;: [
    &#x2F;&#x2F; ...
  ]
&#125;</code></pre></div>

<hr>
<h1 id="Compose-使用方式"><a href="#Compose-使用方式" class="headerlink" title="Compose 使用方式"></a>Compose 使用方式</h1><p>sora-editor 目前暫時還沒支援 Compose 架構的可組合項函式，但是我們可以使用 <code>AndroidView</code> 把 <code>CodeEditor</code> 視圖嵌入至可組合函式內，有兩種方法：</p>
<ol>
<li>直接定義一個新的 <code>CodeEditor</code><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Composable
fun CodeEditor(
    modifier: Modifier &#x3D; Modifier,
    properties: ((CodeEditor) -&gt; Unit)? &#x3D; null
) &#123;
    val context &#x3D; LocalContext.current
    val editor &#x3D; remember &#123;
        CodeEditor(context)
            .also &#123;
                properties?.invoke(it)
            &#125;
    &#125;
    AndroidView(
        factory &#x3D; &#123; editor &#125;,
        modifier &#x3D; modifier.fillMaxSize(),
        onRelease &#x3D; &#123; it.release() &#125;
    )
&#125;</code></pre></li>
<li>如果你已經有一個編輯器的佈局，可以考慮用 <code>inflate</code> 方式<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Composable
fun CodeEditor(
    modifier: Modifier &#x3D; Modifier,
    properties: ((CodeEditor) -&gt; Unit)? &#x3D; null
) &#123;
    AndroidView(
        factory &#x3D; &#123; View.inflate(it, R.layout.layout_editor_view, null) &#125;
        modifier &#x3D; modifier.fillMaxSize()
    ) &#123; view -&gt;
        val editor &#x3D; view.findViewById&lt;CodeEditor&gt;(R.id.editor)
        properties?.invoke(editor)
    &#125;
&#125;</code></pre></li>
</ol>
]]></content>
      <categories>
        <category>實驗內容</category>
        <category>Android 開發</category>
        <category>Jetpack Compose</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 版本控制及操作 - JGit 筆記</title>
    <url>/post/dev-jgit-notes.html</url>
    <content><![CDATA[<p>在現代軟體開發中，版本控制是一個不可或缺的工具，它可以幫助我們追蹤和管理程式碼的變化。而 Git 是目前最受歡迎的版本控制系統之一。相信編寫員及開發者對它絕對不陌生，甚至耳熟能詳。</p>
<p>不過這裏最主要，並不是講解 Git 版本控制的操作，而是透過 Java 語言使用 JGit 函式庫進行版本控制的處理。</p>
<h1 id="開始前注意事項"><a href="#開始前注意事項" class="headerlink" title="開始前注意事項"></a>開始前注意事項</h1><ol>
<li>Kotlin 開發者亦可使用 <a href="https://github.com/sya-ri/KGit">KGit</a> 函式庫，該函式庫以 JGit 為基礎，但保留 Kotlin 語法的程式編寫方式</li>
<li>Android 開發在使用 JGit 時，需要注意以下幾點：</li>
</ol>
<ul>
<li>確保 <code>AndroidManifest.xml</code> 聲明權限許可，以及<strong>允許所有檔案權限</strong> (All File Access)，否則報錯 Operation Not Permitted<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;uses-permission android:name&#x3D;&quot;android.permission.READ_EXTERNAL_STORAGE&quot; &#x2F;&gt;
&lt;uses-permission android:name&#x3D;&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; &#x2F;&gt;
&lt;uses-permission android:name&#x3D;&quot;android.permission.MANAGE_EXTERNAL_STORAGE&quot; &#x2F;&gt;
&lt;uses-permission android:name&#x3D;&quot;android.permission.INTERNET&quot;&#x2F;&gt;
&lt;uses-permission android:name&#x3D;&quot;android.permission.ACCESS_NETWORK_STATE&quot; &#x2F;&gt;</code></pre></li>
<li>進行指令操作，如克隆遠端存儲庫至本機，需要使用<strong>異步執行緒或 <code>Executor</code> 等相關處理方式</strong>，(Kotlin 則可使用協程)，否則會在執行指令時報錯 <code>NetworkOnMainThreadException</code><pre class="line-numbers language-java" data-language="java"><code class="language-java">private final ExecutorService executor &#x3D; Executors.newSingleThreadExecutor();
private final Handler handler &#x3D; new Handler(Looper.getMainLooper());

executor.execute(() -&gt; &#123;
    &#x2F;&#x2F; ...
&#125;)</code></pre></li>
</ul>
<hr>
<h1 id="初始配置"><a href="#初始配置" class="headerlink" title="初始配置"></a>初始配置</h1><p>匯入依附元件至 <code>build.gradle</code></p>
<pre class="line-numbers language-gradle" data-language="gradle"><code class="language-gradle">implementation &#39;org.eclipse.jgit:org.eclipse.jgit:6.8.0.202311291450-r&#39;</code></pre>

<h2 id="產生本機存儲庫及-git-檔案"><a href="#產生本機存儲庫及-git-檔案" class="headerlink" title="產生本機存儲庫及 .git 檔案"></a>產生本機存儲庫及 <code>.git</code> 檔案</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;
    this.localRepo &#x3D; new FileRepository(localPath + &quot;&#x2F;.git&quot;);
&#125; catch (IOException e) &#123;
    e.printStackTrace();
&#125;

git &#x3D; new Git(localRepo);</code></pre>

<hr>
<h1 id="版本控制及操作"><a href="#版本控制及操作" class="headerlink" title="版本控制及操作"></a>版本控制及操作</h1><h2 id="克隆遠端存儲庫至本機"><a href="#克隆遠端存儲庫至本機" class="headerlink" title="克隆遠端存儲庫至本機"></a>克隆遠端存儲庫至本機</h2><div class="note warning simple"><p>要克隆的目錄或資料夾<strong>需要被建立及清空</strong>才能順利克隆遠端存儲庫，不清空則報 Directory XXX is not empty</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">File dir &#x3D; new File(localPath)
if (!dir.exists()) folder.mkdirs();</code></pre></div>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">Git.cloneRepository()
    .setURI(remotePath)
    .setDirectory(new File(localPath))
    .call();</code></pre>]]></content>
      <categories>
        <category>實驗內容</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetpack Compose | 多樣化的動畫實現方式</title>
    <url>/post/jetpack-compose-dev-animation-in-compose.html</url>
    <content><![CDATA[<p>Jetpack Compose 是一個新興的 UI 構建技術框架，除了著重於 UI 靜態方面的實現，都有支援到輕鬆使用動畫的一環。</p>
<p>這個是大家初嘗 Jetpack Compose 時，想必會看過這個官方圖：</p>
<p><img src="/post/jetpack-compose-dev-animation-in-compose/img1.gif" alt="official showcase gif"></p>
<p>你會看到，只要執行了 <code>Column</code> 的點擊事件，就可以有一個展開的動畫。這個只是其中一種動畫實現方式，接下來會說說更多其他不同處理動畫的方式。</p>
<p>官方有一個建議，判斷用哪一種方式最為適合：</p>
<ul>
<li>如果要在版面配置中為內容變更建立動畫效果：<ul>
<li>如果要建立顯示與消失的動畫效果：<ul>
<li>使用 <code>AnimatedVisibility</code>。</li>
</ul>
</li>
<li>根據狀態替換內容：<ul>
<li>如果要為內容建立淡出淡入效果：<ul>
<li>使用 <code>Crossfade</code>。</li>
</ul>
</li>
<li>否則，請使用 <code>AnimatedContent</code>。</li>
</ul>
</li>
<li>否則，請使用 <code>Modifier.animateContentSize</code>。</li>
</ul>
</li>
<li>如果要依據狀態顯示動畫：<ul>
<li>如果要在組合期間顯示動畫：<ul>
<li>如要讓動畫持續顯示：<ul>
<li>使用 <code>rememberInfiniteTransition</code>。</li>
</ul>
</li>
<li>如果您同時為多個值建立動畫效果：<ul>
<li>使用 <code>updateTransition</code>。</li>
</ul>
</li>
<li>否則，請使用 <code>animate*AsState</code>。</li>
</ul>
</li>
</ul>
</li>
<li>如果要精確控制動畫時間：<ul>
<li>使用 <code>Animation</code>，例如 <code>TargetBasedAnimation</code> 或 <code>DecayAnimation</code>。</li>
</ul>
</li>
<li>如果動畫是事實的唯一來源：<ul>
<li>使用 <code>Animatable</code>。</li>
</ul>
</li>
<li>否則，請使用 <code>AnimationState</code> 或 <code>animate</code>。</li>
</ul>
<hr>
<h1 id="高階動畫-API"><a href="#高階動畫-API" class="headerlink" title="高階動畫 API"></a>高階動畫 API</h1><p>配合質感設計的簡易高階動畫</p>
<h2 id="AnimatedVisibility"><a href="#AnimatedVisibility" class="headerlink" title="AnimatedVisibility"></a><code>AnimatedVisibility</code></h2><p>主要是以動畫方式呈現內容的顯示與消失。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">var visible by remember &#123; mutableStateOf(false) &#125;

Column &#123;
    AnimatedVisibility(visible &#x3D; visible) &#123;
        Text(text &#x3D; &quot;Hello World&quot;)
    &#125;
    Button(onClick &#x3D; &#123; visible &#x3D; !visible &#125;) &#123;
        Text(&quot;show text&quot;)
    &#125;
&#125;</code></pre>

<h2 id="AnimatedContent-實驗功能"><a href="#AnimatedContent-實驗功能" class="headerlink" title="AnimatedContent (實驗功能)"></a><code>AnimatedContent</code> (實驗功能)</h2><div class="note danger simple"><p>實驗性 API 未來可能會變更，或完全移除。</p>
</div>

<div class="note info simple"><p><code>AnimatedContent</code> 與 <code>AnimatedVisibility</code> 有點相似，前者控制切換，後者則控制顯隱。</p>
</div>

<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">var count by remember &#123; mutableIntStateOf(0) &#125;

Column &#123;
    AnimatedContent(targetState &#x3D; count) &#123; targetCount -&gt;
        Text(
            text &#x3D; &#123; Text(text &#x3D; targetCount) &#125;
        )
    &#125;
    Button(onClick &#x3D; &#123; count++ &#125; )
&#125;</code></pre>

<p><code>Text</code> 應用了隸屬於 <code>AnimatedContent</code> 的 <code>targetCount</code> 傳入參數，這個時候當內容更改時，就會有動畫的改變。</p>
<h2 id="animate-AsState"><a href="#animate-AsState" class="headerlink" title="animate*AsState"></a><code>animate*AsState</code></h2><p>可用於為單一值建立動畫效果。您只需提供結束值 (或目標值)，該 API 就會從現值開始播放動畫，直到達到指定值。</p>
<p>假如現在有一個小方塊 (預設的正常大小是 <code>70.dp</code>)，當按它就會長大一點，再按就長大多一點。</p>
<div class="note info simple"><p><code>animate*AsState</code> 這裏指的 <code>*</code> 是有許多不同的至別，如 <code>Dp</code>, <code>Int</code>, <code>Float</code>, <code>Color</code> 等。</p>
<p>因為現在是在用 <code>Dp</code> 值為狀態提升的基準，所以這裏會用的是 <code>animateDpAsState</code>，因此剛才所指的 <code>*</code> 是按情況而選擇用哪一個型別的。</p>
</div>

<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">var size by remember &#123; mutableStateOf(70.dp) &#125;
val animatedSize by animateDpAsState(                           &#x2F;&#x2F; 新增一個狀態動畫提升
    targetValue &#x3D; size,
    animationSpec &#x3D; tween(1000)                                 &#x2F;&#x2F; 動畫執行時間
)        

Box(
    modifier &#x3D; Modifier
        .background(MaterialTheme.colorScheme.primary)
        .size(animatedSize)                                     &#x2F;&#x2F; 使用狀態動畫提升值
        .clickable &#123; size *&#x3D; 2 &#125;
)</code></pre>

<div class="note warning simple"><p>使用 <code>animate*AsState</code> 的變量一定只能是 <code>val</code> 唯讀變量，意味著<strong>這個變量不會進行任何計算</strong>，只會用作最後顯示到目標位置。</p>
</div>

<table>
<thead>
<tr>
<th>沒有動畫</th>
<th>有動畫</th>
</tr>
</thead>
<tbody><tr>
<td><img alt="without animation" src="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExcXBlODFzcDZmNXZxM3kyaDN4a2dqdDNidzRmbWdjdTdtbXUyZmlnciZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/GZ4XaWk930NDcq2ljI/giphy.gif"></td>
<td><img alt="with animation" src="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExM3NoNGdieGN1dHN2engyZmZkZnFjbGwzbms2b3F4ZXpxZTFucWl6ayZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/Gx3PbwaTAnU8L2T90E/giphy.gif"></td>
</tr>
</tbody></table>
<div class="note warning simple"><p><img src="/post/jetpack-compose-dev-animation-in-compose/img2.png" alt="label parameter warning"></p>
<p>這裏 Android Studio 會警告你在使用 <code>animate*AsState</code> 或其他關於動畫範疇的情況下沒有用 <code>label</code> 參數，這個 <code>label</code> 參數純粹是在 IDE 的動畫製作時候，方便辨認的，如果不是特別重要，可選擇忽略。</p>
</div>]]></content>
      <categories>
        <category>實驗內容</category>
        <category>Jetpack Compose</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetpack Compose | 客製化主題實作筆記</title>
    <url>/post/jetpack-compose-dev-custom-theme-implementation-notes.html</url>
    <content><![CDATA[<p>在編寫 Jetpack Compose 程式時，常常會使用到質感設計 2 或質感設計 3 的設計框架，作為應用程式的基本設計風格。這是因為質感設計 2 和質感設計 3 提供了許多簡潔明瞭的組件，官方建議在構建 Jetpack Compose 程式時，盡量使用這些框架進行開發。</p>
<p>然而，一些知名的大型公司可能會選擇採用與質感設計不同的設計風格，來<strong>展現他們自家應用程式的獨特性</strong>。這也反映了應用程式的多樣性，避免出現與其他應用程式相似的情況。有些公司會<strong>在質感設計的框架基礎上進行改革</strong>，有些則會<strong>從頭開始自己撰寫設計框架</strong>。</p>
<p>不可否認的是，官方為 Jetpack Compose 所撰寫的質感設計主題都是使用他們自家開發的 API。因此，我們可以<strong>參考原始的質感設計實現程式碼，來撰寫自己的設計主題</strong>。這樣我們就可以擁有自己定制的設計風格了。</p>
<p>這裏有官方教學，不過是以質感設計 2 為基礎的，有興趣看可按此：<a href="https://developer.android.com/jetpack/compose/designsystems/custom?hl=zh-tw#implementing-fully-custom">官方教學文案</a>，這裏會著重於使用質感設計 3 的實作方式。</p>
<hr>
<table>
<thead>
<tr>
<th>明亮主題</th>
<th>黑暗主題</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/post/jetpack-compose-dev-custom-theme-implementation-notes/img1.png" alt="Showcase = Light mode"></td>
<td><img src="/post/jetpack-compose-dev-custom-theme-implementation-notes/img2.png" alt="Showcase = Dark mode"></td>
</tr>
</tbody></table>
<p>以上是製成品，這篇筆記會記下有關自訂主題的實現方式。</p>
<hr>
<h1 id="參照-MaterialTheme-程式碼"><a href="#參照-MaterialTheme-程式碼" class="headerlink" title="參照 MaterialTheme 程式碼"></a>參照 <code>MaterialTheme</code> 程式碼</h1><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">object MaterialTheme &#123;
    val colorScheme: ColorScheme
        @Composable
        @ReadOnlyComposable
        get() &#x3D; LocalColorScheme.current

    val typography: Typography
        @Composable
        @ReadOnlyComposable
        get() &#x3D; LocalTypography.current

    val shapes: Shapes
        @Composable
        @ReadOnlyComposable
        get() &#x3D; LocalShapes.current
&#125;</code></pre>

<p>預設的質感設計 3 提供了三個設計指標</p>
<ul>
<li><code>colorScheme</code>: 要應用的色彩配置</li>
<li><code>typography</code>: 要應用的字型及字體</li>
<li><code>shapes</code>: 要應用的形狀，如形狀的弧度</li>
</ul>
<p>然後你會發現。。。<strong>其實沒有內置像素密度、尺寸 (dimension)、間距 (spacing) 等常用指標</strong>，有見及此，我們可以自己參照原型，寫一個更好用的主題。</p>
<hr>
<h1 id="導入自訂主題"><a href="#導入自訂主題" class="headerlink" title="導入自訂主題"></a>導入自訂主題</h1><p>姑且命名新主題為 <strong>「BabyWhale」</strong>。</p>
<h2 id="多範疇指標建立"><a href="#多範疇指標建立" class="headerlink" title="多範疇指標建立"></a>多範疇指標建立</h2><h3 id="色彩調色指標"><a href="#色彩調色指標" class="headerlink" title="色彩調色指標"></a>色彩調色指標</h3><p>建立一個 <code>BabyWhaleColor.kt</code>，這個檔案是定義不同主題的顏色配置，例如是淺色和深色主題。</p>
<p>這裏是一個簡單的顏色色板，作用大概是</p>
<ul>
<li><code>Blue</code>: Primary 主色</li>
<li><code>Cyan</code>: Info 提示色</li>
<li><code>Green</code>: Success 成功色</li>
<li><code>Orange</code>: Warning 警告色</li>
<li><code>Red</code>: Error 錯誤&#x2F;危險色</li>
</ul>
<p><code>500</code> 是供淺色主題用的，而 <code>300</code> 則是深色主題。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val Blue_500 &#x3D; Color(0xFF3366FF)
val Blue_300 &#x3D; Color(0xFF84A9FF)

val Cyan_500 &#x3D; Color(0xFF3CC6FC)
val Cyan_300 &#x3D; Color(0xFF89EDFE)

val Green_500 &#x3D; Color(0xFF98E01D)
val Green_300 &#x3D; Color(0xFFCFF575)

val Orange_500 &#x3D; Color(0xFFFFAF3F)
val Orange_300 &#x3D; Color(0xFFFFD88B)

val Red_500 &#x3D; Color(0xFFFF4130)
val Red_300 &#x3D; Color(0xFFFFA182)

val White &#x3D; Color.White
val Black &#x3D; Color.Black</code></pre>

<div class="note info simple"><p>我是使用 <a href="https://colors.eva.design/">Eva Design System</a> 來生成以上的調色，為了較簡單，這裏只採用 <code>500</code> 和 <code>300</code> 色調碼，如果想要再完整的，基本上就是 <code>100</code> 至 <code>900</code> 全都使用。</p>
<p><img src="/post/jetpack-compose-dev-custom-theme-implementation-notes/img3.png" alt="Eva Design System"></p>
</div>

<p>寫一個數據類定義要用的顏色指標，然後把顏色向分予不同的主題模式。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Immutable
data class BabyWhaleColors(
    val primary: Color,
    val info: Color,
    val success: Color,
    val warning: Color,
    val error: Color,
    val background: Color,
    val onBackground: Color,
    val onPrimary: Color
)

val LightColorScheme &#x3D; BabyWhaleColors(
    primary &#x3D; Blue_500,
    info &#x3D; Cyan_500,
    success &#x3D; Green_500,
    warning &#x3D; Orange_500,
    error &#x3D; Red_500,
    background &#x3D; White,
    onBackground &#x3D; Black,
    onPrimary &#x3D; White
)

val DarkColorScheme &#x3D; BabyWhaleColors(
    primary &#x3D; Blue_300,
    info &#x3D; Cyan_300,
    success &#x3D; Green_300,
    warning &#x3D; Orange_300,
    error &#x3D; Red_300,
    background &#x3D; Black,
    onBackground &#x3D; White,
    onPrimary &#x3D; Black
)

val LocalBabyWhaleColors &#x3D; staticCompositionLocalOf &#123; LightColorScheme &#125;</code></pre>

<h3 id="字型指標"><a href="#字型指標" class="headerlink" title="字型指標"></a>字型指標</h3><p>建立一個 <code>BabyWhaleTypography.kt</code>，用來管理主題的應用字型</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Immutable
data class BabyWhaleTypography(
    val headline: TextStyle,
    val title: TextStyle,
    val subtitle: TextStyle,
    val body: TextStyle,
    val label: TextStyle
)

val babyWhaleTypography &#x3D; BabyWhaleTypography(
    headline &#x3D; TextStyle(
        fontSize &#x3D; 27.sp,
        fontFamily &#x3D; FontFamily.SansSerif,
        fontWeight &#x3D; FontWeight.Black,
    ),
    title &#x3D; TextStyle(
        fontSize &#x3D; 21.sp,
        fontFamily &#x3D; FontFamily.SansSerif,
        fontWeight &#x3D; FontWeight.Bold,
    ),
    subtitle &#x3D; TextStyle(
        fontSize &#x3D; 19.sp,
        fontFamily &#x3D; FontFamily.SansSerif,
        fontWeight &#x3D; FontWeight.Normal,
    ),
    body &#x3D; TextStyle(
        fontSize &#x3D; 18.sp,
        fontFamily &#x3D; FontFamily.SansSerif,
        fontWeight &#x3D; FontWeight.Normal,
    ),
    label &#x3D; TextStyle(
        fontSize &#x3D; 16.sp,
        fontFamily &#x3D; FontFamily.SansSerif,
        fontWeight &#x3D; FontWeight.Bold,
    ),
)

val LocalBabyWhaleTypography &#x3D; staticCompositionLocalOf &#123; babyWhaleTypography &#125;</code></pre>

<h3 id="形狀指標"><a href="#形狀指標" class="headerlink" title="形狀指標"></a>形狀指標</h3><p>建立一個 <code>BabyWhaleShape.kt</code></p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Immutable
data class BabyWhaleShape(
    val extraSmall: RoundedCornerShape &#x3D; RoundedCornerShape(4.dp),
    val small: RoundedCornerShape &#x3D; RoundedCornerShape(8.dp),
    val medium: RoundedCornerShape &#x3D; RoundedCornerShape(16.dp),
    val large: RoundedCornerShape &#x3D; RoundedCornerShape(24.dp),
    val extraLarge: RoundedCornerShape &#x3D; RoundedCornerShape(28.dp)
)

val LocalBabyWhaleShape &#x3D; staticCompositionLocalOf &#123; BabyWhaleShape() &#125;</code></pre>

<h3 id="自訂間距指標"><a href="#自訂間距指標" class="headerlink" title="自訂間距指標"></a>自訂間距指標</h3><p>新建 <code>BabyWhaleSpacing.kt</code></p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">data class BabyWhaleSpacing(
    val small: Dp &#x3D; 8.dp,
    val medium: Dp &#x3D; 16.dp,
    val large: Dp &#x3D; 24.dp
)

val LocalBabyWhaleSpacing &#x3D; staticCompositionLocalOf &#123; BabyWhaleSpacing() &#125;</code></pre>

<h2 id="套用指標至主題"><a href="#套用指標至主題" class="headerlink" title="套用指標至主題"></a>套用指標至主題</h2><p>把指標全都寫好後，就可以新建 <code>BabyWhaleTheme.kt</code> ，把主題相關的邏輯通通寫進去。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">object BabyWhaleTheme &#123;
    val colors: BabyWhaleColors
        @ReadOnlyComposable
        @Composable
        get() &#x3D; LocalBabyWhaleColors.current
    val typography: BabyWhaleTypography
        @ReadOnlyComposable
        @Composable
        get() &#x3D; LocalBabyWhaleTypography.current
    val shapes: BabyWhaleShape
        @ReadOnlyComposable
        @Composable
        get() &#x3D; LocalBabyWhaleShape.current
    val spacing: BabyWhaleSpacing
        @ReadOnlyComposable
        @Composable
        get() &#x3D; LocalBabyWhaleSpacing.current
&#125;</code></pre>

<p>然後寫 <code>BabyWhaleTheme()</code> 主要用的主題應用函數</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Composable
fun BabyWhaleTheme(
    isDarkMode: Boolean &#x3D; isSystemInDarkTheme(),
    typography: BabyWhaleTypography &#x3D; BabyWhaleTheme.typography,
    shapes: BabyWhaleShape &#x3D; BabyWhaleTheme.shapes,
    spacing: BabyWhaleSpacing &#x3D; BabyWhaleTheme.spacing,
    content: @Composable () -&gt; Unit
) &#123;
    val colorScheme &#x3D; if (isDarkMode) DarkColorScheme else LightColorScheme
    CompositionLocalProvider(
        LocalBabyWhaleColors provides colorScheme,
        LocalBabyWhaleTypography provides typography,
        LocalBabyWhaleShape provides shapes,
        LocalBabyWhaleSpacing provides spacing
    ) &#123;
        Box(
            modifier &#x3D; Modifier
                .background(colorScheme.background)
                .fillMaxSize()
        ) &#123;
            content()
        &#125;
    &#125;
&#125;</code></pre>

<details class="folding-tag"><summary> 主題函式庫提供方法 </summary>
              <div class="content">
              <p>如果你是想將主題封裝成依附元件，供不同項目使用，用法其實就像 <code>MaterialTheme</code> 一樣。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Composable
fun AppTheme(
    isDarkMode: Boolean &#x3D; isSystemInDarkTheme,
    content: @Composable () -&gt; Unit
) &#123;
    BabyWhaleTheme(
        isDarkMode &#x3D; isDarkMode,
        content &#x3D; content
    )
&#125;</code></pre>
              </div>
            </details>

<h2 id="自訂組件"><a href="#自訂組件" class="headerlink" title="自訂組件"></a>自訂組件</h2><p>因為 Jetpack Compose 內置提供的大部份組件都是使用質感設計為基礎的，所以如果你要寫一個與這個自訂主題相容的組件，就必須要自己另外再寫，這裏展示例如寫一個不同級別程度的按鈕</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">enum class BabyWhaleButtonType &#123;
    Primary, Info, Success, Warning, Error
&#125;

@Composable
internal fun getTypeColor(type: BabyWhaleButtonType) &#x3D; when (type) &#123;
    BabyWhaleButtonType.Primary -&gt; BabyWhaleTheme.colors.primary
    BabyWhaleButtonType.Info -&gt; BabyWhaleTheme.colors.info
    BabyWhaleButtonType.Success -&gt; BabyWhaleTheme.colors.success
    BabyWhaleButtonType.Warning -&gt; BabyWhaleTheme.colors.warning
    BabyWhaleButtonType.Error -&gt; BabyWhaleTheme.colors.error
&#125;

@Composable
fun BabyWhaleButton(
    modifier: Modifier &#x3D; Modifier,
    type: BabyWhaleButtonType &#x3D; BabyWhaleButtonType.Primary,
    onClick: () -&gt; Unit,
    content: @Composable () -&gt; Unit
) &#123;
    Button(
        modifier &#x3D; modifier,
        onClick &#x3D; onClick,
        colors &#x3D; ButtonDefaults.buttonColors(
            containerColor &#x3D; getTypeColor(type &#x3D; type),
            contentColor &#x3D; BabyWhaleTheme.colors.onPrimary
        )
    ) &#123;
        content()
    &#125;
&#125;</code></pre>

<p>用法：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">class MainActivity : ComponentActivity() &#123;
    override fun onCreate(savedInstanceState: Bundle?) &#123;
        super.onCreate(savedInstanceState)
        setContent &#123;
            BabyWhaleTheme &#123;
                Column &#123;
                    val types &#x3D; BabyWhaleButtonType.entries     &#x2F;&#x2F; 注意：需要 Kotlin 1.9.10 版本
                    types.forEach &#123;
                        BabyWhaleButton(
                            type &#x3D; it,
                            onClick &#x3D; &#123; &#x2F;*TODO*&#x2F; &#125;
                        ) &#123;
                            Text(text &#x3D; &quot;$&#123;it.name&#125; Button&quot;)
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<hr>
<h1 id="擴充質感主題"><a href="#擴充質感主題" class="headerlink" title="擴充質感主題"></a>擴充質感主題</h1><p>或許你對質感主題仍然情有獨鍾，只是對部分的顏色或其他的指標有點執着。甚至是想另外新增一個第 N 個副色，這裏可考慮用擴充形式，一來不會影響整個主題，二來實現到你的目的，無傷大雅。</p>
<h2 id="擴充屬性"><a href="#擴充屬性" class="headerlink" title="擴充屬性"></a>擴充屬性</h2><p>說好是擴充了，所以就真的是單純用擴展函式來對指標物件進行擴充。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">&#x2F;&#x2F; Use with MaterialTheme.colorScheme.snackbarAction
val ColorScheme.snackbarAction: Color
    get() &#x3D; if (isLight) Red300 else Red700

&#x2F;&#x2F; Use with MaterialTheme.typography.textFieldInput
val Typography.textFieldInput: TextStyle
    get() &#x3D; TextStyle(&#x2F;* ... *&#x2F;)

&#x2F;&#x2F; Use with MaterialTheme.shapes.card
val Shapes.card: Shape
    get() &#x3D; RoundedCornerShape(size &#x3D; 20.dp)</code></pre>

<h2 id="擴充質感主題-1"><a href="#擴充質感主題-1" class="headerlink" title="擴充質感主題"></a>擴充質感主題</h2><p>這個會用到 <code>CompositionLocalProvider</code> 把定義好的擴充顏色作為本機資料。再把這些顏色「包裝」到現有的 <code>MaterialTheme</code>。</p>
<p>假如現在質感設計 3 有 <code>error</code>, <code>onError</code>, <code>errorContainer</code>, <code>onErrorContainer</code>，你覺得不夠，你想看到「成功」，就可以寫一個數據類再加以把顏色定義。</p>
<p>預設會先用 <code>Color.Unspecified</code> (未下定義的顏色值)。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Immutable
data class ExtendedColorScheme(
    val success: Color,
    val onSuccess: Color,
    val successContainer: Color,
    val onSuccessContainer: Color
)

val LocalExtendedColorScheme &#x3D; staticCompositionLocalOf &#123;
    ExtendedColorScheme(
        success &#x3D; Color.Unspecified,
        onSuccess &#x3D; Color.Unspecified,
        successContainer &#x3D; Color.Unspecified,
        onSuccessContainer &#x3D; Color.Unspecified,
    )
&#125;</code></pre>

<p>然後像 <code>MaterialTheme</code> 一樣寫一個 <code>object</code> 和可組合函式，但不同的是，我們仍然會用到 <code>MaterialTheme</code>。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">object ExtendedTheme &#123;
    val colorScheme: ExtendedColorScheme
        @Composable
        get() &#x3D; LocalExtendedColorScheme.current
&#125;

@Composable
fun ExtendedTheme(
    &#x2F;* 這裏如常處理其他參數 *&#x2F;
    content: @Composable () -&gt; Unit
) &#123;
    &#x2F;&#x2F; 這裏的顏色值沒有進行特別測試
    val extendedColors &#x3D; ExtendedColorScheme(
        success &#x3D; Color(0xFF98e01d),
        onSuccess &#x3D; Color(0xFF366B05),
        successContainer &#x3D; Color(0xFF366B05),
        onSuccessContainer &#x3D; Color(0xFF7AC015),
    )
    CompositionLocalProvider(LocalExtendedColorScheme provides extendedColors) &#123;
        MaterialTheme(
            &#x2F;* 這裏如常處理其他參數 *&#x2F;
            content &#x3D; content
        )
    &#125;
&#125;</code></pre>]]></content>
      <categories>
        <category>學習筆記</category>
        <category>Jetpack Compose</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetpack Compose | 導航的基本應用</title>
    <url>/post/jetpack-compose-dev-navigation.html</url>
    <content><![CDATA[<p>在編寫 Jetpack Compose 程式的我們，不再像以前使用 XML 的傳統架構方式來設計程式的不同介面，而是透過編寫多個可組合函式來實現介面的設計。然而，這樣一來就帶出了一個問題，既然在 Compose 中不再使用 <code>Activity</code>，也不能使用 <code>Intent</code> 來切換介面了，那要怎麼做呢？</p>
<p>答案就是使用 Navigation。雖然 Navigation 在傳統的 XML 架構中也有使用，例如在 Fragment 中會用到 <code>NavController</code>，但在 Compose 中也存在並且非常有用。</p>
<p>Navigation 的作用是<strong>持續追蹤應用程式畫面的可組合項返回堆疊</strong>以及各個畫面的狀態。簡單來說，它就是用來切換不同頁面的工具。使用 Navigation 可以輕鬆地定義和管理應用程式的畫面流程，讓我們能夠更方便地控制和切換介面。</p>
<hr>
<h1 id="定義介面的路由"><a href="#定義介面的路由" class="headerlink" title="定義介面的路由"></a>定義介面的路由</h1><p>在開始使用之前，我們可以先定義一下介面路由，定義路由通常有兩種方法：</p>
<ol>
<li>使用 <code>enum class</code> 列舉類：<strong>適合不需要用上參數</strong>的路由，簡單明暸<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">enum class ScreenRoute &#123;
    Main, Second
&#125;</code></pre>
你亦可以用這個方式：<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">enum class ScreenRoute(
    val route: String
) &#123;
    Main(&quot;screen_main&quot;), Second(&quot;screen_second&quot;)
&#125;</code></pre></li>
<li>使用 <code>sealed class</code> 封裝類別：多元化管理不同路由的適用參數<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">sealed class Screen(
    val route: String
) &#123;
    data object MainScreen: Screen(&quot;screen_main&quot;)
    data object SecondScreen: Screen(&quot;screen_second&quot;)
&#125;</code></pre></li>
</ol>
<div class="note info simple"><p>建議用 <code>sealed class</code> 來定義介面路由，因為這樣可以<strong>更具彈性處理</strong>。</p>
</div>

<hr>
<h1 id="建立一個導航操作器"><a href="#建立一個導航操作器" class="headerlink" title="建立一個導航操作器"></a>建立一個導航操作器</h1><p>你可以先加入一個可組合函式，例如名為 <code>ScreenNavController()</code></p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Composable
fun ScreenNavController() &#123; ... &#125;</code></pre>

<p>修改程式起始的核心部分，如 <code>setContent &#123; ... &#125;</code> 內容內，或 <code>App()</code> 可組合函式，總知你就要把這個 <code>ScreenNavController()</code> 放在程式顯示的開端。</p>
<p>在這個 <code>ScreenNavController()</code> 定義一個 <code>NavHost()</code></p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Composable
fun ScreenNavController() &#123;
    val navController &#x3D; rememberNavController()
    NavHost(
        navController &#x3D; navController,
        startDestination &#x3D; Screen.MainScreen.route
    ) &#123;
        composable(route &#x3D; Screen.MainScreen.route) &#123;
            MainScreen(navController &#x3D; navController)
        &#125;
        composable(route &#x3D; Screen.SecondScreen.route) &#123;
            SecondScreen(navController &#x3D; navController)
        &#125;
    &#125;
&#125;</code></pre>

<div class="note warning simple"><p>建議如果這個介面函式 (<code>*Screen</code>) 是會被應用到 <code>NavHost</code>，請加上 <code>navController</code> 參數至可組合函式</p>
</div>

<p>當中：</p>
<ul>
<li><code>rememberNavController()</code>: 一個存取及提升導航的狀態</li>
<li><code>startDestination</code>: 宣告導航首個介面，通常就是 <code>MainScreen</code></li>
<li><code>composable()</code>: 為這個 <code>NavHost</code> 定義所用的介面路由，為相應的介面路由定義所用的可組合函式。</li>
</ul>
<hr>
<h1 id="切換介面的操作"><a href="#切換介面的操作" class="headerlink" title="切換介面的操作"></a>切換介面的操作</h1><h2 id="簡單・純粹切換介面"><a href="#簡單・純粹切換介面" class="headerlink" title="簡單・純粹切換介面"></a>簡單・純粹切換介面</h2><p>例如在 <code>MainScreen</code> 你有一個按鈕，當點擊這個按鈕，就會切換到 <code>SecondScreen</code> 介面。我們可以用 <code>navigate()</code> 函數導航到指定的路由</p>
<div class="note info simple"><p>如果你是使用 <code>enum class</code> 方式，導向路由的方法例如是 <code>route = ScreenRoute.Second.name</code>，要注意因為 <code>Second</code> 是一個列舉，要獲取為字串要附上 <code>name</code> 屬性，變成 <code>&quot;Second&quot;</code></p>
</div>

<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Composable
fun MainScreen(
    navController: NavController
) &#123;
    Column &#123;
        Text(text &#x3D; &quot;Main screen&quot;)
        Button(
            onClick &#x3D; &#123;
                navController.navigate(route &#x3D; Screen.SecondScreen.route)
            &#125;
        ) &#123;
            Text(text &#x3D; &quot;Navigate to Second screen&quot;)
        &#125;
    &#125;
&#125;</code></pre>

<p>如果想返回上一頁，例如在 <code>SecondScreen</code> 可組合函式有一個按鈕，點擊後返回到上一頁，可以用 <code>popBackStack()</code>。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Composable
fun SecondScreen(
    navController: NavController
) &#123;
    Column &#123;
        Text(text &#x3D; &quot;Second screen&quot;)
        Button(
            onClick &#x3D; &#123;
                navController.popBackStack()
            &#125;
        ) &#123;
            Text(text &#x3D; &quot;Back to Main screen&quot;)
        &#125;
    &#125;
&#125;</code></pre>

<h2 id="傳入參數的切換介面"><a href="#傳入參數的切換介面" class="headerlink" title="傳入參數的切換介面"></a>傳入參數的切換介面</h2><p>有時候可能你想在切換介面的同時，傳入參數，為接下來的介面得到資料變化，這個時候可以在 <code>composable()</code> 可組合函式定義 <code>arguments</code> 參數。</p>
<p>假如在 <code>MainScreen</code> 現在新增一個輸入框，用來輸入不同值作為參數，切換介面時得到不同的數值變化。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Composable
fun MainScreen(
    navController: NavController
) &#123;
    var value by remember &#123; mutableStateOf(&quot;&quot;) &#125;

    Column &#123;
        Text(text &#x3D; &quot;Main screen&quot;)

        TextField(
            value &#x3D; value,
            onValueChange &#x3D; &#123; value &#x3D; it &#125;
        )

        Button(
            onClick &#x3D; &#123;
                navController.navigate(route &#x3D; Screen.SecondScreen.route)
            &#125;
        ) &#123;
            Text(text &#x3D; &quot;Navigate to Second screen&quot;)
        &#125;
    &#125;
&#125;</code></pre>

<p>然後當切換到 <code>SecondScreen</code> 介面時，顯示路由所得的參數項，這裏會先給可組合函式多定義 <code>name</code> 參數，這個 <code>Text</code> 是用來顯示參數所傳的值。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Composable
fun SecondScreen(
    navController: NavController,
    name: String?
) &#123;
    Column &#123;
        Text(text &#x3D; &quot;Second screen, hello $name&quot;)
        Button(
            onClick &#x3D; &#123;
                navController.popBackStack()
            &#125;
        ) &#123;
            Text(text &#x3D; &quot;Back to Main screen&quot;)
        &#125;
    &#125;
&#125;</code></pre>

<p>在負責 <code>SecondScreen</code> 的 <code>composable()</code> 需要設置 <code>arguments</code>，假定現在這個參數值的類型是 <code>String</code>，而參數名跟 <code>SecondScreen</code> 的參數一樣都是 <code>name</code>。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">composable(
    route &#x3D; Screen.SecondScreen.route + &quot;&#x2F;&#123;name&#125;&quot;,
    arguments &#x3D; listOf(
        navArgument(&quot;name&quot;) &#123;
            type &#x3D; NavType.StringType
            defaultValue &#x3D; &quot;&quot;
            nullable &#x3D; true
        &#125;
    )
) &#123; entry -&gt;
    SecondScreen(
        navController &#x3D; navController,
        name &#x3D; entry.arguments?.getString(&quot;name&quot;)
    )
&#125;</code></pre>

<p>要注意的是 <code>route</code> 因為要傳入參數 <code>name</code>，所以要像一般 URL 或 URI 掛上參數項，<strong>要用一對 <code>&#123;&#125;</code> 把參數括住</strong>。</p>
<p>可以在 <code>Screen.kt</code> 寫一個新的函數 <code>withArgs()</code></p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun withArgs(vararg args: String) &#x3D; buildString &#123;
    append(route)
    args.forEach &#123; append(&quot;&#x2F;$it&quot;) &#125;
&#125;</code></pre>

<p>最後，在 <code>MainScreen</code> 剛才所寫的 <code>value</code> 輸入狀態中傳入為參數</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">&#x2F;&#x2F; var value by remember &#123; mutableStateOf(&quot;&quot;) &#125;
onClick &#x3D; &#123;
    navController.navigate(route &#x3D; Screen.SecondScreen.withArgs(value))
&#125;</code></pre>

<hr>
<h1 id="切換介面的過渡動畫"><a href="#切換介面的過渡動畫" class="headerlink" title="切換介面的過渡動畫"></a>切換介面的過渡動畫</h1><p>以前需要用上 Accompanist 的 <code>AnimatedHost</code>，但現在 Navigation API 更新了，<code>NavHost</code> 支援切換介面的動畫了，而且預設已經設定了淡入淡出動畫：</p>
<div class="note danger simple"><p>目前 <code>NavHost</code> 的過渡動畫特性 API 尚未穩定。</p>
</div>

<p><img src="/post/jetpack-compose-dev-navigation/img1.png" alt="NavHost default animation"></p>
<p>可見設置自訂的過渡動畫需要理解 4 個參數：</p>
<ul>
<li><code>enterTransition</code>：進入目的地時的過渡效果，可以設置目的地進入畫面的動畫效果。</li>
<li><code>exitTransition</code>：離開目的地時的過渡效果，可以設置目的地離開畫面的動畫效果。</li>
<li><code>popEnterTransition</code>：返回上一個目的地時的過渡效果，可以設置返回時目的地進入畫面的動畫效果。</li>
<li><code>popExitTransition</code>：返回上一個目的地時的過渡效果，可以設置返回時目的地離開畫面的動畫效果。</li>
</ul>
<p>例子如下：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">enterTransition &#x3D; &#123;
    slideIntoContainer(
        towards &#x3D; AnimatedContentTransitionScope.SlideDirection.Companion.Left,
        animationSpec &#x3D; tween(700)
    )
&#125;,
exitTransition &#x3D; &#123;
    slideOutOfContainer(
        towards &#x3D; AnimatedContentTransitionScope.SlideDirection.Companion.Left,
        animationSpec &#x3D; tween(700)
    )
&#125;,
popEnterTransition &#x3D; &#123;
    slideIntoContainer(
        towards &#x3D; AnimatedContentTransitionScope.SlideDirection.Companion.Right,
        animationSpec &#x3D; tween(700)
    )
&#125;,
popExitTransition &#x3D; &#123;
    slideOutOfContainer(
        towards &#x3D; AnimatedContentTransitionScope.SlideDirection.Companion.Right,
        animationSpec &#x3D; tween(700)
    )
&#125;</code></pre>]]></content>
      <categories>
        <category>實驗內容</category>
        <category>學習筆記</category>
        <category>Jetpack Compose</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetpack Compose | 有效管理 UI 介面的狀態</title>
    <url>/post/jetpack-compose-ui-state-sealed-class-notes.html</url>
    <content><![CDATA[<p>在 Jetpack Compose 中，官方強調的是狀態管理的重要性。一般情況下，我們使用 ViewModel 將商業邏輯放在其中，以減少組合函式中的邏輯程式碼，從而提供更好的使用者體驗。</p>
<p>然而，有時我們需要處理一些進階的管理程式，例如 API 請求、檔案讀取等，這時候可能會用到以下三個基本狀態：</p>
<ul>
<li><code>Loading</code>（載入中）：表示資料正在載入的過程中，可以顯示一個載入中的動畫或提示訊息。</li>
<li><code>Success</code>（成功）：表示資料載入成功，可以將資料顯示在介面上或執行相應的操作。</li>
<li><code>Error</code>（錯誤）：表示資料載入過程中發生錯誤，可以顯示錯誤訊息或提供用戶重新嘗試的選項。</li>
</ul>
<p>這三個狀態可以<strong>幫助我們更好地管理資料載入的過程</strong>，並提供更好的使用者反饋。在實作中，我們可以使用<strong>相應的狀態來更新介面</strong>，以反映當前的狀態。</p>
<p>接下來會以一個檔案文本編輯器作範例</p>
<hr>
<h1 id="定義封裝類狀態"><a href="#定義封裝類狀態" class="headerlink" title="定義封裝類狀態"></a>定義封裝類狀態</h1><div class="note warning simple"><p><code>UIState</code> 封裝類會因應程式的目的而有所不同，現在這個範例是檔案文本編輯器，所以稱作 <code>EditorUIState</code></p>
</div>

<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">sealed class EditorUIState &#123;
    data object Loading : EditorUIState()
    data class Error(val message: String? &#x3D; null) : EditorUIState()
    data class Success(val file: File? &#x3D; null) : EditorUIState()
&#125;</code></pre>

<p>在這個 <code>EditorUIState</code>，其中 <code>Error</code> 及 <code>Success</code> 需要傳入參數，<code>Error</code> 是用來顯示錯誤訊息，而 <code>Success</code> 是只有傳入參數的物件是有效，才會執行，在這個範例中，唯獨只有 <code>Success</code> 這個狀態需要獲取要用的資料。</p>
<h2 id="不同狀態應用的介面"><a href="#不同狀態應用的介面" class="headerlink" title="不同狀態應用的介面"></a>不同狀態應用的介面</h2><p>在這個範例中，我們的 <code>Loading</code>, <code>Success</code> 及 <code>Error</code> 狀態會分別以以下方式顯示：</p>
<ul>
<li><code>Loading</code>: 會顯示一個載入對話框，當載入完成，對話框便會自動關閉</li>
<li><code>Error</code>: 把錯誤訊息顯示在 <code>Scaffold</code> 內的 <code>Snackbar</code>，當發生錯誤，<code>Snackbar</code> 便會彈出，同時會附加一個重試按鈕，重新再獲取資料</li>
<li><code>Success</code>: 成功獲取資料的內容就會在 <code>Scaffold</code> 的主佈局呈現</li>
</ul>
<hr>
<h1 id="編寫-ViewModel"><a href="#編寫-ViewModel" class="headerlink" title="編寫 ViewModel"></a>編寫 ViewModel</h1><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">class EditorViewModel : ViewModel()</code></pre>

<p>在這個範例中，需要定義三個狀態，狀態分別需要可變及不可變型態。</p>
<div class="note info simple"><p>定義可變狀態時，一般我們在 ViewModel 定義可變 (mutable) 狀態都會在變量名稱加上 <code>_</code> 前綴，而定義不可變狀態會宣告 <code>State</code> 型別，即不可變狀態作賦值。</p>
</div>

<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">private val _file &#x3D; mutableStateOf(File(&quot;&quot;)) &#x2F;&#x2F; 無效檔案範例
val file: State&lt;File&gt; &#x3D; _file

private val _uiState &#x3D; MutableStateFlow&lt;EditorUIState&gt;(EditorUIState.Loading)
val uiState &#x3D; _uiState.asStateFlow()

private val _editorText &#x3D; mutableStateOf(_file.value.getFileContent())
val editorText: State&lt;String&gt; &#x3D; _editorText

val snackbarHostState &#x3D; SnackbarHostState()</code></pre>

<p>正常情況下，都會以 <code>Loading</code> 狀態為初始 UI 狀態，<code>Success</code> 或 <code>Error</code> 狀態是待 <code>Loading</code> 完成才判斷的。</p>
<h2 id="初始化狀態程序"><a href="#初始化狀態程序" class="headerlink" title="初始化狀態程序"></a>初始化狀態程序</h2><div class="note info simple"><p>因為我們想確保 ViewModel 能夠順利被載入及執行，所以加上了 2 秒延遲 (<code>delay(2000L)</code>)。</p>
</div>

<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">init &#123;
    init()
&#125;

private fun init() &#123;
    viewModelScope.launch &#123;
        delay(2000L)

        _uiState.value &#x3D; if (_file.value.exists()) &#123;
            EditorUIState.Success(file &#x3D; _file.value)
        &#125; else &#123;
            EditorUIState.Error(message &#x3D; &quot;Invalid file&quot;)
        &#125;
    &#125;
&#125;</code></pre>

<p>在這個範例中，我們判斷如果所獲取的檔案是存在的，則視為成功，否則視為錯誤。</p>
<h2 id="顯示錯誤訊息的-Snackbar"><a href="#顯示錯誤訊息的-Snackbar" class="headerlink" title="顯示錯誤訊息的 Snackbar"></a>顯示錯誤訊息的 <code>Snackbar</code></h2><p>剛才都說過，當發生錯誤，就會彈出 <code>Snackbar</code> 訊息</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun showErrorSnackbar(message: String) &#123;
    viewModelScope.launch &#123;
        snackbarHostState.showSnackbar(message)
    &#125;
&#125;</code></pre>

<p>而且有一個重試按鈕的點擊事件，重新再獲取資料，其實就是把狀態歸零，再初始化一遍。</p>
<div class="note info simple"><p>這裏的歸零是重置為 <code>Loading</code> 狀態。</p>
</div>

<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun refresh() &#123;
    _uiState.value &#x3D; EditorUIState.Loading
    init()
&#125;</code></pre>

<h1 id="編寫不同狀態的介面"><a href="#編寫不同狀態的介面" class="headerlink" title="編寫不同狀態的介面"></a>編寫不同狀態的介面</h1><p><code>Success</code> 的含義本來就是當資料獲取成功後就會導向該介面，意昧着你只要把主要的介面內容寫進 <code>Success</code> 介面便可，因為理論上<strong>用戶提供的檔案路徑均屬有效。只要檔案有效才可以繼續使用編輯器</strong>。</p>
<p>在這個範例中，<code>Loading</code> 及 <code>Error</code> 分別使用了對話框及 Snackbar 形式，其實這個可以很自由，你喜歡的話都可以都以介面形式處理：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">when (state) &#123;
    is EditorUIState.Loading -&gt; LoadingScreen()
    is EditorUIState.Error -&gt; ErrorScreen()
    is EditorUIState.Success -&gt; ReadyScreen()
&#125;</code></pre>

<div class="note warning simple"><p>記得 <code>state</code> 參數要設置 <code>collectAsState()</code>，否則只會一直處於 <code>Loading</code> 狀態，一直顯示載入對話框。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Composable
fun EditorScreen(
    viewModel: EditorViewModel &#x3D; viewModel(),
    navController: NavController
) &#123;
    Content(
        state &#x3D; viewModel.uiState.collectAsState().value
    )
&#125;</code></pre></div>

<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Composable
fun Content(
    viewModel: EditorViewModel &#x3D; viewModel(),
    state: EditorUIState,
) &#123;
    val scope &#x3D; rememberCoroutineScope()

    Container(
        onRetry &#x3D; &#123;
            viewModel.refresh()
        &#125;
    ) &#123;
        when (state) &#123;
            is EditorUIState.Loading -&gt; &#123;
                LoadingDialog()
            &#125;
            is EditorUIState.Error -&gt; &#123;
                scope.launch &#123;
                    viewModel.showErrorSnackbar(state.message ?: &quot;Unexpected Error&quot;)
                &#125;
            &#125;
            is EditorUIState.Success -&gt; &#123;
                Text(text &#x3D; state.file?.path.toString())
                TextField(
                    value &#x3D; viewModel.editorText.value,
                    onValueChange &#x3D; &#123; viewModel.editorText.value &#x3D; it &#125;
                )
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<div class="tabs" id="container_loadingdialog"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="container_loadingdialog-1">Container</button><button type="button" class="tab " data-href="container_loadingdialog-2">LoadingDialog</button></ul><div class="tab-contents"><div class="tab-item-content active" id="container_loadingdialog-1"><p><code>Container</code> 可組合函式主要是用來封裝整個 <code>Scaffold</code>，連同顯示錯誤訊息的 Snackbar。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Composable
fun Container(
    viewModel: EditorViewModel &#x3D; viewModel(),
    onRetry: () -&gt; Unit,
    content: @Composable () -&gt; Unit
) &#123;
    Scaffold(
        snackbarHost &#x3D; &#123;
            SnackbarHost(
                hostState &#x3D; viewModel.snackbarHostState,
                snackbar &#x3D; &#123; data -&gt;
                    Snackbar(
                        modifier &#x3D; Modifier.padding(16.dp),
                        action &#x3D; &#123;
                            TextButton(
                                onClick &#x3D; onRetry,
                                colors &#x3D; ButtonDefaults.textButtonColors(
                                    contentColor &#x3D; SnackbarDefaults.actionColor
                                )
                            ) &#123;
                                Text(text &#x3D; &quot;Retry&quot;)
                            &#125;
                        &#125;
                    ) &#123;
                        Text(text &#x3D; data.visuals.message)
                    &#125;
                &#125;
            )
        &#125;
    ) &#123;
        Column(
            modifier &#x3D; Modifier.padding(it)
        ) &#123;
            content()
        &#125;
    &#125;
&#125;</code></pre></div><div class="tab-item-content" id="container_loadingdialog-2"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Composable
fun LoadingDialog() &#123;
    Dialog(
        onDismissRequest &#x3D; &#123;&#125;
    ) &#123;
        Box(
            modifier &#x3D; Modifier
                .width(100.dp)
                .height(100.dp)
                .clip(MaterialTheme.shapes.extraLarge)
                .background(MaterialTheme.colorScheme.surfaceContainer),
            contentAlignment &#x3D; Alignment.Center
        ) &#123;
            CircularProgressIndicator()
        &#125;
    &#125;
&#125;</code></pre></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>

<hr>
<h1 id="實驗及預覽所有狀態介面"><a href="#實驗及預覽所有狀態介面" class="headerlink" title="實驗及預覽所有狀態介面"></a>實驗及預覽所有狀態介面</h1><p>在這個範例中，如果要實驗一個成功導向 <code>Success</code> 狀態的介面，就需要提供一個有效的檔案路徑：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">private val _file &#x3D; mutableStateOf(File(&quot;&#x2F;storage&#x2F;emulated&#x2F;0&#x2F;BlueWhaleYT&#x2F;Hello.js&quot;)) &#x2F;&#x2F; 有效檔案範例
val file: State&lt;File&gt; &#x3D; _file</code></pre>

<p>如果要實驗導向 <code>Error</code> 狀態介面，則可以提供無效檔案：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">private val _file &#x3D; mutableStateOf(File(&quot;&quot;)) &#x2F;&#x2F; 無效檔案範例
val file: State&lt;File&gt; &#x3D; _file</code></pre>

<p>不過有時候，你可能會想借助 Compose Preview 功能來預覽不同狀態的介面，我們可以寫一個繼承 <code>PreviewParameterProvider</code> 介面，例如：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">internal class EditorUIStateProvider : PreviewParameterProvider&lt;EditorUIState&gt; &#123;
    override val values: Sequence&lt;EditorUIState&gt; &#x3D; sequenceOf(
        EditorUIState.Loading,
        EditorUIState.Success(),
        EditorUIState.Error()
    )
&#125;</code></pre>

<p>然後在你的預覽可組合函式中：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Preview(showSystemUi &#x3D; true)
@Composable
fun EditorScreenPreview(
    @PreviewParameter(EditorUIStateProvider::class) state: EditorUIState
) &#123;
    MyAppTheme &#123;
        Content(state &#x3D; state)
    &#125;
&#125;</code></pre>]]></content>
      <categories>
        <category>實驗內容</category>
        <category>學習筆記</category>
        <category>Jetpack Compose</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
</search>
