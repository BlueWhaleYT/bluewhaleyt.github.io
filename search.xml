<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【Android】應用程式崩潰及除錯介面</title>
    <url>/post/android-crash-debug-error-screen.html</url>
    <content><![CDATA[<p>應用程式不是完美的，很多時候會因為<strong>各種原因導致應用程式出現錯誤及崩潰</strong>，而<strong>崩潰是嚴重影響用戶體驗</strong>，因為一旦應用程式崩潰，就是<strong>強制關閉應用程式</strong>，使用戶不知所措。有見及此，一個較為用戶友善性的應用程式，都會實現一個崩潰除錯介面，讓用戶能夠知悉，應用程式崩潰是因為程式錯誤而導致的。</p>
<h1 id="建立崩潰及除錯處理器"><a href="#建立崩潰及除錯處理器" class="headerlink" title="建立崩潰及除錯處理器"></a>建立崩潰及除錯處理器</h1><p><span class="step" data-step="1" data-title="CrashHandler 初始程序"></span></p>
<p>我們需要建立一個崩潰及除錯處理器，目的是<strong>捕捉整個應用程式所發生的所有錯誤及異常</strong>，我們會繼承 <code>Thread.UncaughtExceptionHandler</code> 介面來捕捉全域異常。另外，這個 <code>CrashHandler</code> 需要接受一個 <code>Context</code> 參數，因為處理捕捉異常需要使用 <code>Context</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CrashHandler</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> context: Context</span><br><span class="line">) : Thread.UncaughtExceptionHandler &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">uncaughtException</span><span class="params">(thread: <span class="type">Thread</span>, throwable: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 其他程式碼..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span class="step" data-step="2" data-title="宣告 StringBuilder"></span></p>
<p>我們需要宣告一個 <code>StringBuilder</code>，把字串組成到 <code>StringBuilder</code> 使用。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> strBuilder: StringBuilder = StringBuilder()</span><br></pre></td></tr></table></figure>

<h2 id="獲取堆疊追蹤"><a href="#獲取堆疊追蹤" class="headerlink" title="獲取堆疊追蹤"></a>獲取堆疊追蹤</h2><p>我們可以透過 <code>printStackTrace()</code> 把堆疊追蹤結果打印至 <code>StringWriter</code>，從而能夠獲取堆疊追蹤。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> stacktrace = StringWriter()</span><br><span class="line">throwable.printStackTrace(PrintWriter(stacktrace))</span><br><span class="line">strBuilder.append(stacktrace)</span><br></pre></td></tr></table></figure>

<h2 id="獲取當前時間"><a href="#獲取當前時間" class="headerlink" title="獲取當前時間"></a>獲取當前時間</h2><p>基本上，在這一刻報錯，就是使用當前時間，亦能作為報錯時間，我們可以使用 <code>Calendar</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> time = Calendar.getInstance().getTime()</span><br></pre></td></tr></table></figure>

<p><span class="step" data-step="3" data-title="開啟偵錯活動畫面並傳出偵錯資料"></span></p>
<p>當應用程式出現異常，就會自動開啟到偵錯活動畫面 <code>DebugActivity</code>，並使用 <code>Intent</code> 把偵錯資料分享出去，供 <code>DebugActivity</code> 使用。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(context, DebugActivity::<span class="keyword">class</span>.java);</span><br><span class="line">intent.putExtra(<span class="string">&quot;stacktrace&quot;</span>, strBuilder.toString())</span><br><span class="line">context.startActivity(intent)</span><br><span class="line"></span><br><span class="line">Process.killProcess(Process.myPid());</span><br><span class="line">exitProcess(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p><span class="step" data-step="4" data-title="從 DebugActivity 獲取並顯示偵錯資料"></span></p>
<p>剛才我們在 <code>CrashHandler</code> 使用 <code>Intent</code> 的 <code>putExtra()</code> 把堆疊追蹤結果傳出去，現在可以使用 <code>getIntent().getStringExtra()</code> 獲取所傳出的堆疊追蹤。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">binding.tvStacktrace = intent.getStringExtra(<span class="string">&quot;stacktrace&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><span class="step" data-step="5" data-title="在 MainActivity 設置崩潰及除錯監聽"></span></p>
<p>你需要在 <code>onCreate()</code> 方法中，在 <code>setContentView()</code> 之前，設置崩潰及除錯監聽。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Thread.setDefaultUncaughtExceptionHandler(CrashHandler(<span class="keyword">this</span>))</span><br></pre></td></tr></table></figure>

<p>然後，當要測試偵錯畫面，例如直接編寫一個拋出異常的程式碼：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Test crash exception&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>該異常便會在應用程式打開時出現，並自動前往 <code>DebugActivity</code> 顯示其堆疊追蹤。</p>
<hr>
<h1 id="複製報錯訊息"><a href="#複製報錯訊息" class="headerlink" title="複製報錯訊息"></a>複製報錯訊息</h1><p>有時候，<strong>一般的用戶</strong>只是負責使用應用程式的，並<strong>不理解程式碼及除錯訊息</strong>，但他們可以做的是，就是把<strong>這些訊息複製並貼上到回饋的地方</strong>，讓<strong>開發者能夠知道應用程式崩潰的原因</strong>，以及對應的解決方案。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.ClipboardManager</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> clipboard = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE)</span><br><span class="line"><span class="keyword">val</span> clip = ClipData.newPlainText(</span><br><span class="line">    <span class="string">&quot;Debug Messages&quot;</span>,       <span class="comment">// 設置剪貼簿的描述</span></span><br><span class="line">    strBuilder.toString()   <span class="comment">// 設置剪貼簿的內容</span></span><br><span class="line">)</span><br><span class="line">clipboard.setPrimaryClip(clip)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>【Android】Firebase 專案初建及配置</title>
    <url>/post/android-firebase-setup-notes.html</url>
    <content><![CDATA[<p>Firebase 是一個由 Google 提供的<strong>綜合性後端開發平台</strong>，它提供一系列的雲端服務及工具，幫助開發者快速構建高品質的應用程式，是一個相當舉足輕重的必要工具之一。</p>
<p>Firebase 提供的服務繁多：</p>
<ul>
<li>身份驗證 (Authentication)：Firebase Authentication 是一個用於用戶身份驗證的服務。它提供了一個簡單且安全的方式，讓開發者可以<strong>輕鬆地管理用戶的註冊、登錄和密碼重置</strong>等功能。Firebase Authentication 支持多種身份驗證方式，包括電子郵件&#x2F;密碼、第三方登錄等。<div calss="anzhiyu-tag-link"><a class="tag-Link" target="_blank" href="/post/jetpack-compose-firebase-auth-notes">
    <div class="tag-link-tips">引用站外地址</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style>
          <i class="anzhiyufont anzhiyu-icon-link" style></i>
        </div>
        <div class="tag-link-right">
            <div class="tag-link-title">身份驗證</div>
            <div class="tag-link-sitename"> 看文章瞭解如何使用 Firebase 進行身份驗證</div>
        </div>
        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>
    </div>
    </a></div></li>
<li>即時資料庫 (Realtime Database)：Firebase Realtime Database 是一個 NoSQL 的<strong>非關聯式資料的雲端數據庫</strong>，它提供了一個實時同步的方式來存儲和同步應用中的數據。開發者可以使用 Firebase Realtime Database 來創建基於事件驅動的應用程序，並實現實時的數據更新。它支持離線緩存，可以在斷網環境下繼續工作，並在網絡連接恢復時自動同步數據。</li>
<li>雲端存儲庫 (Cloud Firestore)：Firebase Cloud Firestore 是一個靈活且可擴展的 NoSQL 文件數據庫，亦是一個 Firebase Realtime Database 的繼代工具。它提供了一個可靠的方式來存儲和同步大規模的結構化數據。Cloud Firestore 支持實時更新，可以在多個平台上保持數據的同步。它還提供了<strong>強大的查詢功能，可以輕鬆地檢索和過濾數據</strong>。<div calss="anzhiyu-tag-link"><a class="tag-Link" target="_blank" href="/post/jetpack-compose-firebase-realtime-database-and-cloud-firestore-notes">
    <div class="tag-link-tips">引用站外地址</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style>
          <i class="anzhiyufont anzhiyu-icon-link" style></i>
        </div>
        <div class="tag-link-right">
            <div class="tag-link-title">即時資料庫及雲端存儲庫</div>
            <div class="tag-link-sitename"> 看文章瞭解如何使用 Realtime Database 及 Cloud Firestore</div>
        </div>
        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>
    </div>
    </a></div></li>
<li>資料分析 (Analytics)：Firebase Analytics 是一個用於應用程式分析的工具。它<strong>可以收集用戶互動和行為數據，並提供有關應用的洞察和指標</strong>。開發者可以使用 Firebase Analytics 來了解用戶的使用情況、用戶行為和應用性能等。它還提供了自定義事件和用戶屬性，以便開發者更好地了解和分析用戶行為。</li>
<li>推播通知 (Cloud Messaging)：Firebase Cloud Messaging (FCM) 是一個強大的推送通知服務。它可以將消息推送到 Android、iOS 和 Web 應用中的用戶。開發者可以使用 FCM 來<strong>向用戶發送即時通知、提醒和促銷訊息</strong>。FCM 還提供了<strong>高度可靠的消息傳遞和自定義的目標設定功能</strong>，可以根據用戶的屬性和行為來定向推送消息。</li>
</ul>
<p>我們瞭解到 Firebase 的強大之處，但有利就必有弊。它雖然具有許多優點，但也有一些潛在的壞處需要考慮：</p>
<div class="table-procons">

<table>
<thead>
<tr>
<th>優點</th>
<th>缺點</th>
</tr>
</thead>
<tbody><tr>
<td>快速開發：Firebase 提供了一個完整的後端解決方案，開發者可以輕鬆地使用它的功能來快速構建應用程序。<strong>不需要自己從頭開始構建和維護後端服務</strong>，可以<strong>節省大量的開發時間和成本。</strong></td>
<td>依賴性：使用 Firebase 意味著開發者將自己的應用程序納入 Google 的生態系統中。這可能使開發者對 Google 的服務和工具產生依賴性，<strong>如果 Firebase 服務發生故障或變更，可能會對應用程序造成影響。</strong></td>
</tr>
<tr>
<td>跨平台支持：Firebase 不僅支持 Android 平台，還支持其他平台，如 iOS、Web 和 Unity 等。這使得開發者可以<strong>使用相同的後端服務和工具來開發多個平台</strong>的應用程序，提高了開發效率。</td>
<td>成本問題：雖然 Firebase 有一個免費的層級，<strong>但某些高級功能和使用量可能需要付費</strong>。如果應用程序的需求超出了免費層級的限制，可能需要支付額外的費用。開發者需要仔細評估他們的預算和需求，以確定是否適合使用 Firebase。</td>
</tr>
<tr>
<td>強大的功能：Firebase 提供了各種強大的功能，包括<strong>數據庫、身份驗證、雲端存儲、應用分發、推送通知和分析</strong>等。這些功能可以幫助開發者解決常見的開發需求，如數據存儲、用戶管理、消息推送和應用監控等。</td>
<td>自定義性限制：Firebase 提供了許多預先建立的功能和工具，但對於一些特定的需求，開發者可能需要進一步自定義和擴展。<strong>Firebase 的功能和工具是有限的，並且可能無法滿足所有開發者的需求</strong>。在使用 Firebase 之前，<strong>開發者應評估其功能是否符合他們的需求</strong>。</td>
</tr>
<tr>
<td>可擴展性：Firebase 的服務是<strong>高度可擴展</strong>的，可以應對大量的用戶和數據。Firebase 的基礎設施由 Google 提供和維護，<strong>開發者不需要擔心服務的可用性和性能問題</strong>。</td>
<td>數據安全性：由於 Firebase 是一個雲端服務，開發者需要注意數據的安全性問題。儘管 Firebase 提供了一些安全功能，如身份驗證和數據庫規則，但<strong>開發者仍需要確保正確配置和使用這些功能</strong>，以保護用戶數據的安全。</td>
</tr>
</tbody></table>
</div>

<div calss="anzhiyu-tag-link"><a class="tag-Link" target="_blank" href="https://firebase.google.com/?gad_source=1&gclid=Cj0KCQiAzoeuBhDqARIsAMdH14E1OZTSpa-Pc_QyB_d8abyoYTb-LUJ-clC4fGEW1lNGnu1lA85eDBMaAkg-EALw_wcB&gclsrc=aw.ds">
    <div class="tag-link-tips">引用站外地址</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style>
          <i class="anzhiyufont anzhiyu-icon-link" style></i>
        </div>
        <div class="tag-link-right">
            <div class="tag-link-title">Firebase</div>
            <div class="tag-link-sitename"> 點擊前往 Firebase 官網，瞭解更多有關 Firebase 的其他功能。</div>
        </div>
        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>
    </div>
    </a></div>

<hr>
<h1 id="建立新的-Firebase-專案"><a href="#建立新的-Firebase-專案" class="headerlink" title="建立新的 Firebase 專案"></a>建立新的 Firebase 專案</h1><p>首先，你需要前往 <a href="https://console.firebase.google.com/">Firebase 主控台</a>新建一個專案。</p>
<p><span class="step" data-step="1" data-title="設置專案名稱"></span></p>
<p>通常，這個新建的 Firebase 專案名稱會根據所開發的應用程式名稱而命名，例如應用程式名稱為 ComposeFirebase，這個專案名稱順理成章都會是 ComposeFirebase，這個是為了方便辨認哪一個 Firebase 專案是屬於何者應用程式使用。</p>
<p><img src="/post/android-firebase-setup-notes/img1.png" alt="新建一個 Firebase 專案"></p>
<div class="note info simple"><p>Firebase 專案的別名 (Alias) 會根據所命名的專案名稱，而在後綴附上額外編號，例如這個範例是 <code>composefirebase-1cc26</code>，從而避免有重複專案的存在。</p>
</div>

<p><span class="step" data-step="2" data-title="註冊應用程式"></span></p>
<p>然後，你需要把這個專案與應用程式產生鏈結，這裏要輸入應用程式的套件名稱及名稱。</p>
<p><img src="/post/android-firebase-setup-notes/img3.png" alt="註冊應用程式"></p>
<p><span class="step" data-step="3" data-title="設置 SHA-1 偵錯簽署憑證"></span></p>
<p>SHA-1（Secure Hash Algorithm 1） 是一種加密演算法，用於正確識別應用程式及身份，<strong>雖然官方指明這個 SHA-1 偵錯簽署憑證是選填的，但我高度建議設置 SHA-1 偵錯簽署憑證</strong>。</p>
<div class="note danger simple"><p>SHA-1 偵錯簽署憑證是一個極為重要的安全性設定，以下事項需要注意：</p>
<ol>
<li>當你<strong>沒有設置 SHA-1 偵錯簽署憑證</strong>，Firebase 預設會<strong>使用應用程式的套件名稱進行識別及驗證</strong>，如果有其他應用程式有相同的套件名稱，它們通通都被視為有效的驗證，這些應用程式可以訪問到用戶的登入資訊，<strong>潛在安全風險</strong>。因此，<strong>設置 SHA-1 偵錯簽署憑證</strong>作為一個指紋，有效可以與應用程式進行相匹配，<strong>防止其他未經驗證的應用程式</strong>試圖訪問用戶的帳號資訊。</li>
<li>另外，當前獲取的 SHA-1 偵錯簽署憑證是根據預設的偵錯模式 (debug mode)，<strong>當你要把應用程式構建發佈模式 (release mode)，你要獲取發佈模式的 Keystore 證書的 SHA-1 偵錯簽署憑證，然後再次下載新的 <code>google-services.json</code> 設定檔。</strong></li>
</ol>
</div>

<p>你有三種方法檢視應用程式的 SHA-1 偵錯簽署憑證：</p>
<ol>
<li>在終端機輸入指令<div class="tabs" id="code-sha-1-check"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="code-sha-1-check-1">MacOS/Linux</button><button type="button" class="tab " data-href="code-sha-1-check-2">Window</button></ul><div class="tab-contents"><div class="tab-item-content active" id="code-sha-1-check-1"><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">keytool -list -v \</span><br><span class="line">-<span class="built_in">alias</span> androiddebugkey -keystore ~/.android/debug.keystore</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="code-sha-1-check-2"><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">keytool -list -v \</span><br><span class="line">-<span class="built_in">alias</span> androiddebugkey -keystore %USERPROFILE%\.android\debug.keystore</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div></li>
<li>在 Android Studio 項目的終端機輸入 <code>gradlew</code>，如果不行，就試 <code>./gradlew</code>。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gradlew signingReport</span><br></pre></td></tr></table></figure></li>
<li>在 Gradle 工作區中的 <code>Tasks</code> &gt; <code>android</code> &gt; <code>signingReport</code> ，雙擊 <code>signingReport</code> 執行程序便會輸出應用程式的 SHA-1 偵錯簽署憑證。<br><img src="/post/android-firebase-setup-notes/img2.png" alt="執行 signingReport 後結果及檢查 SHA-1 偵錯簽署憑證"><div class="note warning simple"><p>如果找不到 <code>signingReport</code> 執行程序：<br><img src="/post/android-firebase-setup-notes/img4.png" alt="找不到 signingReport 執行程序"><br>請在 Android Studio 偏好設定中留意以下設定：</p>
<ul>
<li>較新版本（Hedgehog 或以上）：<strong>勾選</strong> Configure all Gradle tasks during Gradle Sync (this can make Gradle Sync slower)</li>
<li>較舊版本：<strong>取消勾選</strong> Only include test tasks in the Gradle task list generated during Gradle sync</li>
</ul>
</div></li>
</ol>
<p><span class="step" data-step="4" data-title="下載並新增 Google 服務設定檔"></span></p>
<p>你需要把 Firebase 生成的 <code>google-services.json</code> JSON 設定檔下載下來，然後把它放到 <code>app</code> 目錄裏。</p>
<p><img src="/post/android-firebase-setup-notes/img5.png" alt="加入 google-services.json 設定檔"></p>
<div class="note warning simple"><p>需要定時更新 <code>google-services.json</code> 設定檔，以確保所啟用的建構及服務能順利運作。</p>
</div>

<p><span class="step" data-step="5" data-title="植入 Google 服務到應用程式"></span></p>
<p>Firebase 依賴 Google 服務來執行的，你需要在根目錄的 <code>build.gradle.kts</code> 匯入 Google 服務的 classpath（在 <code>plugins</code> 區塊上方）。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">&quot;com.google.gms:google-services:4.4.0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然後在 <code>app</code> 目錄的 <code>build.gradle.kts</code> 引入 Google 服務的插件以及其函式庫。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Suppress(<span class="string">&quot;DSL_SCOPE_VIOLATION&quot;</span>)</span> <span class="comment">// <span class="doctag">TODO:</span> Remove once KTIJ-19369 is fixed</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    id(<span class="string">&quot;com.google.gms.google-services&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="初始化配合使用-Firebase-的應用程式"><a href="#初始化配合使用-Firebase-的應用程式" class="headerlink" title="初始化配合使用 Firebase 的應用程式"></a>初始化配合使用 Firebase 的應用程式</h1><p>完成了創建 Firebase 專案後，現在就要為應用程式與 Firebase 產生聯繫，方能使用 Firebase 的功能。</p>
<p><span class="step" data-step="1" data-title="准許訪問網絡權限"></span></p>
<p>你需要允許應用程式訪問網絡，從而能夠順利使用部分 Firebase 的網絡服務。請在 <code>AndroidManifest.xml</code> 的 <code>&lt;manifest&gt;</code> 區塊內宣告允許網絡權限。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><span class="step" data-step="2" data-title="匯入 Firebase BoM 物料清單"></span></p>
<p>你需要匯入 Firebase 函式庫，我們會使用 BoM (Bill of Materials) 物料清單匯入。因為 Firebase 提供許多不同功能模組，版本經常性需要作修改，假如你在使用許多功能模組，更新時需要手動逐個修改版本號，所有我們會使用 BoM，<strong>這樣只需要指定 BoM 版本，BoM 便會為你自動匯入該功能模組的穩定版</strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation(platform(<span class="string">&quot;com.google.firebase:firebase-bom:32.7.1&quot;</span>))</span><br><span class="line"><span class="comment">// Java</span></span><br><span class="line">implementation(<span class="string">&quot;com.google.firebase:firebase-common&quot;</span>)</span><br><span class="line"><span class="comment">// Kotlin</span></span><br><span class="line">implementation(<span class="string">&quot;com.google.firebase:firebase-common-ktx&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><span class="step" data-step="3" data-title="初始化 Firebase 程式"></span></p>
<p>然後，你要在應用程式的邏輯入口，初始化 Firebase 程序，才可以在往後執行 Firebase 的功能。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">FirebaseApp.initializeApp(context)</span><br></pre></td></tr></table></figure>

<p>以下是簡單範例，說明如何在傳統的 XML 及 Jetpack Compose 程式的入口點，初始化 Firebase 程式。</p>
<div class="tabs" id="code-initialize-firebase"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="code-initialize-firebase-1">Compose</button><button type="button" class="tab " data-href="code-initialize-firebase-2">XML</button></ul><div class="tab-contents"><div class="tab-item-content active" id="code-initialize-firebase-1"><p>在 Jetpack Compose 程式，在可組合項初始化 Firebase 程式都沒有問題。要注意的是需要使用 <code>LocalContext.current</code> 獲取目前的 <code>Context</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">ComponentActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContent &#123;</span><br><span class="line">            AppTheme &#123;</span><br><span class="line">                <span class="keyword">val</span> context = LocalContext.current</span><br><span class="line">                FirebaseApp.initializeApp(context)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="code-initialize-firebase-2"><p>在傳統 XML 程式，你需要在佈局設置完成後，才可初始化 Firebase 程式，使用 <code>this</code> 已經是 <code>Activity</code> (繼承自 <code>Context</code>) 的實例。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        FirebaseApp.initializeApp(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      <categories>
        <category>Android</category>
        <category>Firebase</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Bash</tag>
      </tags>
  </entry>
  <entry>
    <title>【Android】Keystore 密鑰庫建立 | 密鑰安全及防止洩漏 | 發佈模式運行程序</title>
    <url>/post/android-keystore-and-release-mode-notes.html</url>
    <content><![CDATA[<p>密鑰庫 (Keystore) 是一個<strong>存儲密鑰和證書的安全文件</strong>，Keystore 被用於對應用程式進行簽名，以確保應用程式的完整性和安全性。它包含了一個私鑰和與之相對應的公鑰。</p>
<p>不同構建模式下的密鑰庫：</p>
<ul>
<li>調試模式：在開發階段，我們通常會使用<strong>調試密鑰庫</strong> (Debug Keystore)，它是由 <strong>Android SDK 自動生成的</strong>，並且不需要我們主動管理。Debug Keystore 用於在開發期間對應用程式進行簽名，方便我們在<strong>測試和調試應用程式時使用</strong>。</li>
<li>發佈模式：我們需要<strong>自建新的密鑰庫</strong>作為發佈密鑰庫 (Release Keystore)，對應用程式進行簽名及驗證。</li>
</ul>
<div class="note info simple"><p>當我們要<strong>將應用程式發布到 Google Play 商店或其他渠道</strong>時，我們需要使用發佈密鑰庫，它是<strong>由開發者自己生成的</strong>，並且需要妥善保管。它將用於對應用程式<strong>進行正式簽名</strong>，以確保應用程式的安全性和真實性。</p>
</div>

<hr>
<h1 id="構建及簽署應用程式"><a href="#構建及簽署應用程式" class="headerlink" title="構建及簽署應用程式"></a>構建及簽署應用程式</h1><p>要進行發佈版本，最重要的就是要為應用程式簽署，開啟 Android Studio，並上方選單列的 <code>Build</code> 找 <code>Generate Signed Bundle / APK</code> 完成以下程序。</p>
<p><span class="step" data-step="1" data-title="選用應用程式封裝模式"></span></p>
<p>它會詢問你使用 Android App Bundle (AAB) 或是 APK 進行封裝，這裏選擇 APK。</p>
<p><img src="/post/android-keystore-and-release-mode-notes/img1.png" alt="選擇 APK 選項"></p>
<p><span class="step" data-step="2" data-title="新建密鑰庫"></span></p>
<p>如果你之前已經有建立了密鑰庫，那麼，你就按 <code>Choose existing...</code> 選擇曾經已建立的密鑰庫，不然就按 <code>Create new...</code> 新建密鑰庫。</p>
<div class="note info simple"><p>在導入已建立的密鑰庫，你需要輸入該密鑰庫所設定的密碼。</p>
</div>

<p><img src="/post/android-keystore-and-release-mode-notes/img2.png" alt="新增或導入密鑰庫"></p>
<p><span class="step" data-step="3" data-title="完成建立密鑰庫的設定"></span></p>
<p>建立一個密鑰庫需要填妥表格，包括以下項目</p>
<p><img src="/post/android-keystore-and-release-mode-notes/img3.png" alt="建立密鑰庫的設定"></p>
<ul>
<li><code>Key store path</code>: 密鑰庫檔案 (副檔名為 <code>.keystore</code>) 存放位置，通常如果是獨立只為獨有應用程式用的 Keystore，這個檔案路徑可以存放到專案的根目錄位置 e.g. <code>AndroidStudioProjects/MyApp/myapp_release.keystore</code></li>
<li><code>Password</code>: 設置密鑰庫的密碼</li>
</ul>
<p>而 <code>Key</code> 有幾項需要注意：</p>
<ul>
<li><code>Alias</code>: Key 的名稱，可以用 <code>key</code> 為前綴 e.g. <code>keyMyApp</code>，不規定。</li>
<li><code>Password</code>: 設置 Key 的密碼，如沒有太大問題，這裏可以都使用密鑰庫的密碼</li>
<li><code>Validity</code>: 以年數作計算，預設是 <code>25</code>，就是 Key 的有效期為 25 年</li>
</ul>
<p>而 <code>Certificate</code> 細項中：</p>
<ul>
<li><code>First and Last Name</code>: 用戶名稱</li>
</ul>
<p>其餘的按需要就填。</p>
<p>例如，現在我完成了密鑰庫的基本設定，如下所示：</p>
<p><img src="/post/android-keystore-and-release-mode-notes/img4.png" alt="完成密鑰庫的基本設定"></p>
<p><span class="step" data-step="4" data-title="選用密鑰庫應用的構建模式"></span></p>
<p>這裏會問密鑰庫應用到 <code>debug</code> 或是 <code>release</code>，選擇 <code>release</code>。</p>
<p><img src="/post/android-keystore-and-release-mode-notes/img5.png" alt="選用密鑰庫應用的構建模式"></p>
<p><span class="step" data-step="5" data-title="在 Gradle 設置發佈模式及密鑰庫組態"></span></p>
<p>在 <code>app</code> 模塊的 <code>build.gradle.kts</code> 加入代碼：</p>
<div class="tabs" id="code-signingconfig"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="code-signingconfig-1">Kotlin DSL</button><button type="button" class="tab " data-href="code-signingconfig-2">Groovy DSL</button></ul><div class="tab-contents"><div class="tab-item-content active" id="code-signingconfig-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">signingConfigs &#123;</span><br><span class="line">    create(<span class="string">&quot;release&quot;</span>) &#123;</span><br><span class="line">        keyAlias = <span class="string">&quot;XXX&quot;</span></span><br><span class="line">        keyPassword = <span class="string">&quot;XXX&quot;</span>         <span class="comment">// Key 密碼</span></span><br><span class="line">        storeFile = file(<span class="string">&quot;XXX&quot;</span>)</span><br><span class="line">        storePassword = <span class="string">&quot;XXX&quot;</span>       <span class="comment">// Keystore 密碼</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">buildTypes &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        signingConfig = signingConfigs.getByName(<span class="string">&quot;release&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="code-signingconfig-2"><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">signingConfigs &#123;</span><br><span class="line">   release &#123;</span><br><span class="line">       keyAlias <span class="string">&quot;XXX&quot;</span></span><br><span class="line">       keyPassword <span class="string">&quot;XXX&quot;</span>            <span class="comment">// Key 密碼</span></span><br><span class="line">       storeFile <span class="keyword">file</span>(<span class="string">&quot;XXX&quot;</span>)</span><br><span class="line">       storePassword <span class="string">&quot;XXX&quot;</span>          <span class="comment">// Keystore 密碼</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">buildTypes &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        signingConfig signingConfigs.release</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>

<div class="note info simple"><p><code>storeFile</code> 是密鑰庫檔案存放路徑，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">storeFile = file(<span class="string">&quot;/Users/bluewhaleyt/AndroidStudioProjects/MyApp/myapp_release.keystore&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<div class="note danger simple"><p>由於密鑰庫是私密的敏感資料，例如所設定的密碼不應公開，你可以在 <code>~/.gradle/gradle.properties</code> 檔案內把密鑰庫設定存入在內：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RELEASE_KEY_ALIAS=XXX</span><br><span class="line">RELEASE_KEY_PASSWORD=XXX</span><br><span class="line">RELEASE_STORE_FILE_PATH=XXX</span><br><span class="line">RELEASE_STORE_PASSWORD=XXX</span><br></pre></td></tr></table></figure>

<p>然後在 <code>build.gradle.kts</code> 使用 <code>gradle.properties</code> 內的密鑰庫設定</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">keyAlias RELEASE_KEY_ALIAS</span><br><span class="line">keyPassword RELEASE_KEY_PASSWORD</span><br><span class="line">storeFile file(RELEASE_STORE_FILE_PATH)</span><br><span class="line">storePassword RELEASE_STORE_PASSWORD</span><br></pre></td></tr></table></figure></div>

<p><span class="step" data-step="6" data-title="為應用程式改用發佈模式構建"></span></p>
<p>把專案 <code>app</code> 的 <code>Build Variant</code> 更改為 <code>release</code> 版本。</p>
<div class="note info simple"><p>一旦改 <code>app</code> 的 <code>Build Variant</code> (構建模式)，其他的模塊都會用該構建模式，即一併使用 <code>release</code> 模式。</p>
</div>

<p><img src="/post/android-keystore-and-release-mode-notes/img6.png" alt="修改應用程式的建構模式"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>【Android】NDK | C++ Native 程式開發</title>
    <url>/post/android-ndk-cpp-project-notes.html</url>
    <content><![CDATA[<p>C++ 是一種中階程式語言，主要用於遊戲和視覺開發。它也是<strong>眾所周知的難以理解的程式語法</strong>之一。這種語言與 Android 開發密切相關，因為<strong>大多數手機遊戲都是用 C++ 進行編寫和開發</strong>的。作為開發 Android 程式的我們，也可以使用 Android Studio 來寫 C++ Native 程式，就像跨領域使用 Java 和 C++ 一樣。</p>
<hr>
<h1 id="初始化及建立-C-Native-項目"><a href="#初始化及建立-C-Native-項目" class="headerlink" title="初始化及建立 C++ Native 項目"></a>初始化及建立 C++ Native 項目</h1><p>現在，我們會透過使用 Android Studio 提供的預設 C++ Native 模板初始化及完成配置。</p>
<p><span class="step" data-step="1" data-title="選用 C++ Native 模板"></span></p>
<p><img src="/post/android-ndk-cpp-project-notes/img1.png" alt="C++ Native 項目模板"></p>
<p><span class="step" data-step="2" data-title="選用 C++ 版本"></span></p>
<p>這裏它會要你選擇使用什麼 C++ 版本，通常選擇 Toolchain Default 便可。</p>
<p><img src="/post/android-ndk-cpp-project-notes/img2.png" alt="選擇 C++ 版本"></p>
<h2 id="項目變更"><a href="#項目變更" class="headerlink" title="項目變更"></a>項目變更</h2><p>當你完成了使用 C++ Native 模板建立項目後，有幾個變更需要留意。</p>
<h3 id="app-模塊-build-gradle"><a href="#app-模塊-build-gradle" class="headerlink" title="app 模塊 build.gradle"></a><code>app</code> 模塊 <code>build.gradle</code></h3><p>在 <code>app</code> 模塊的 <code>build.gradle</code> 內的 <code>android</code> 區塊多定義了使用 C++ 函式庫的配置：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">externalNativeBuild &#123;</span><br><span class="line">    cmake &#123;</span><br><span class="line">        path <span class="keyword">file</span>(<span class="string">&#x27;src/main/cpp/CMakeLists.txt&#x27;</span>)</span><br><span class="line">        version <span class="string">&#x27;3.22.1&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="樹狀結構變更"><a href="#樹狀結構變更" class="headerlink" title="樹狀結構變更"></a>樹狀結構變更</h3><p>因為這是一個 C++ Native 項目，所以它會較一般的 Android 項目多附加了一些預設元素，如果你沒有 C++ Native 模板或 Android Studio，可考慮以下樹狀結構變更。</p>
<p><img src="/post/android-ndk-cpp-project-notes/img3.png" alt="樹狀結構變更"></p>
<p>在 app 目錄會多新增了一個 <code>cpp</code> 資料夾，顧名思義，這個資料夾是用來管理及編寫 C++ 語言。</p>
<h3 id="CMake-建構指令碼"><a href="#CMake-建構指令碼" class="headerlink" title="CMake 建構指令碼"></a>CMake 建構指令碼</h3><p>CMake 建構指令碼是一個純文字檔案，檔案名必須為 <code>CMakeLists.txt</code>。就是負責為 C 或 C++ 程式定義要用的函式庫，相當於 Java 的 <code>build.gradle</code>。</p>
<p>根據這個模板，預設的 <code>CMakeLists.txt</code> 內容是這樣的：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># For more information about using CMake with Android Studio, read the</span></span><br><span class="line"><span class="comment"># documentation: https://d.android.com/studio/projects/add-native-code.html.</span></span><br><span class="line"><span class="comment"># For more examples on how to use CMake, see https://github.com/android/ndk-samples.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sets the minimum CMake version required for this project.</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.22</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Declares the project name. The project name can be accessed via $&#123; PROJECT_NAME&#125;,</span></span><br><span class="line"><span class="comment"># Since this is the top level CMakeLists.txt, the project name is also accessible</span></span><br><span class="line"><span class="comment"># with $&#123;CMAKE_PROJECT_NAME&#125; (both CMake variables are in-sync within the top level</span></span><br><span class="line"><span class="comment"># build script scope).</span></span><br><span class="line"><span class="keyword">project</span>(<span class="string">&quot;cppapptest&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creates and names a library, sets it as either STATIC</span></span><br><span class="line"><span class="comment"># or SHARED, and provides the relative paths to its source code.</span></span><br><span class="line"><span class="comment"># You can define multiple libraries, and CMake builds them for you.</span></span><br><span class="line"><span class="comment"># Gradle automatically packages shared libraries with your APK.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In this top level CMakeLists.txt, $&#123;CMAKE_PROJECT_NAME&#125; is used to define</span></span><br><span class="line"><span class="comment"># the target library name; in the sub-module&#x27;s CMakeLists.txt, $&#123;PROJECT_NAME&#125;</span></span><br><span class="line"><span class="comment"># is preferred for the same purpose.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In order to load a library into your app from Java/Kotlin, you must call</span></span><br><span class="line"><span class="comment"># System.loadLibrary() and pass the name of the library defined here;</span></span><br><span class="line"><span class="comment"># for GameActivity/NativeActivity derived applications, the same library name must be</span></span><br><span class="line"><span class="comment"># used in the AndroidManifest.xml file.</span></span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;CMAKE_PROJECT_NAME&#125;</span> SHARED</span><br><span class="line">        <span class="comment"># List C/C++ source files with relative paths to this CMakeLists.txt.</span></span><br><span class="line">        native-lib.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specifies libraries CMake should link to your target library. You</span></span><br><span class="line"><span class="comment"># can link libraries from various origins, such as libraries defined in this</span></span><br><span class="line"><span class="comment"># build script, prebuilt third-party libraries, or Android system libraries.</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;CMAKE_PROJECT_NAME&#125;</span></span><br><span class="line">        <span class="comment"># List libraries link to the target library</span></span><br><span class="line">        android</span><br><span class="line">        log)</span><br></pre></td></tr></table></figure>

<h3 id="Java-與-C-鏈結產生"><a href="#Java-與-C-鏈結產生" class="headerlink" title="Java 與 C++ 鏈結產生"></a>Java 與 C++ 鏈結產生</h3><p>這個模板預設提供了一個 <code>native-lib.cpp</code> 檔案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">JNIEXPORT jstring JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_com_bluewhaleyt_cppapptest_MainActivity_stringFromJNI</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        JNIEnv* env,</span></span></span><br><span class="line"><span class="params"><span class="function">        jobject <span class="comment">/* this */</span>)</span> </span>&#123;</span><br><span class="line">    std::string hello = <span class="string">&quot;Hello from C++&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(hello.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在 <code>MainActivity.java</code> 多新增了一個載入 <code>native-lib</code> C++ 本機函式庫的程式碼，而及一個 <code>native</code> 關鍵字而成的 C++ 調用函數：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.loadLibrary(<span class="string">&quot;cppapptest&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">stringFromJNI</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Java-本機介面-JNI"><a href="#Java-本機介面-JNI" class="headerlink" title="Java 本機介面 (JNI)"></a>Java 本機介面 (JNI)</h1><p>JNI 是一個編程框架，透過 Java 虛擬機 (JVM) 調用函式庫，或其他本機程序，本機程序一般使用 C、C++ 或匯編語言 (Assembly) 編寫，從而被編譯為爾件及系統操作的程序。</p>
<p>在以上模板，你可以看到，定義一個 JNI 方法，需要這麼長的程式碼：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">JNIEXPORT jstring JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_ClassName_functionName</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    JNIEnv* env,</span></span></span><br><span class="line"><span class="params"><span class="function">    jobject <span class="comment">/* this */</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<div class="note info simple"><p>在這個範例中，<code>ClassName</code> 是項目的 Java <code>MainActivity</code> 類別 <code>com_bluewhaleyt_cppapptest_MainActivity</code></p>
</div>

<p>而在 Java 程式調用 C++ 函數 <code>functionName()</code>，就要另外定義一個附有 <code>native</code> 關鍵字的相應函數：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">functionName</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>特別要說說 C++ 程式碼：</p>
<ul>
<li><code>extern &quot;C&quot;</code>: 是一個限制使用 C 語言作為命名規則，即該函數將會採用 C 語言進行定義。</li>
<li><code>JNIEXPORT</code> 及 <code>JNICALL</code>: 是定義 JNI 函數的修飾詞。</li>
<li><code>jstring</code>: 是指明函數傳回類型是 Java 的 <code>String</code> 型別</li>
<li><code>JNIEnv</code>: 是一個指向 JNI 環境的指標，提供了在本地程式碼中調用 Java 方法、訪問 Java 對象等操作的方法。</li>
<li><code>jobject</code>: 是一個代表 Java 對象的類型。它可以是任何 Java 對象的參考，並且可以在本地程式碼中用於訪問該對象的屬性和方法。</li>
</ul>
<div class="note info simple"><p>基本上這個 JNI 定義方法不用手動敲的，可以直接用 Android Studio 的自動完成方案：</p>
<p>只要在 Java 定義一個 <code>native</code> 方法：</p>
<p><img src="/post/android-ndk-cpp-project-notes/img4.png" alt="C++ 自動完成方案"></p>
<p>然後就會在 C++ 檔案生成了程式碼：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="type">void</span> JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_com_bluewhaleyt_cppapptest_MainActivity_myTestFunc</span><span class="params">(JNIEnv *env, jobject thiz)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement myTestFunc()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以你大可以不用學會怎樣寫 JNI 方法，只要理解便可。</p>
</div>

<hr>
<h1 id="動態鏈接庫-so"><a href="#動態鏈接庫-so" class="headerlink" title="動態鏈接庫 (.so)"></a>動態鏈接庫 (<code>.so</code>)</h1><p>把編譯並匯出後的 <code>.apk</code> 檔案修改為 <code>.zip</code> 檔案解壓縮，開啟 <code>lib</code> 資料夾就可以看到 <code>.so</code> 檔案。</p>
<p>Android Studio 的 C++ Native 模板預設支援及提供以下 NDK 架構:</p>
<p><img src="/post/android-ndk-cpp-project-notes/img5.png" alt="NDK .so"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>NDK</tag>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>【Android】Termux API | 終端機視圖介面</title>
    <url>/post/android-terminal-view-using-termux-api-notes.html</url>
    <content><![CDATA[<p>如果你經常使用手機進行開發及運行套件，那麼，你一定會使用 Termux 終端機應用程式，它是一個<strong>專為 Android 而設</strong>的終端機應用程式，<strong>執行 Linux 指令碼</strong>。Termux 除了提供一個指令行介面的應用程式，亦都提供了 API 函式庫，讓<strong>開發者能夠把 Termux 終端機介面嵌入至應用程式</strong>裏。例如，如果你在編寫一個終端機應用程式或需要使用到終端機的程式碼編寫工具，你便可以使用 Termux API，而不需要手動實作終端機。</p>
<hr>
<h1 id="匯入-Termux-API-至應用程式"><a href="#匯入-Termux-API-至應用程式" class="headerlink" title="匯入 Termux API 至應用程式"></a>匯入 Termux API 至應用程式</h1><p>首先，你需要匯入 Termux API 函式庫至應用程式，才可使用相關 API 程式碼。</p>
<p><span class="step" data-step="1" data-title="引入 JitPack 存儲庫"></span></p>
<p>因為 Termux API 採用 Jitpack 來上傳函式庫，所以請於 <code>settings.gradle.kts</code> 引入 JitPack 存儲庫。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">pluginManagement &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        maven(<span class="string">&quot;https://jitpack.io&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencyResolutionManagement &#123;</span><br><span class="line">    repositoriesMode.<span class="keyword">set</span>(RepositoriesMode.FAIL_ON_PROJECT_REPOS)</span><br><span class="line">    repositories &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        maven(<span class="string">&quot;https://jitpack.io&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span class="step" data-step="2" data-title="匯入 Termux API 函式庫"></span></p>
<p>以下的函式庫是由 Termux API 提供並所使用的函式庫。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation(<span class="string">&quot;com.termux.termux-app:terminal-shared:0.117&quot;</span>)</span><br><span class="line">implementation(<span class="string">&quot;com.termux.termux-app:terminal-view:0.117&quot;</span>)</span><br><span class="line">implementation(<span class="string">&quot;com.termux.termux-app:terminal-emulator:0.117&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="使用-terminal-view-函式庫"><a href="#使用-terminal-view-函式庫" class="headerlink" title="使用 terminal-view 函式庫"></a>使用 <code>terminal-view</code> 函式庫</h1><p>這個函式庫主要提供一個 <code>TerminalView</code> 視圖，並透過建立 <code>TerminalSession</code> 來使用終端機。</p>
<h2 id="加入終端機視圖組件"><a href="#加入終端機視圖組件" class="headerlink" title="加入終端機視圖組件"></a>加入終端機視圖組件</h2><p>請在佈局文件加入 <code>TerminalView</code> 視圖。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;com.termux.view.TerminalView</span><br><span class="line">    android:id=<span class="string">&quot;@+id/terminal&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<h2 id="宣告及建立初始的工作階段"><a href="#宣告及建立初始的工作階段" class="headerlink" title="宣告及建立初始的工作階段"></a>宣告及建立初始的工作階段</h2><p>預設的 <code>TerminalView</code> 是空的，所以你需要自行建立一個起始的工作階段 (session)，而建立一個工作階段，根據 <code>TerminalSession</code> 建構式，你需要以下設置元素：</p>
<ul>
<li><code>shellPath</code>：殼層的檔案路徑，預設是使用 <code>/bin/sh</code> 路徑，但如果這個路徑不存在，就會使用 <code>/system/bin/sh</code>，或者，你可以使用自訂的 Shell 檔案。<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shell = <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line"><span class="keyword">if</span> (!File(shell).exists())</span><br><span class="line">    shell = <span class="string">&quot;/system/bin/sh&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><code>cwd</code>：當前的工作目錄 (current working directory)，即設置這個工作階段起始的根路徑。<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> cwd = context.filesDir.absolutePath                             <span class="comment">// 此應用程式的 data 目錄</span></span><br><span class="line"><span class="keyword">val</span> cwd = Environment.getExternalStorageDirectory().absolutePath    <span class="comment">// 此裝置的外部儲存空間目錄</span></span><br></pre></td></tr></table></figure></li>
<li><code>args</code>：要傳入的參數，如果不需傳入任何參數，可用空陣列。<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> args: Array&lt;String&gt; = emptyArray()</span><br></pre></td></tr></table></figure></li>
<li><code>env</code>：要設置的環境變數，預設不需要使用。<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> env: Array&lt;String&gt;? = <span class="literal">null</span></span><br></pre></td></tr></table></figure></li>
<li><code>transcriptRows</code>：終端機可顯示的總行數，即使用戶輸入 <code>clear</code> 指令，當向上滾動時，仍能顯示及檢查較舊的終端輸出，是取決於此設定值。<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> transcriptRows = TerminalEmulator.DEFAULT_TERMINAL_TRANSCRIPT_ROWS  <span class="comment">// 預設：2000</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="設置工作階段客戶端"><a href="#設置工作階段客戶端" class="headerlink" title="設置工作階段客戶端"></a>設置工作階段客戶端</h3><p>這個 <code>TerminalSession</code> 最後需要接受的參數是一個工作階段客戶端，你需要加入以下程式碼。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> TerminalView.<span class="title">getSessionClient</span><span class="params">()</span></span> = <span class="keyword">object</span> : TerminalSessionClient &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTextChanged</span><span class="params">(changedSession: <span class="type">TerminalSession</span>?)</span></span> &#123;</span><br><span class="line">        onScreenUpdated()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTitleChanged</span><span class="params">(changedSession: <span class="type">TerminalSession</span>?)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSessionFinished</span><span class="params">(finishedSession: <span class="type">TerminalSession</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (finishedSession?.isRunning == <span class="literal">false</span>) &#123;</span><br><span class="line">            finishedSession.finishIfRunning()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClipboardText</span><span class="params">(session: <span class="type">TerminalSession</span>?, text: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBell</span><span class="params">(session: <span class="type">TerminalSession</span>?)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onColorsChanged</span><span class="params">(session: <span class="type">TerminalSession</span>?)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTerminalCursorStateChange</span><span class="params">(state: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getTerminalCursorStyle</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> TerminalEmulator.DEFAULT_TERMINAL_CURSOR_STYLE</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">logError</span><span class="params">(tag: <span class="type">String</span>?, message: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">logWarn</span><span class="params">(tag: <span class="type">String</span>?, message: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">logInfo</span><span class="params">(tag: <span class="type">String</span>?, message: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">logDebug</span><span class="params">(tag: <span class="type">String</span>?, message: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">logVerbose</span><span class="params">(tag: <span class="type">String</span>?, message: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">logStackTraceWithMessage</span><span class="params">(tag: <span class="type">String</span>?, message: <span class="type">String</span>?, e: <span class="type">Exception</span>?)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">logStackTrace</span><span class="params">(tag: <span class="type">String</span>?, e: <span class="type">Exception</span>?)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最後，你的 <code>TerminalSession</code> 完成設置如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> terminalSession = TerminalSession(</span><br><span class="line">    shellPath,</span><br><span class="line">    cwd,</span><br><span class="line">    args,</span><br><span class="line">    env,</span><br><span class="line">    transcriptRows,</span><br><span class="line">    getSessionClient()</span><br><span class="line">)</span><br><span class="line">terminalSession.titleChanged(<span class="string">&quot;1&quot;</span>, shellPath)</span><br></pre></td></tr></table></figure>

<h3 id="設置視圖客戶端"><a href="#設置視圖客戶端" class="headerlink" title="設置視圖客戶端"></a>設置視圖客戶端</h3><p>另外，你亦需要設置視圖客戶端，這個視圖客戶端用來客製化及控制終端機的各種行為。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> TerminalView.<span class="title">getViewClient</span><span class="params">()</span></span> = <span class="keyword">object</span> : TerminalViewClient &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onScale</span><span class="params">(scale: <span class="type">Float</span>)</span></span>: <span class="built_in">Float</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">18f</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSingleTapUp</span><span class="params">(e: <span class="type">MotionEvent</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> imm = context.getSystemService(Context.INPUT_METHOD_SERVICE) <span class="keyword">as</span> InputMethodManager</span><br><span class="line">        isFocusable = <span class="literal">true</span></span><br><span class="line">        isFocusableInTouchMode = <span class="literal">true</span></span><br><span class="line">        requestFocus()</span><br><span class="line">        imm.showSoftInput(<span class="keyword">this</span><span class="symbol">@getViewClient</span>, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">shouldBackButtonBeMappedToEscape</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">shouldEnforceCharBasedInput</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">shouldUseCtrlSpaceWorkaround</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">copyModeChanged</span><span class="params">(copyMode: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyDown</span><span class="params">(keyCode: <span class="type">Int</span>, e: <span class="type">KeyEvent</span>?, session: <span class="type">TerminalSession</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (keyCode == KeyEvent.KEYCODE_ENTER &amp;&amp; !session!!.isRunning) &#123;</span><br><span class="line">            exitProcess(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyUp</span><span class="params">(keyCode: <span class="type">Int</span>, e: <span class="type">KeyEvent</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onLongPress</span><span class="params">(event: <span class="type">MotionEvent</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">readControlKey</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">readAltKey</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCodePoint</span><span class="params">(codePoint: <span class="type">Int</span>, ctrlDown: <span class="type">Boolean</span>, session: <span class="type">TerminalSession</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onEmulatorSet</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">logError</span><span class="params">(tag: <span class="type">String</span>?, message: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">logWarn</span><span class="params">(tag: <span class="type">String</span>?, message: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">logInfo</span><span class="params">(tag: <span class="type">String</span>?, message: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">logDebug</span><span class="params">(tag: <span class="type">String</span>?, message: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">logVerbose</span><span class="params">(tag: <span class="type">String</span>?, message: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">logStackTraceWithMessage</span><span class="params">(tag: <span class="type">String</span>?, message: <span class="type">String</span>?, e: <span class="type">Exception</span>?)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">logStackTrace</span><span class="params">(tag: <span class="type">String</span>?, e: <span class="type">Exception</span>?)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然後，為 <code>TerminalView</code> 設置視圖客戶端如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">setTerminalViewClient(getViewClient())</span><br></pre></td></tr></table></figure>

<p>最後，應用 <code>terminalSession</code> 的工作階段。</p>
<div class="note danger simple"><p>你需要手動設置 <code>TerminalView</code> 的文字大小，不然會報錯。</p>
</div>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">attachSession(terminalSession)</span><br><span class="line">setTextSize(<span class="number">40</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="利用程式碼執行指令"><a href="#利用程式碼執行指令" class="headerlink" title="利用程式碼執行指令"></a>利用程式碼執行指令</h2><p>有時候，你可能會提供一些快捷按鈕執行指令，例如，你想使用程式碼執行 <code>clear</code> 指令，你可以使用 <code>mTermSession</code> 的 <code>write()</code> 方法完成。</p>
<div class="note info simple"><p>加上 <code>\r</code> 就是回車鍵，所以會直接執行指令。<strong>若不加上，則只會把文本寫入到終端機的輸入欄</strong>。</p>
</div>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> TerminalSession.<span class="title">runCommand</span><span class="params">(command: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.write(<span class="string">&quot;<span class="variable">$command</span>\r&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>【Jetpack Compose】Firebase Authentication 帳號註冊及身份驗證 | 多平台第三方登入</title>
    <url>/post/jetpack-compose-firebase-auth-notes.html</url>
    <content><![CDATA[<p>當我們要編寫及開發一些社交媒體或需要用戶註冊一個帳戶時，許多時候這些的應用程式要求用戶註冊及登入一個新帳戶，這個帳戶是用來<strong>存取屬於該應用程式的帳戶資料及其他資料</strong>，亦用於識別帳戶。用戶除了可以<strong>透過電郵地址&#x2F;密碼來註冊，亦可以使用第三方平台</strong>的帳戶進行登入，如常見的 Google、Facebook 等。</p>
<p>未創建 Firebase 專案的請先看這篇文章：</p>
<div calss="anzhiyu-tag-link"><a class="tag-Link" target="_blank" href="/post/android-firebase-setup-notes">
    <div class="tag-link-tips">引用站外地址</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style>
          <i class="anzhiyufont anzhiyu-icon-link" style></i>
        </div>
        <div class="tag-link-right">
            <div class="tag-link-title">Firebase 專案配置</div>
            <div class="tag-link-sitename"> 看這篇文章瞭解如何配置 Firebase 專案</div>
        </div>
        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>
    </div>
    </a></div>

<hr>
<h1 id="初始化-Firebase-Authentication"><a href="#初始化-Firebase-Authentication" class="headerlink" title="初始化 Firebase Authentication"></a>初始化 Firebase Authentication</h1><p>Firebase Authentication 是 Firebase 其中一個常用的功能建構，它可以為應用程式實現身份驗證及第三方登入的程序。</p>
<p><span class="step" data-step="1" data-title="匯入 Firebase Authentication 函式庫"></span></p>
<p>首先，Firebase Authentication 是一個 Firebase 延伸的功能模組，對應模組名是 <code>firebase-auth</code>，你需要匯入 Firebase Authentication 函式庫才可使用相關的 API 程式碼。</p>
<div class="note info simple"><p>這裏使用 Firebase BoM 物料清單匯入。</p>
</div>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation(<span class="string">&quot;com.google.android.gms:play-services-auth:20.7.0&quot;</span>)</span><br><span class="line">implementation(<span class="string">&quot;com.google.firebase:firebase-auth&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><span class="step" data-step="2" data-title="宣告及初始化 FirebaseAuth 實例"></span></p>
<div class="tabs" id="code-init-firebaseauth"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="code-init-firebaseauth-1">Kotlin</button><button type="button" class="tab " data-href="code-init-firebaseauth-2">Java</button></ul><div class="tab-contents"><div class="tab-item-content active" id="code-init-firebaseauth-1"><p>在 Kotlin，我們可以使用 <code>Firebase</code> 實例中的 <code>auth</code> 屬性來獲取 <code>FirebaseAuth</code> 實例。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> auth = Firebase.auth</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="code-init-firebaseauth-2"><p>在 Java，我們需要使用 <code>FirebaseAuth</code> 實例中的 <code>getInstance()</code> 方法來獲取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FirebaseAuth</span> <span class="variable">auth</span> <span class="operator">=</span> FirebaseAuth.getInstance();</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>

<hr>
<h1 id="基本使用-Firebase-Authentication"><a href="#基本使用-Firebase-Authentication" class="headerlink" title="基本使用 Firebase Authentication"></a>基本使用 Firebase Authentication</h1><p>完成好 Firebase Authentication 的初始化工序後，接下來我們所宣告的 <code>auth</code> 變量將會經常被使用，因為大部分的身份驗證 API 程式碼都需要 <code>FirebaseAuth</code> 實例。</p>
<h2 id="註冊新用戶"><a href="#註冊新用戶" class="headerlink" title="註冊新用戶"></a>註冊新用戶</h2><p>在用戶初始使用應用程式時，通常都沒有現有帳戶的，所以這個註冊工序是必須的。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">auth.createUserWithEmailAndPassword(email, password)</span><br><span class="line">    .await()</span><br></pre></td></tr></table></figure>

<div class="note info simple"><p>以上方法只適用於以電郵地址&#x2F;密碼進行註冊帳戶。</p>
</div>

<h2 id="登入現有用戶"><a href="#登入現有用戶" class="headerlink" title="登入現有用戶"></a>登入現有用戶</h2><p>通常用戶註冊完後，接下來就是登入帳戶，就算<strong>用戶清空了或刪除了應用程式及資料</strong>，用戶仍可透過 Firebase Authentication <strong>所儲存的帳戶再次登入</strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">auth.signInWithEmailAndPassword(email, password)</span><br><span class="line">    .await()</span><br></pre></td></tr></table></figure>

<div class="note info simple"><p>以上方法只適用於以電郵地址&#x2F;密碼進行登入帳戶。</p>
</div>

<h2 id="登出帳戶"><a href="#登出帳戶" class="headerlink" title="登出帳戶"></a>登出帳戶</h2><p>當用戶想登出帳戶時，可能是更換其他帳戶、再次註冊新帳戶等程序，這個時候登出帳戶就重要了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">auth.signOut()</span><br></pre></td></tr></table></figure>

<div class="note info simple"><p>使用第三方登入的程式碼都是使用以上方法進行登出帳戶。</p>
</div>

<h2 id="檢查目前的身份驗證狀態"><a href="#檢查目前的身份驗證狀態" class="headerlink" title="檢查目前的身份驗證狀態"></a>檢查目前的身份驗證狀態</h2><p>許多時候，你會想<strong>用戶一旦完成登入帳戶後，用戶不需再進行登入多次</strong>，進入登入後的主介面，所以這個檢查身份驗證狀態是必要的，通常就是檢查用戶是否已登入。如果用戶已登入，則可以直接進入主介面，否則則會進行註冊&#x2F;登入介面。</p>
<p>原來，我們可以使用 <code>FirebaseAuth</code> 的 <code>getCurrentUser()</code> 方法，檢查如果這個獲取的 <code>currentUser</code> 是空的話，就代表用戶尚未登入。</p>
<div class="tabs" id="code-check-user-auth-status"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="code-check-user-auth-status-1">Kotlin</button><button type="button" class="tab " data-href="code-check-user-auth-status-2">Java</button></ul><div class="tab-contents"><div class="tab-item-content active" id="code-check-user-auth-status-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> isUserSignedIn = auth.currentUser != <span class="literal">null</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="code-check-user-auth-status-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isUserSignedIn</span> <span class="operator">=</span> auth.getCurrentUser() != <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>

<h3 id="存取用戶資訊"><a href="#存取用戶資訊" class="headerlink" title="存取用戶資訊"></a>存取用戶資訊</h3><p>當你確認好用戶已完成登入，你可以使用 <code>currentUser</code> 來獲取當前已登入用戶的資訊。</p>
<div class="note warning simple"><p>因為當前用戶 (<code>currentUser</code>) 需要時間獲取的，所以它有可能一開始時是空的。</p>
</div>

<p>你可以從這個 <code>FirebaseUser</code> 實例中，獲取以下資訊：</p>
<ul>
<li><code>displayName</code>：用戶的顯示名稱</li>
<li><code>email</code>：用戶的電郵地址</li>
<li><code>photoUrl</code>：用戶的頭像圖片 URL 鏈結</li>
<li><code>isEmailVerified</code>：檢查用戶的電郵地址是否有效</li>
<li><code>uid</code>：用戶唯一的獨有 ID，但<strong>通常不建議在後端使用</strong>，官方建議使用 <code>FirebaseUser#getIdToken()</code></li>
</ul>
<div class="tabs" id="code-get-currentuser-info"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="code-get-currentuser-info-1">Kotlin</button><button type="button" class="tab " data-href="code-get-currentuser-info-2">Java</button></ul><div class="tab-contents"><div class="tab-item-content active" id="code-get-currentuser-info-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> user = auth.currentUser</span><br><span class="line">user?.let &#123;</span><br><span class="line">    <span class="keyword">val</span> name = it.displayName</span><br><span class="line">    <span class="keyword">val</span> email = it.email</span><br><span class="line">    <span class="keyword">val</span> photoUrl = it.photoUrl</span><br><span class="line">    <span class="keyword">val</span> emailVerified = it.isEmailVerified</span><br><span class="line">    <span class="keyword">val</span> uid = it.uid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="code-get-currentuser-info-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FirebaseUser</span> <span class="variable">user</span> <span class="operator">=</span> auth.getCurrentUser();</span><br><span class="line"><span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> user.getDisplayName();</span><br><span class="line">    <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> user.getEmail();</span><br><span class="line">    <span class="type">Uri</span> <span class="variable">photoUrl</span> <span class="operator">=</span> user.getPhotoUrl();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">emailVerified</span> <span class="operator">=</span> user.isEmailVerified();</span><br><span class="line">    <span class="type">String</span> <span class="variable">uid</span> <span class="operator">=</span> user.getUid();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>

<hr>
<h1 id="建立-Firebase-Authentication-介面及第三方登入處理"><a href="#建立-Firebase-Authentication-介面及第三方登入處理" class="headerlink" title="建立 Firebase Authentication 介面及第三方登入處理"></a>建立 Firebase Authentication 介面及第三方登入處理</h1><p>你看到<strong>大部分應用程式都不是使用單一的登入方式</strong>的，它們會允許用戶以電郵地址&#x2F;密碼及第三方登入，如支援登入方式如下：</p>
<ul>
<li>電郵地址&#x2F;密碼</li>
<li>Google</li>
<li>Facebook</li>
<li>更多..</li>
</ul>
<p><img src="/post/jetpack-compose-firebase-auth-notes/img6.png" alt="Firebase Authentication 支援的第三方平台"></p>
<p>通常，這些登入方式萬變不離其宗，都會有以下功能：</p>
<ul>
<li>註冊&#x2F;登入帳戶</li>
<li>登出帳戶</li>
<li>用戶是否已登入</li>
</ul>
<p>那麼，我們可以編寫一個 <code>Authenticator</code> 介面，包含這些描象功能，再在實質的類別中實現相關程式碼。</p>
<div class="note info simple"><p>因為 <code>signOut()</code>（登出帳戶）及 <code>isSignedIn()</code>（判斷用戶是否已登入）的功能實現方式一樣，所以它們會作為預設程式碼，至於 <code>signUp()</code>（註冊新帳戶） 及 <code>signIn()</code>（登入現有帳戶）的程式碼<strong>視乎不同的登入方式而決定</strong>。</p>
</div>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Authenticator</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> auth: FirebaseAuth</span><br><span class="line">        <span class="keyword">get</span>() = Firebase.auth</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">signUp</span><span class="params">()</span></span> = run &#123;  &#125;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">signIn</span><span class="params">()</span></span> = run &#123;  &#125;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">signOut</span><span class="params">()</span></span> = run &#123; auth.signOut() &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isSignedIn</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> = auth.currentUser != <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="電郵地址-x2F-密碼"><a href="#電郵地址-x2F-密碼" class="headerlink" title="電郵地址&#x2F;密碼"></a>電郵地址&#x2F;密碼</h2><p>處理電郵地址&#x2F;密碼的登入方式，我們會新建一個名為 <code>EmailAndPasswordAuthenticator</code> 類別，該類別會繼承 <code>Authenticator</code> 介面，但要求 <code>email</code> 及 <code>password</code> 作為參數。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EmailAndPasswordAuthenticator</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> email: String = <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> password: String = <span class="string">&quot;&quot;</span></span><br><span class="line">) : Authenticator &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">signUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        auth.createUserWithEmailAndPassword(email, password)</span><br><span class="line">            .await()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">signIn</span><span class="params">()</span></span> &#123;</span><br><span class="line">        auth.signInWithEmailAndPassword(email, password)</span><br><span class="line">            .await()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Google-登入"><a href="#Google-登入" class="headerlink" title="Google 登入"></a>Google 登入</h2><p><span class="step" data-step="1" data-title="啟用 Google 登入供應商"></span></p>
<p>你需要在 Firebase Authentication 啟用 Google 登入供應商，方可使用 Google 登入。</p>
<p><span class="step" data-step="2" data-title="獲取並設置網絡用戶端 ID"></span></p>
<p>然後，把網絡用戶端 ID 複製下來。把這個網絡用戶端 ID 貼上到 <code>strings.xml</code>，如命名為 <code>web_client_id</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;web_client_id&quot;</span>&gt;</span>XXX<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/post/jetpack-compose-firebase-auth-notes/img12.png" alt="把網絡用戶端 ID 複製下來"></p>
<p>我們同樣編寫一個 <code>GoogleAuthenticator</code> 類別，但 Google 登入提供了兩種登入方式，所以除了使用介面提供的 <code>signIn()</code> 抽象函數，還需要額外使用 <code>oneTapSignIn()</code> 函數。</p>
<p>在這個類別，我們會<strong>要求兩種供不同活動合約使用的啟動器，因為兩種登入方式使用的啟動器並不一樣</strong>，分別是 <code>legacyLauncher</code> 及 <code>oneTapLauncher</code>，顧名思義，前者是處理普通登入方式的啟動器，後者則處理One Tap方式的啟動器。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GoogleAuthenticator</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> context: Context,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> legacyLauncher: ManagedActivityResultLauncher&lt;Intent, ActivityResult&gt;? = <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> oneTapLauncher: ActivityResultLauncher&lt;IntentSenderRequest&gt;? = <span class="literal">null</span></span><br><span class="line">) : Authenticator &#123;</span><br><span class="line">    <span class="comment">// 實現的程式碼..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="舊版登入"><a href="#舊版登入" class="headerlink" title="舊版登入"></a>舊版登入</h3><div class="note warning simple"><p>雖然官方<strong>不再支援對舊版登入作出往後的更新及維護</strong>，但你仍然可以使用。</p>
</div>

<p>實現這個舊版的 Google 登入方式，我們會新建一個 <code>rememberGoogleSignInLauncher()</code> 可組合函式，該函式會是整個 <code>rememberLauncherForActivityResult()</code> 函式的封裝。</p>
<ul>
<li>啟動器型別：<code>ManagedActivityResultLauncher&lt;Intent, ActivityResult&gt;</code></li>
<li>活動合約：<code>ActivityResultContracts.StartActivityForResult()</code></li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">rememberGoogleSignInLauncher</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    onAuthComplete: ((<span class="type">AuthResult</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    onAuthError: ((<span class="type">ApiException</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: ManagedActivityResultLauncher&lt;Intent, ActivityResult&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> scope = rememberCoroutineScope()</span><br><span class="line">    <span class="keyword">return</span> rememberLauncherForActivityResult(</span><br><span class="line">        contract = ActivityResultContracts.StartActivityForResult(),</span><br><span class="line">        onResult = &#123; result -&gt;</span><br><span class="line">            <span class="keyword">val</span> task = GoogleSignIn.getSignedInAccountFromIntent(result.<span class="keyword">data</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> account = task.getResult(ApiException::<span class="keyword">class</span>.java)!!</span><br><span class="line">                <span class="keyword">val</span> credential = GoogleAuthProvider.getCredential(account.idToken!!, <span class="literal">null</span>)</span><br><span class="line">                scope.launch &#123;</span><br><span class="line">                    <span class="keyword">val</span> authResult = Firebase.auth.signInWithCredential(credential).await()</span><br><span class="line">                    onAuthComplete?.invoke(authResult)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: ApiException) &#123;</span><br><span class="line">                onAuthError?.invoke(e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至於 <code>signIn()</code> 函數的程式碼，會用 <code>GoogleSignInOptions</code> 進行登入，並呼喚 <code>legacyLauncher</code> 啟動器。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">signIn</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)</span><br><span class="line">        .requestIdToken(context.getString(R.string.web_client_id))</span><br><span class="line">        .requestEmail()</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">val</span> googleSignInClient = GoogleSignIn.getClient(context, gso)</span><br><span class="line"></span><br><span class="line">    legacyLauncher?.launch(googleSignInClient.signInIntent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是一個點擊登入按鈕後進行舊版登入的使用範例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> scope = rememberCoroutineScope()</span><br><span class="line"><span class="keyword">val</span> authenticator = GoogleAuthenticator(</span><br><span class="line">    legacyLauncher = rememberGoogleSignInLauncher()</span><br><span class="line">)</span><br><span class="line">Button(</span><br><span class="line">    onClick = &#123;</span><br><span class="line">        scope.launch &#123;</span><br><span class="line">            authenticator.signIn()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="One-Tap"><a href="#One-Tap" class="headerlink" title="One Tap"></a>One Tap</h3><p>而 One Tap 方式是依賴 Google 新推出的 <a href="https://developers.google.com/identity">Identity API</a>，基本上現在大部分網頁、應用程式都已經改用 One Tap。</p>
<ul>
<li>啟動器型別：<code>ActivityResultLauncher&lt;IntentSenderRequest&gt;</code></li>
<li>活動合約：<code>ActivityResultContracts.StartIntentSenderForResult()</code></li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><img src="/post/jetpack-compose-firebase-auth-notes/img14.png" alt="One Tap"></td>
<td><img src="/post/jetpack-compose-firebase-auth-notes/img15.jpeg" alt="One Tap（確認）"></td>
<td><img src="/post/jetpack-compose-firebase-auth-notes/img16.jpeg" alt="One Tap（登入中）"></td>
</tr>
</tbody></table>
<p>我們會同樣編寫一個 <code>rememberGoogleOneTapSignInLauncher()</code> 可組合函式。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">rememberGoogleOneTapSignInLauncher</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">/* TODO */</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: ActivityResultLauncher&lt;IntentSenderRequest&gt; &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這個 <code>oneTapSignIn()</code> <strong>不屬於 <code>Authenticator</code> 介面提供的抽象函數</strong>，但是它是 Google 的另類登入方式，所以會在 <code>GoogleAuthenticator</code> 額外定義。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">oneTapSignIn</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info simple"><p>因技術性錯誤，暫時無法提供完整程式碼。</p>
</div>

<h2 id="Facebook-登入"><a href="#Facebook-登入" class="headerlink" title="Facebook 登入"></a>Facebook 登入</h2><p>除了常見的 Google 登入，使用 Facebook 登入都是一個經常支援的平台，在 Android 開發，我們需要<strong>構建 Facebook 開發應用程式</strong>，配合 <strong>Facebook SDK 軟件開發工具包</strong>實現 Facebook 登入程序。</p>
<p><span class="step" data-step="1" data-title="建立 Facebook 開發應用程式"></span></p>
<p>首先，你需要前往 <a href="https://developers.facebook.com/">Facebook 開發人員中心</a>，建立一個新的 Facebook 開發應用程式，並選擇「使用 Facebook 登入，驗證用戶並向他們索取資料」選項。</p>
<p><img src="/post/jetpack-compose-firebase-auth-notes/img7.png" alt="建立新的開發應用程式"></p>
<p>你需要設置 Facebook 開發應用程式的名稱，例如沿用 Android 應用程式名稱 <code>ComposeFirebase</code>。</p>
<p><img src="/post/jetpack-compose-firebase-auth-notes/img8.png" alt="完成開發應用程式的設置"></p>
<p><span class="step" data-step="2" data-title="連接應用程式編號及密鑰"></span></p>
<p>現在，你需要在 Firebase Authentication 啟用 Facebook 登入供應商，並從剛創建的 Facebook 開發應用程式中，複製應用程式 ID 及應用程式密鑰，把它們貼上到 Firebase 的相應位置。</p>
<div class="note info simple"><p>應用程式密鑰需要先按「顯示」，再進行複製。</p>
</div>

<p><img src="/post/jetpack-compose-firebase-auth-notes/img10.png" alt="複製應用程式編號及應用程式密鑰"></p>
<p><span class="step" data-step="3" data-title="設置 OAuth 重新導向 URI"></span></p>
<p>你需要把 Firebase 提供的 OAuth 重新導向 URI 設置於 Facebook 的開發應用程式設定內。</p>
<p><img src="/post/jetpack-compose-firebase-auth-notes/img9.png" alt="Firebase 提供的 OAuth 重新導向 URI"></p>
<p>請於該開發應用程式的 Facebook 登入設定中，設置有效的 OAuth 重新導向 URI。</p>
<p><img src="/post/jetpack-compose-firebase-auth-notes/img11.png" alt="貼上 OAuth 重新導向 URI"></p>
<p><span class="step" data-step="4" data-title="匯入 Facebook SDK 軟體開發套件"></span></p>
<p>你需要匯入 Facebook SDK 軟體開發套件方可使用 Facebook 登入實現的 API 程式碼。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation(<span class="string">&quot;com.facebook.android:facebook-android-sdk:16.0.0&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><span class="step" data-step="5" data-title="宣告 Facebook 元數據"></span></p>
<p>接着，在 <code>AndroidManifest.xml</code> 的 <code>&lt;application&gt;</code> 區塊內宣告 Facebook 元數據設定。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;com.facebook.sdk.ApplicationId&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:value</span>=<span class="string">&quot;@string/facebook_app_id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;com.facebook.sdk.ClientToken&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:value</span>=<span class="string">&quot;@string/facebook_client_token&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<div class="note info simple"><p>你需要把 Facebook 開發<strong>應用程式的 ID</strong> 及<strong>用戶端憑證</strong>複製下來，並貼上到 <code>strings.xml</code> 作為字串資源。</p>
<p>請到開發應用程式的進階設定中，於安全性區域複製用戶端憑證。</p>
<p><img src="/post/jetpack-compose-firebase-auth-notes/img18.png" alt="複製用戶端憑證"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;facebook_app_id&quot;</span>&gt;</span>XXX<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;client_token&quot;</span>&gt;</span>XXX<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><span class="step" data-step="6" data-title="設置金鑰雜湊"></span></p>
<p>你需要獲取應用程式的金鑰雜湊，在偵錯模式 (debug mode) 中，我們可以透過以下程式碼獲取金鑰雜湊。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    PackageInfo info = getPackageManager().getPackageInfo(getPackageName() , PackageManager.GET_SIGNATURES);</span><br><span class="line">    <span class="keyword">for</span>(Signature signature:info.signatures)&#123;</span><br><span class="line">        MessageDigest md = MessageDigest.getInstance(<span class="string">&quot;SHA&quot;</span>);</span><br><span class="line">        md.update(signature.toByteArray());</span><br><span class="line">        Log.i(<span class="string">&quot;Signature&quot;</span>, Base64.encodeToString(md.digest(), Base64.DEFAULT));<span class="comment">// &lt;--- signature</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然後在開發應用程式的基本設定中，選擇 Android，加入一個應用程式商店，例如使用 Google Play 商店，並把金鑰雜湊設置。</p>
<p><img src="/post/jetpack-compose-firebase-auth-notes/img20.png" alt="設置金鑰雜湊"></p>
<p><span class="step" data-step="7" data-title="啟用電郵地址的權限"></span></p>
<p>在使用案例中，新增 <code>email</code> 權限。</p>
<p><img src="/post/jetpack-compose-firebase-auth-notes/img19.png" alt="新增 email 權限"></p>
<h3 id="使用-Facebook-的-LoginButton-組件"><a href="#使用-Facebook-的-LoginButton-組件" class="headerlink" title="使用 Facebook 的 LoginButton 組件"></a>使用 Facebook 的 <code>LoginButton</code> 組件</h3><p>顧名思義，這個是 Facebook 軟體開發套件提供的 Facebook 登入按鈕組件，它不僅只是一個按鈕，更是<strong>擁有 Facebook 登入回調的程序處理</strong>。目前，<code>LoginButton</code> 只支援 XML 佈局使用，我們需要配合 <code>AndroidView</code> 來應用於 Jetpack Compose。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">AndroidView(</span><br><span class="line">    factory = &#123; context -&gt;</span><br><span class="line">        LoginButton(context).apply &#123;</span><br><span class="line">            <span class="comment">// 實現的程式碼..</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<div class="note danger simple"><p>如果沒有完成 Facebook SDK 所有配置，<code>LoginButton</code> 不會顯示任何文字！<br>如果完成了，若用戶尚未登入，則顯示「繼續使用 Facebook 登入」，若已登入，則顯示「登出」。</p>
</div>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">AndroidView(</span><br><span class="line">    factory = &#123; context -&gt;</span><br><span class="line">        LoginButton(context).apply &#123;</span><br><span class="line">            <span class="keyword">val</span> callbackManager = CallbackManager.Factory.create()</span><br><span class="line">            setPermissions(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;public_profile&quot;</span>)</span><br><span class="line">            registerCallback(callbackManager, <span class="keyword">object</span> : FacebookCallback&lt;LoginResult&gt; &#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCancel</span><span class="params">()</span></span> &#123;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(error: <span class="type">FacebookException</span>)</span></span> &#123;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(result: <span class="type">LoginResult</span>)</span></span> &#123;</span><br><span class="line">                    scope.launch &#123;</span><br><span class="line">                        <span class="keyword">val</span> token = result.accessToken.token</span><br><span class="line">                        <span class="keyword">val</span> credential = FacebookAuthProvider.getCredential(token)</span><br><span class="line">                        <span class="keyword">val</span> authResult = Firebase.auth.signInWithCredential(credential).await()</span><br><span class="line">                        <span class="keyword">if</span> (authResult.user != <span class="literal">null</span>) &#123;</span><br><span class="line">                            </span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Could not sign in with Firebase&quot;</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>LoginButton</code> 會為你實現登入及登出功能。</p>
<h3 id="使用-Authenticator-介面"><a href="#使用-Authenticator-介面" class="headerlink" title="使用 Authenticator 介面"></a>使用 <code>Authenticator</code> 介面</h3><p>但是以上程式碼並非使用我們所使用的 <code>Authenticator</code> 介面，實際上如果不使用 <code>LoginButton</code> 來實現 Facebook 登入是絕對可行的。<strong>Facebook 登入程式背後都是使用啟動器的</strong>。 </p>
<ul>
<li>啟動器型別：<code>ManagedActivityResultLauncher&lt;Collection&lt;String&gt;, CallbackManager.ActivityResultParameters&gt;</code></li>
<li>活動合約：無特定類別，需要以函數獲取。</li>
</ul>
<p>一如既往，編寫 <code>FacebookAuthenticator</code> 類別，接受一個 <code>launcher</code> 參數。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FacebookAuthenticator</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> launcher: ManagedActivityResultLauncher&lt;Collection&lt;String&gt;, CallbackManager.ActivityResultParameters&gt;? = <span class="literal">null</span></span><br><span class="line">) : Authenticator &#123;</span><br><span class="line">    <span class="comment">// 實現的程式碼..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是 <code>rememberFacebookSignInLauncher()</code> 可組合函式實現程式碼。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">rememberFacebookSignInLauncher</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    onAuthComplete: ((<span class="type">AuthResult</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    onAuthError: ((<span class="type">Exception</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: ManagedActivityResultLauncher&lt;Collection&lt;String&gt;, CallbackManager.ActivityResultParameters&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> loginManager = LoginManager.getInstance()</span><br><span class="line">    <span class="keyword">val</span> callbackManager = remember &#123;</span><br><span class="line">        CallbackManager.Factory.create()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 獲取的活動合約</span></span><br><span class="line">    <span class="keyword">val</span> contract = loginManager.createLogInActivityResultContract(callbackManager, <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">val</span> scope = rememberCoroutineScope()</span><br><span class="line"></span><br><span class="line">    DisposableEffect(<span class="built_in">Unit</span>) &#123;</span><br><span class="line">        loginManager.registerCallback(callbackManager, <span class="keyword">object</span> : FacebookCallback&lt;LoginResult&gt; &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCancel</span><span class="params">()</span></span> &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(error: <span class="type">FacebookException</span>)</span></span> &#123;</span><br><span class="line">                onAuthError?.invoke(error)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(result: <span class="type">LoginResult</span>)</span></span> &#123;</span><br><span class="line">                scope.launch &#123;</span><br><span class="line">                    <span class="keyword">val</span> token = result.accessToken.token</span><br><span class="line">                    <span class="keyword">val</span> credential = FacebookAuthProvider.getCredential(token)</span><br><span class="line">                    <span class="keyword">val</span> authResult = Firebase.auth.signInWithCredential(credential).await()</span><br><span class="line">                    <span class="keyword">if</span> (authResult.user != <span class="literal">null</span>) &#123;</span><br><span class="line">                        onAuthComplete?.invoke(authResult)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        onAuthError?.invoke(IllegalStateException(<span class="string">&quot;Unable to sign in with Facebook&quot;</span>))</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        onDispose &#123;</span><br><span class="line">            loginManager.unregisterCallback(callbackManager)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rememberLauncherForActivityResult(</span><br><span class="line">        contract = contract,</span><br><span class="line">        onResult = &#123;</span><br><span class="line">            <span class="comment">// 不需要執行任何程式碼，因為會在 FacebookCallback 執行</span></span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至於執行登入程序很簡單，直接呼喚這個 <code>launcher</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">signIn</span><span class="params">()</span></span> &#123;</span><br><span class="line">    launcher?.launch(listOf(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;public_profile&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Github-登入"><a href="#Github-登入" class="headerlink" title="Github 登入"></a>Github 登入</h2><p>通常，一些屬於技術性或編程的應用程式，都會支援 Github 登入，因為支援 Github 登入，意味着用戶可以與其他 Github 開放源碼有所聯繫。例如編寫一個整合開發環境 IDE 應用程式，你需要允許用戶以 Github 帳戶登入，方能執行相關檔案及存儲庫處理。</p>
<p><span class="step" data-step="1" data-title="建立 Github 開發應用程式"></span></p>
<p>啟用 Github 登入供應商，並前往<a href="https://github.com/settings/applications/new">開發人員設定</a>建立一個 Github 開發應用程式。裏面的 Homepage URL 和 Authorization callback URL 都是輸入 Firebase 提供的授權回呼網址。</p>
<p><img src="/post/jetpack-compose-firebase-auth-notes/img21.png" alt="建立應用程式"></p>
<p><span class="step" data-step="2" data-title="設置 Client ID 及 Client secrets"></span></p>
<p>建立完成後，把 Client ID 及 Client secrets 複製下來。</p>
<p><img src="/post/jetpack-compose-firebase-auth-notes/img22.png" alt="複製 Client ID 及 Client secrets"></p>
<p>再把它們設置到 Firebase 的相應位置。</p>
<p><img src="/post/jetpack-compose-firebase-auth-notes/img23.png" alt="設置 Client ID 及 Client secrets"></p>
<div class="note info simple"><p>因技術性錯誤，暫時無法提供完整程式碼。</p>
</div>]]></content>
      <categories>
        <category>Android</category>
        <category>Jetpack Compose</category>
        <category>Firebase</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>【Jetpack Compose】Firebase Realtime Database 及 Firebase Cloud Firestore 初階級與企業級的資料庫整合</title>
    <url>/post/jetpack-compose-firebase-realtime-database-and-cloud-firestore-notes.html</url>
    <content><![CDATA[<p>Firebase 提供了兩種資料庫建構，每一個資料庫建構的特性都不同：</p>
<ul>
<li>Realtime Database 即時資料庫：是一個較為初階級的資料庫，透過使用 <strong>JSON 樹結構方式</strong>儲存及顯示資料，並且<strong>即時更新資料的變化</strong>。</li>
<li>Cloud Firestore 雲端存儲庫：是一個媲美 Realtime Database 更強大的資料庫，提供<strong>更多查詢功能</strong>，利用集合及欄位儲存及顯示資料，從而掌握資料的關聯性。</li>
</ul>
<p>雖然，大部分的開發者都紛紛遷移到使用 Cloud Firestore，但是 Google 至今並沒提及有關 Realtime Database 退役的消息，因此，大家可以根據情況，選用合適的資料庫建構。</p>
<p>未創建 Firebase 專案的請先看這篇文章：</p>
<div calss="anzhiyu-tag-link"><a class="tag-Link" target="_blank" href="/post/android-firebase-setup-notes">
    <div class="tag-link-tips">引用站外地址</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style>
          <i class="anzhiyufont anzhiyu-icon-link" style></i>
        </div>
        <div class="tag-link-right">
            <div class="tag-link-title">Firebase 專案配置</div>
            <div class="tag-link-sitename"> 看這篇文章瞭解如何配置 Firebase 專案</div>
        </div>
        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>
    </div>
    </a></div>

<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Realtime Database</th>
<th align="center">Cloud Firestore Database</th>
</tr>
</thead>
<tbody><tr>
<td align="center">使用目的</td>
<td align="center">基本查詢同步資料</td>
<td align="center">高級查詢、排序和事務</td>
</tr>
<tr>
<td align="center">資料結構</td>
<td align="center">簡單的 JSON 樹</td>
<td align="center">文檔整理為集合</td>
</tr>
<tr>
<td align="center">資料庫用量</td>
<td align="center">經常發生更改的幾 GB 或更少的資料</td>
<td align="center">大小為數百 GB 到 TB，且讀取頻率比更改頻率高得多的資料</td>
</tr>
<tr>
<td align="center">可用性需求</td>
<td align="center">保證正常運行時間至少達到 99.95%</td>
<td align="center">99.999% 的極高正常運行時間保證</td>
</tr>
<tr>
<td align="center">資料庫實例數</td>
<td align="center">一個或許多</td>
<td align="center">一個</td>
</tr>
<tr>
<td align="center">在無法連接的設備上執行查詢的頻率</td>
<td align="center">極少或從不</td>
<td align="center">頻繁、極少或從不</td>
</tr>
</tbody></table>
<p>遷移至 Cloud Firestore 後，你可以使用以下功能，並留意以下細項：</p>
<ul>
<li>增加了集合 (Collection) 概念。資料庫的根 (Root) 為多個集合，每個集合可裝載多個文件 (Document)，每個文件實體中也可包含集合。</li>
<li>支援了更多資料型別，比如：<code>object</code>、<code>array</code>、<code>geopoint</code>、<code>reference</code>。其中 <code>reference</code> 可指定到特定節點的文件實體。</li>
<li>可自定義索引 (index)，亦支援多鍵索引。可以簡易做到混合 (compound) 的排序 (sorting) 和條件過濾 (filtering)。</li>
</ul>
<hr>
<h1 id="初始化資料庫"><a href="#初始化資料庫" class="headerlink" title="初始化資料庫"></a>初始化資料庫</h1><p><span class="step" data-step="1" data-title="匯入函式庫"></span></p>
<p>首先，你需要匯入資料庫建構功能模組，請按情況選用適用的資料庫。</p>
<div class="tabs" id="code-import-database-lib"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="code-import-database-lib-1">Realtime Database</button><button type="button" class="tab " data-href="code-import-database-lib-2">Cloud Firestore</button></ul><div class="tab-contents"><div class="tab-item-content active" id="code-import-database-lib-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation(<span class="string">&quot;com.google.firebase:firebase-database&quot;</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="code-import-database-lib-2"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation(<span class="string">&quot;com.google.firebase:firebase-firestore&quot;</span>)</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>

<p><span class="step" data-step="2" data-title="啟用並建立資料庫"></span></p>
<p>然後，請到 Firebase 主控台啟用資料庫建構，並且建立資料庫。</p>
<p><span class="step" data-step="3" data-title="選擇資料庫存放位置"></span></p>
<p>根據你所位於的地區，選擇較為合適的地區作為資料庫存放的位置。</p>
<div class="note info simple"><p>小摘錄：</p>
<ul>
<li>Realtime Database：這裏推薦選擇美國 (us-central1)。</li>
<li>Cloud Firestore：支援的地區更廣泛，不需要特別有推薦。</li>
</ul>
</div>

<p><span class="step" data-step="4" data-title="設定安全性規則"></span></p>
<p>我們需要設定安全性規則，安全性規則是一個用來保護資料庫的機制，限制存取權限。</p>
<p>先暫時選擇任一模式，然後更新安全性規則。</p>
<div class="tabs" id="code-secure-rules"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="code-secure-rules-1">Realtime Database</button><button type="button" class="tab " data-href="code-secure-rules-2">Cloud Firestore</button></ul><div class="tab-contents"><div class="tab-item-content active" id="code-secure-rules-1"><p>在使用 Realtime Database 定義保護規則時，需要使用 JSON 語言進行編製。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;.write&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;.read&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="code-secure-rules-2"><p>在使用 Cloud Firestore 定義保護規則時，需要使用安全規則語言，即是 CEL (Common Expression Language) 語言進行編製，其中：</p>
<ul>
<li><code>rules_version</code>：是聲明規則版本，預設是 <code>2</code></li>
<li><code>match /databases/{database}/documents</code>：是聲明該資料庫內所有文件都受到以下的許可權<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rules_version = &#x27;2&#x27;;</span><br><span class="line"></span><br><span class="line">service cloud.firestore &#123;</span><br><span class="line">  match /databases/&#123;database&#125;/documents &#123;</span><br><span class="line">    match /&#123;document=**&#125; &#123;</span><br><span class="line">      allow read, write: if true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>

<div class="note danger simple"><p>當你正式使用資料庫時，你需要編寫更嚴格的安全性規則，把讀取 (<code>read</code>) 及寫入 (<code>write</code>) 權限長期設置為 <code>true</code> 相當危險，<strong>以上安全性規則僅作測試用途！</strong></p>
</div>

<hr>
<h1 id="預備要儲存的資料組"><a href="#預備要儲存的資料組" class="headerlink" title="預備要儲存的資料組"></a>預備要儲存的資料組</h1><p>接下來，為了方便往後編寫程式碼，我<strong>高度建議你編寫數據類作為要儲存的資料組</strong>。</p>
<p><span class="step" data-step="1" data-title="建立數據類"></span></p>
<p>我們會建立一個數據類，把用戶可提供的資料以一個數據類包裝起來。該資料組包含可用資料見下方。</p>
<p>由用戶自行提供的資料：</p>
<ul>
<li>筆記的標題：設有一個輸入框，供用戶設置標題</li>
<li>筆記的內文：設有一個輸入框，供用戶撰寫內容</li>
</ul>
<p>由系統自動生成的資料：</p>
<ul>
<li>建立筆記的作者：這個取決於所登入的帳戶，從而獲取其顯示名稱</li>
<li>建立筆記的作者的帳號 UID：同上，獲取其 UID</li>
</ul>
<div class="tabs" id="code-note"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="code-note-1">數據類</button><button type="button" class="tab " data-href="code-note-2">狀態容器</button></ul><div class="tab-contents"><div class="tab-item-content active" id="code-note-1"><p>因此，我們會就以上情況，把可用資料編製成資料組。</p>
<div class="note danger simple"><p>當你要讀取資料庫的資料，你需要<strong>宣告一個空建構式</strong>，否則會報錯，所以建議一開始就把它事先寫好。<br>提提你：空建構式需要滿足參數數量 (有多少個 <code>null</code>)，是取決於這個數據類的屬性 (有預設值除外) 數量。</p>
</div>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Note</span>(</span><br><span class="line">    <span class="keyword">val</span> author: String?,</span><br><span class="line">    <span class="keyword">val</span> authorUid: String?,</span><br><span class="line">    <span class="keyword">val</span> title: String?,</span><br><span class="line">    <span class="keyword">val</span> content: String?</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="code-note-2"><p>這個是用於獲取目前筆記的狀態，其中的 <code>clear()</code> 函數把 <code>title</code> 及 <code>content</code> 的狀態清空。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">NoteState</span>(</span><br><span class="line">    <span class="keyword">val</span> id: MutableState&lt;String&gt;? = mutableStateOf(<span class="string">&quot;&quot;</span>),</span><br><span class="line">    <span class="keyword">val</span> title: MutableState&lt;String&gt;? = mutableStateOf(<span class="string">&quot;&quot;</span>),</span><br><span class="line">    <span class="keyword">val</span> content: MutableState&lt;String&gt;? = mutableStateOf(<span class="string">&quot;&quot;</span>),</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">        title?.value = <span class="string">&quot;&quot;</span></span><br><span class="line">        content?.value = <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>

<p><span class="step" data-step="2" data-title="宣告 NoteState 狀態"></span></p>
<p>我們會需要用到這個 <code>NoteState</code> 狀態獲取筆記的重要資料。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> state = remember &#123; NoteState() &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="資料的增刪查改"><a href="#資料的增刪查改" class="headerlink" title="資料的增刪查改"></a>資料的增刪查改</h1><p>接下來，我們將會瞭解到如何使用 Realtime Database 或 Cloud Firestore 為資料進行增刪查改的程序。</p>
<p>先簡單釐清資料庫結構及筆記的資料結構，例如，如果新增並儲存了三筆筆記，資料結構長這樣的：</p>
<div class="tabs" id="code-data-structure"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="code-data-structure-1">Realtime Database</button></ul><div class="tab-contents"><div class="tab-item-content active" id="code-data-structure-1"><p>在 Realtime Database，它採用了 JSON 結構樹顯示資料，因此，我們大概想像的結果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">資料庫</span><br><span class="line">└── notes (筆記根位置)</span><br><span class="line">    ├── 1 (筆記的 ID)</span><br><span class="line">    │   ├── title: Note 1</span><br><span class="line">    │   └── content: Content 1</span><br><span class="line">    ├── 2 (筆記的 ID)</span><br><span class="line">    │   ├── title: Note 2</span><br><span class="line">    │   └── content: Content 2</span><br><span class="line">    └── 3 (筆記的 ID)</span><br><span class="line">        ├── title: Note 3</span><br><span class="line">        └── content: Content 3</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>

<p>為了方便編寫程式碼，以下是簡化程式碼的常用變量及常量：</p>
<div class="tabs" id="code-common-variables"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="code-common-variables-1">Realtime Database</button><button type="button" class="tab " data-href="code-common-variables-2">Cloud Firestore</button></ul><div class="tab-contents"><div class="tab-item-content active" id="code-common-variables-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> rdbDatabase: FirebaseDatabase = Firebase.database</span><br><span class="line"><span class="keyword">val</span> rdbReference: DatabaseReference = Firebase.database.reference</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="code-common-variables-2"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> fdbDatabase: FirebaseFirestore = Firebase.firestore</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> authUser: FirebaseUser? = Firebase.auth.currentUser</span><br><span class="line"></span><br><span class="line"><span class="comment">// 筆記根位置</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> ROOT_PATH = <span class="string">&quot;notes&quot;</span></span><br></pre></td></tr></table></figure>

<div class="note info simple"><p>若在使用身份驗證，請在進行增刪查改程序前，加上 <code>authUser?.run</code> 區塊。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">authUser?.run &#123;</span><br><span class="line">  <span class="comment">// 增刪查改程式碼..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="新增資料"><a href="#新增資料" class="headerlink" title="新增資料"></a>新增資料</h2><p>現在，我們會編寫新增及儲存資料的程式碼，要注意的是我們需要<strong>附加一個用於辨識筆記的獨一無二的 ID</strong>，我們可以使用 <code>UUID.randomUUID()</code> 程式碼獲取隨機的 UUID 作為獨一無二的 ID。<strong>如果不附上獨一無二的 ID，筆記的資料無法被正確辨識，其資料或會被取代！</strong></p>
<div class="tabs" id="code-save-data"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="code-save-data-1">Realtime Database</button><button type="button" class="tab " data-href="code-save-data-2">Cloud Firestore</button></ul><div class="tab-contents"><div class="tab-item-content active" id="code-save-data-1"><p>我們會透過 <code>DatabaseReference</code>，然後使用 <code>child()</code> 從參照進行追蹤，<strong>最後一個 <code>child()</code> 就是最終儲存的位置</strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">rdbReference</span><br><span class="line">    .child(ROOT_PATH)</span><br><span class="line">    .child(UUID.randomUUID().toString())</span><br><span class="line">    .setValue(value)</span><br></pre></td></tr></table></figure>

<p>完成後，你可以在 Realtime Database 檢視剛新增的資料。<br><img src="/post/jetpack-compose-firebase-realtime-database-and-cloud-firestore-notes/img1.png" alt="Realtime Database 資料庫"></p></div><div class="tab-item-content" id="code-save-data-2"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">fdbDatabase</span><br><span class="line">    .collection(ROOT_PATH)</span><br><span class="line">    .document()</span><br><span class="line">    .<span class="keyword">set</span>(value)</span><br></pre></td></tr></table></figure>
<p>完成後，你可以在 Cloud Firestore 檢視剛新增的資料。<br><img src="/post/jetpack-compose-firebase-realtime-database-and-cloud-firestore-notes/img2.png" alt="Cloud Firestore 資料庫"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>

<h2 id="刪除資料"><a href="#刪除資料" class="headerlink" title="刪除資料"></a>刪除資料</h2><p>既然可以新增資料，那麼必須要有刪除資料的功能，才有完整的體驗。在這個範例，我們會利用筆記的 ID 來刪除該資料。</p>
<div class="tabs" id="code-delete-data"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="code-delete-data-1">Realtime Database</button><button type="button" class="tab " data-href="code-delete-data-2">Cloud Firestore</button></ul><div class="tab-contents"><div class="tab-item-content active" id="code-delete-data-1"><p>與新增資料相似，但<strong>這次的 <code>child()</code> 最終參照位置是取決於所提供的筆記 ID</strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">rdbReference</span><br><span class="line">    .child(ROOT_PATH)</span><br><span class="line">    .child(id)</span><br><span class="line">    .removeValue()</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="code-delete-data-2"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">fdbDatabase</span><br><span class="line">    .collection(ROOT_PATH)</span><br><span class="line">    .document(id)</span><br><span class="line">    .delete()</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>

<h2 id="修改資料"><a href="#修改資料" class="headerlink" title="修改資料"></a>修改資料</h2><p>有時候，用戶可能會在筆記上撰寫了錯誤的資訊，總不能把它移除再寫，因此這個編輯功能相當重要，亦是用於提升用戶體驗元素之一。</p>
<p>例如，用戶想編輯該筆記的內容，實際方案如下：</p>
<div class="tabs" id="code-edit-data"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="code-edit-data-1">Realtime Database</button></ul><div class="tab-contents"><div class="tab-item-content active" id="code-edit-data-1"><p>同樣追蹤參照，<strong>這回的 <code>child()</code> 最終參照位置是取決於所編輯的資料值</strong>，如 <code>content</code>，並在 <code>setValue()</code> 提供新的值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">rdbReference</span><br><span class="line">    .child(ROOT_PATH)</span><br><span class="line">    .child(id)</span><br><span class="line">    .child(content)</span><br><span class="line">    .setValue(newValue)</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>

<h2 id="讀取資料"><a href="#讀取資料" class="headerlink" title="讀取資料"></a>讀取資料</h2><p>我們可以使用兩種方式讀取資料庫內的資料：</p>
<ul>
<li>一次性讀取：從資料庫中<strong>讀取一次資料</strong>，讀取後資料<strong>不會被自動更新</strong>。</li>
<li>持續性讀取：在資料庫<strong>設置監聽器</strong>，當資料有更新及有變化時，就會觸發監聽器，從而<strong>追蹤到資料的更新</strong>，使應用程式介面都能即時更新資訊。</li>
</ul>
<div class="tabs" id="code-read-data"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="code-read-data-1">Realtime Database</button><button type="button" class="tab " data-href="code-read-data-2">Cloud Firestore</button></ul><div class="tab-contents"><div class="tab-item-content active" id="code-read-data-1"><p>因為 <code>Note</code> 是一個數據類 <code>data class</code>，在 Kotlin 及 Java 的 Getter Setter，我們需要使用 <code>GenericTypeIndicator</code> 宣告泛型數據源。宣告範例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> typeIndicator = <span class="keyword">object</span> : GenericTypeIndicator&lt;Note&gt;() &#123;&#125;</span><br></pre></td></tr></table></figure>

<div class="tabs" id="code-rdb-read-data"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="code-rdb-read-data-1">一次性讀取</button><button type="button" class="tab " data-href="code-rdb-read-data-2">持續性讀取</button></ul><div class="tab-contents"><div class="tab-item-content active" id="code-rdb-read-data-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">rdbReference</span><br><span class="line">    .child(ROOT_PATH)</span><br><span class="line">    .<span class="keyword">get</span>().apply &#123;</span><br><span class="line">        addOnSuccessListener &#123; snapshot -&gt;</span><br><span class="line">            <span class="keyword">val</span> <span class="keyword">data</span> = snapshot.getValue(typeIndicator)</span><br><span class="line">            <span class="comment">// 使用 data 變量來讀取資料</span></span><br><span class="line">        &#125;</span><br><span class="line">        addOnFailureListener &#123; error -&gt;</span><br><span class="line">            <span class="comment">// 讀取資料時發生錯誤</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="code-rdb-read-data-2"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">rdbReference</span><br><span class="line">    .child(ROOT_PATH)</span><br><span class="line">    .addValueEventListener(<span class="keyword">object</span> : ValueEventListener &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDataChange</span><span class="params">(snapshot: <span class="type">DataSnapshot</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">val</span> <span class="keyword">data</span> = snapshot.getValue(typeIndicator)</span><br><span class="line">            <span class="comment">// 使用 data 變量來讀取資料</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCancelled</span><span class="params">(error: <span class="type">DatabaseError</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 讀取資料時發生錯誤</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div></div><div class="tab-item-content" id="code-read-data-2"><p>因為 <code>Note</code> 是一個數據類 <code>data class</code>，在 Kotlin 及 Java 的 Getter Setter，我們需要使用 <code>toObjects()</code> 把資料組宣告為一個列表，然後再使用 <code>forEach</code> 函數獲取每一項資料。</p>
<div class="tabs" id="code-fdb-read-data"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="code-fdb-read-data-1">一次性讀取</button><button type="button" class="tab " data-href="code-fdb-read-data-2">持續性讀取</button></ul><div class="tab-contents"><div class="tab-item-content active" id="code-fdb-read-data-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">fdbDatabase</span><br><span class="line">    .collection(ROOT_PATH)</span><br><span class="line">    .<span class="keyword">get</span>().apply &#123;</span><br><span class="line">        addOnSuccessListener &#123; snapshot -&gt;</span><br><span class="line">            <span class="keyword">val</span> list = snapshot?.toObjects(Note::<span class="keyword">class</span>.java)</span><br><span class="line">            list?.forEach &#123; <span class="keyword">data</span> -&gt;</span><br><span class="line">                <span class="comment">// 使用 data 參數來讀取資料</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addOnFailureListener &#123; error -&gt;</span><br><span class="line">            <span class="comment">// 讀取資料時發生錯誤</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="code-fdb-read-data-2"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">fdbDatabase</span><br><span class="line">    .collection(ROOT_PATH)</span><br><span class="line">    .addSnapshotListener &#123; snapshot, error -&gt;</span><br><span class="line">        <span class="keyword">if</span> (error != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 讀取資料時發生錯誤</span></span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@addSnapshotListener</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> list = snapshot?.toObjects(Note::<span class="keyword">class</span>.java)</span><br><span class="line">        list?.forEach &#123; <span class="keyword">data</span> -&gt;</span><br><span class="line">            <span class="comment">// 使用 data 參數來讀取資料</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>

<h3 id="遍歷資料"><a href="#遍歷資料" class="headerlink" title="遍歷資料"></a>遍歷資料</h3><p>你或許會想使用 <code>LazyColumn</code> 遍歷並顯示所有筆記的資料，以下是參考方案：</p>
<p><span class="step" data-step="1" data-title="宣告一個可變列表"></span></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list: SnapshotStateList&lt;Pair&lt;String?, Note?&gt;?&gt; = mutableStateListOf()</span><br></pre></td></tr></table></figure>

<p><span class="step" data-step="2" data-title="在獲取資料時更新列表"></span></p>
<p>在獲取資料成功部分的程式碼中，加入以下程式碼：</p>
<div class="tabs" id="code-list-data"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="code-list-data-1">Realtime Database</button></ul><div class="tab-contents"><div class="tab-item-content active" id="code-list-data-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">list.clear()</span><br><span class="line"><span class="keyword">for</span> (childSnapshot <span class="keyword">in</span> snapshot.children) &#123;</span><br><span class="line">    <span class="keyword">val</span> id = childSnapshot.key                        <span class="comment">// 獲取子節點的 ID</span></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = childSnapshot.getValue(typeIndicator)  <span class="comment">// 獲取子節點的資料組</span></span><br><span class="line">    list.add(Pair(id, <span class="keyword">data</span>))                          <span class="comment">// 將 ID 和資料組成一個 Pair 並加入列表</span></span><br><span class="line">    <span class="comment">// 其他程式碼..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>

<p><span class="step" data-step="3" data-title="完成 LazyColumn 程序"></span></p>
<p>這裏傳出的 <code>data</code> 參數屬於 <code>Pair</code> 型別，當你要獲取資料組，你需要使用 <code>data?.second</code> 獲取。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">LazyColumn &#123;</span><br><span class="line">  itemsIndexed(list) &#123; index, <span class="keyword">data</span> -&gt;</span><br><span class="line">    <span class="keyword">val</span> id = <span class="keyword">data</span>?.first.toString()</span><br><span class="line">    <span class="keyword">val</span> note = <span class="keyword">data</span>?.second</span><br><span class="line">    <span class="comment">// 其他程式碼..</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
        <category>Jetpack Compose</category>
        <category>Firebase</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>【Jetpack Compose】免費使用的 Google 翻譯 API | 實作簡易翻譯應用程式</title>
    <url>/post/jetpack-compose-free-google-translate-api-app-no-api-key.html</url>
    <content><![CDATA[<p>相信大家都使用過 Google 翻譯，它是將文字翻譯成另一種語言的文字的服務。而作為開發者的我們，除了使用 Google 翻譯服務，亦會想把這個服務加入到應用程式中。</p>
<p>但問題是，<strong>Google 翻譯是需要註冊 Google Cloud 服務的，而這個服務需要付費</strong>，有見於此，我們會採用另一種 RESTful API 方式使用 Google 翻譯服務，在這個範例中，我們會使用 Okhttp3 函式庫進行 API 請求。</p>
<hr>
<h2 id="項目初始配置"><a href="#項目初始配置" class="headerlink" title="項目初始配置"></a>項目初始配置</h2><p><span class="step" data-step="1" data-title="允許網絡權限"></span></p>
<p>你需要在 <code>AndroidManifest.xml</code> 設置網絡許可權，因為我們<strong>需要透過從網絡請求 API 通訊，獲取回應</strong>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><span class="step" data-step="2" data-title="匯入 Okhttp3 函式庫"></span></p>
<p>你有許多方法請求 API，這個範例中，我們會使用 Okhttp3 函式庫。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation(<span class="string">&quot;com.squareup.okhttp3:okhttp:4.12.0&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="宣告翻譯介面使用的狀態"><a href="#宣告翻譯介面使用的狀態" class="headerlink" title="宣告翻譯介面使用的狀態"></a>宣告翻譯介面使用的狀態</h2><p>接下來，我們需要宣告一個狀態容器，把翻譯介面要輸入值的狀態封裝到狀態容器。</p>
<p>在這個 <code>TranslationState</code> 狀態容器，需要以下狀態值：</p>
<ul>
<li>原文語言：用戶所輸入原文的對應語言代碼，如果要自動偵測，則設置為 <code>auto</code></li>
<li>目標語言：用戶要把原文翻譯的指定語言</li>
<li>原文內容：用戶所輸入的原文</li>
<li>翻譯結果：經過 Google 翻譯 API 所得出的翻譯結果</li>
</ul>
<p>因此，我們得出以下程式碼：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">TranslationState</span>(</span><br><span class="line">    <span class="keyword">val</span> originalLanguage: MutableState&lt;String&gt; = mutableStateOf(<span class="string">&quot;&quot;</span>),</span><br><span class="line">    <span class="keyword">val</span> targetLanguage: MutableState&lt;String&gt; = mutableStateOf(<span class="string">&quot;&quot;</span>),</span><br><span class="line">    <span class="keyword">val</span> originalText: MutableState&lt;String&gt; = mutableStateOf(<span class="string">&quot;&quot;</span>),</span><br><span class="line">    <span class="keyword">val</span> translatedText: MutableState&lt;String&gt; = mutableStateOf(<span class="string">&quot;&quot;</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>以上所有狀態值都只是使用 <code>mutableStateOf()</code> 宣告，並無為 Compose 作出重組及介面更新，我們可以直接使用 <code>remember</code> 函式把整個 <code>TranslationState</code> 封裝起來。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">rememberTranslationState</span><span class="params">()</span></span> = remember &#123;</span><br><span class="line">    TranslationState()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="開始請求-Google-翻譯-API-並獲取結果"><a href="#開始請求-Google-翻譯-API-並獲取結果" class="headerlink" title="開始請求 Google 翻譯 API 並獲取結果"></a>開始請求 Google 翻譯 API 並獲取結果</h1><p>現在，我們會使用 Okhttp3 編寫程式碼，向網絡請求 Google 翻譯 API，並把翻譯結果顯示於介面。在這個 Google 翻譯 API，只會使用 GET 請求方式，所以以下程式碼只為 GET 請求方式編寫。</p>
<p><span class="step" data-step="1" data-title="宣告 OkHttpClient"></span></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> client = OkHttpClient().newBuilder().build()</span><br></pre></td></tr></table></figure>

<p><span class="step" data-step="2" data-title="宣告 Request.Builder"></span></p>
<p>在這個 API 鏈接，你需要傳入以下查詢參數：</p>
<table>
<thead>
<tr>
<th>參數名稱</th>
<th>參數描述</th>
<th>參數值例子</th>
</tr>
</thead>
<tbody><tr>
<td><code>client</code></td>
<td></td>
<td><code>gtx</code></td>
</tr>
<tr>
<td><code>sl</code></td>
<td>原文的語言代碼</td>
<td><code>en</code></td>
</tr>
<tr>
<td><code>tl</code></td>
<td>目標的語言代碼</td>
<td><code>zh-tw</code></td>
</tr>
<tr>
<td><code>dt</code></td>
<td></td>
<td><code>t</code></td>
</tr>
<tr>
<td><code>q</code></td>
<td>原文內容（要翻譯的文本）</td>
<td><code>Hello, World!</code></td>
</tr>
</tbody></table>
<p>請自行完成 <code>TextField</code> 程式碼處理，並成功連繫 <code>TranslationState</code> 的 <code>originalLanguage</code>、<code>targetLanguage</code> 及 <code>originalText</code> 狀態，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">TextField(</span><br><span class="line">    value = state.originalText.value,</span><br><span class="line">    onValueChange = &#123;</span><br><span class="line">        state.originalText.value = it</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>完成後，我們需要使用以上三個狀態，作為 API 鏈接的查詢參數。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> originalLanguage = state.originalLanguage.value</span><br><span class="line"><span class="keyword">val</span> targetLanguage = state.targetLanguage.value</span><br><span class="line"><span class="keyword">val</span> encodeText = URLEncoder.encode(state.originalText.value, <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> url = <span class="string">&quot;https://translate.googleapis.com/translate_a/single?client=gtx&amp;sl=<span class="variable">$originalLanguage</span>&amp;tl=<span class="variable">$targetLanguage</span>&amp;dt=t&amp;q=<span class="variable">$encodeText</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> requestBuilder = Request.Builder().url(url)</span><br></pre></td></tr></table></figure>

<p><span class="step" data-step="3" data-title="呼叫並執行請求程序"></span></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> request = requestBuilder.build()</span><br><span class="line">client.newCall(request).enqueue(<span class="keyword">object</span> : Callback &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>, e: <span class="type">IOException</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 請求失敗時的處理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>, response: <span class="type">Response</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> responseBody = response.body?.string()</span><br><span class="line">        <span class="comment">// 使用 responseBody 變量解析 JSON，取出翻譯結果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果你使用 Postman 或其他工具測試 API，你會得到以下 JSON 結果：</p>
<p><img src="/post/jetpack-compose-free-google-translate-api-app-no-api-key/img1.png" alt="Google 翻譯 API 回應結果"></p>
<p>你會看到我們想要的翻譯結果是在第 4 行，現在我們會從這個 <code>requestBody</code> 解析這個內容出來。</p>
<p><span class="step" data-step="4" data-title="透過回應主體把翻譯結果顯示於介面"></span></p>
<p>在 <code>onResponse()</code> 函式中，加入以下程式碼：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>, response: <span class="type">Response</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> responseBody = response.body?.string()</span><br><span class="line">    state.translatedText.value = JSONArray(responseBody)</span><br><span class="line">        .getJSONArray(<span class="number">0</span>)</span><br><span class="line">        .getJSONArray(<span class="number">0</span>)</span><br><span class="line">        .getString(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在你的 Jetpack Compose 程式中，請將 <code>state.translatedText</code> 連繫至 <code>Text</code>，如下所示。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> state = rememberTranslationState()</span><br><span class="line"></span><br><span class="line">Text(</span><br><span class="line">    text = state.translatedText.value</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
        <category>Jetpack Compose</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>【Jetpack Compose】JGit | KGit | 整合 Git 版本控制至應用程式</title>
    <url>/post/jetpack-compose-jgit-and-commands-notes.html</url>
    <content><![CDATA[<p>在現代軟體開發中，版本控制是一個不可或缺的工具，它可以幫助我們追蹤和管理程式碼的變化。而 Git 是目前最受歡迎的版本控制系統之一。相信編寫員及開發者對它絕對不陌生，甚至耳熟能詳。</p>
<hr>
<h1 id="開始前注意事項"><a href="#開始前注意事項" class="headerlink" title="開始前注意事項"></a>開始前注意事項</h1><ol>
<li>Kotlin 開發者可使用 JGit 或 KGit (使用 Kotlin 語法) 函式庫，而 Java 開發者只可使用 JGit 函式庫。</li>
<li>JGit 版本大小是取決於你的項目所使用的 JDK 版本。</li>
<li>Android 開發在使用 JGit 時，需要注意以下幾點：<ul>
<li>確保 <code>AndroidManifest.xml</code> 聲明權限許可，以及<strong>允許所有檔案權限</strong> (All File Access)，否則報錯 Operation Not Permitted 錯誤。<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.MANAGE_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.ACCESS_NETWORK_STATE&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>進行指令操作，如克隆遠端存儲庫至本機，需要使用<strong>異步執行緒或 <code>Executor</code> 等相關處理方式</strong>，(Kotlin 則可使用協程)，否則會在執行指令時報錯 <code>NetworkOnMainThreadException</code> 錯誤。<div class="tabs" id="code-async-task"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="code-async-task-1">Kotlin</button><button type="button" class="tab " data-href="code-async-task-2">Java</button></ul><div class="tab-contents"><div class="tab-item-content active" id="code-async-task-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">scope.launch &#123;</span><br><span class="line">    withContext(Dispatchers.IO) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="code-async-task-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">executor.execute(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div></li>
</ul>
</li>
</ol>
<hr>
<h1 id="Git-初始配置"><a href="#Git-初始配置" class="headerlink" title="Git 初始配置"></a>Git 初始配置</h1><p><span class="step" data-step="1" data-title="匯入 JGit 函式庫"></span></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JGit - Java / Kotlin</span></span><br><span class="line">implementation(<span class="string">&quot;org.eclipse.jgit:org.eclipse.jgit:6.8.0.202311291450-r&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// KGit - Kotlin</span></span><br><span class="line">implementation(<span class="string">&quot;com.github.sya-ri:kgit:1.0.6&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><span class="step" data-step="2" data-title="宣告 Git 對象"></span></p>
<p>我們需要宣告一個 <code>Git</code> 對象，用來執行及處理版本控制，我們可以透過三個方式建立一個 <code>Git</code> 對象，但是視乎情況而使用。</p>
<h2 id="以初始化形式宣告"><a href="#以初始化形式宣告" class="headerlink" title="以初始化形式宣告"></a>以初始化形式宣告</h2><p>如果目前的<strong>本機存儲庫沒有 <code>.git</code> 資料夾</strong>，則可以使用此方式宣告 <code>Git</code> 對象。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> git = Git.<span class="keyword">init</span>().setDirectory(localRepo).call()</span><br></pre></td></tr></table></figure>

<h2 id="以當前的-git-資料夾宣告"><a href="#以當前的-git-資料夾宣告" class="headerlink" title="以當前的 .git 資料夾宣告"></a>以當前的 <code>.git</code> 資料夾宣告</h2><p>當你的本機存儲庫成功初始化，並產生了 <code>.git</code> 資料夾，你可以透過開啟 <code>.git</code> 資料夾形式，宣告 <code>Git</code> 對象。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> git = Git.<span class="keyword">open</span>(localRepo)</span><br></pre></td></tr></table></figure>

<h2 id="以克隆遠端存儲庫至本機存儲庫來宣告"><a href="#以克隆遠端存儲庫至本機存儲庫來宣告" class="headerlink" title="以克隆遠端存儲庫至本機存儲庫來宣告"></a>以克隆遠端存儲庫至本機存儲庫來宣告</h2><p>你亦可以透過提供要克隆的遠端存儲庫，把其克隆到本機存儲庫，來藉此宣告 <code>Git</code> 對象。</p>
<div class="note danger simple"><p>要克隆的目錄或資料夾<strong>需要被建立及清空</strong>才能順利克隆遠端存儲庫，不清空則報 Directory XXX is not empty 錯誤。</p>
</div>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> remoteRepoUrl = <span class="string">&quot;https://github.com/xxx.git&quot;</span></span><br><span class="line"><span class="keyword">val</span> git = <span class="keyword">if</span> (!localRepo.exists()) &#123;</span><br><span class="line">    localRepo.mkdirs()</span><br><span class="line">    Git.cloneRepository()</span><br><span class="line">        .setBranch(branch)</span><br><span class="line">        .setURI(remoteRepoUrl)</span><br><span class="line">        .setDirectory(localRepo)</span><br><span class="line">        .call()</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Git-版本控制及指令操作"><a href="#Git-版本控制及指令操作" class="headerlink" title="Git 版本控制及指令操作"></a>Git 版本控制及指令操作</h1><p>以下將會展示如何使用 JGit 函式庫實作一系列的 Git 指令操作。</p>
<h2 id="克隆遠端存儲庫至本機存儲庫"><a href="#克隆遠端存儲庫至本機存儲庫" class="headerlink" title="克隆遠端存儲庫至本機存儲庫"></a>克隆遠端存儲庫至本機存儲庫</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Git.cloneRepository()</span><br><span class="line">    .setBranch(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">    .setURI(<span class="string">&quot;https://github.com/xxx.git&quot;</span>)</span><br><span class="line">    .setDirectory(localRepo)</span><br><span class="line">    .call()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
        <category>Jetpack Compose</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>【Jetpack Compose】Android 13 相片挑選工具 API | 舊型裝置向後相容處理</title>
    <url>/post/jetpack-compose-photo-picker-for-android-13.html</url>
    <content><![CDATA[<p>Android 13 的推出以來，有一個 API 功能是對我們作為應用程式開發者來說尤其重要，就是讓用戶能夠從我們的應用程式中選擇要使用的圖像或影像。</p>
<p>等等。。！你可能會問，不是可以使用相冊 (Gallery) 來選擇圖像嗎？沒錯，但這需要向用戶存取檔案權限，而這一個 Android 13 新推出的 Photo Picker API 是<strong>不需要向用戶存取檔案權限的，所以能夠確保並保障資料安全性</strong>。</p>
<table>
<thead>
<tr>
<th>官方演示</th>
<th>單選媒體</th>
<th>多選媒體</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/post/jetpack-compose-photo-picker-for-android-13/img2.gif" alt="相片挑選工具提供直覺易用的使用者介面，方便您與應用程式分享相片"></td>
<td><img src="/post/jetpack-compose-photo-picker-for-android-13/img3.jpeg" alt="單選媒體"></td>
<td><img src="/post/jetpack-compose-photo-picker-for-android-13/img4.jpeg" alt="多選媒體"></td>
</tr>
</tbody></table>
<div calss="anzhiyu-tag-link"><a class="tag-Link" target="_blank" href="https://developer.android.com/training/data-storage/shared/photopicker?hl=zh-tw">
    <div class="tag-link-tips">引用站外地址</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style>
          <i class="anzhiyufont anzhiyu-icon-link" style></i>
        </div>
        <div class="tag-link-right">
            <div class="tag-link-title">Photo Picker API 相片挑選工具</div>
            <div class="tag-link-sitename"> 這裏有關相片挑選工具的官方文案</div>
        </div>
        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>
    </div>
    </a></div>

<p>Android 13 的相片挑選工具特點如下：</p>
<ul>
<li><strong>不需要詢問及允許任何運行時權限</strong></li>
<li>提供更好的 UI 及 UX 介面供用戶選擇媒體</li>
<li>支援從雲端存取的媒體 (<code>CloudMediaProvider</code> API)</li>
<li>支援向後相容，<strong>低版本裝置仍可透過向後移植版本使用</strong></li>
</ul>
<hr>
<h1 id="適當選擇使用相冊或相片挑選工具"><a href="#適當選擇使用相冊或相片挑選工具" class="headerlink" title="適當選擇使用相冊或相片挑選工具"></a>適當選擇使用相冊或相片挑選工具</h1><p>雖然在 Android 13 推出了一個很好用的相片挑選工具，輕鬆選擇圖像，但是<strong>它並不是萬能的</strong>。這裏簡單指出了應在什麼情況，適當選擇使用相冊及照相機 (Gallery &amp; Camera) 和相片挑選工具 (Photo Picker API)。</p>
<table>
<thead>
<tr>
<th align="center">情況</th>
<th align="center">相冊及照相機</th>
<th align="center">相片挑選工具</th>
</tr>
</thead>
<tbody><tr>
<td align="center">從相冊中選擇照片</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
</tr>
<tr>
<td align="center">選擇多張照片</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
</tr>
<tr>
<td align="center">拍攝新照片</td>
<td align="center">✔️</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">詢問及存取檔案權限</td>
<td align="center">✔️</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">設定照片選擇器的選項和行為</td>
<td align="center">❌</td>
<td align="center">✔️</td>
</tr>
</tbody></table>
<hr>
<h1 id="使用相片挑選工具-API"><a href="#使用相片挑選工具-API" class="headerlink" title="使用相片挑選工具 API"></a>使用相片挑選工具 API</h1><p>接下來，我們就會使用相片挑選工具 API 來選擇單張或多張圖片，然後把選擇了的圖片顯示在介面上。</p>
<h2 id="預備一個存放已選擇的圖片-Uri-列表的狀態"><a href="#預備一個存放已選擇的圖片-Uri-列表的狀態" class="headerlink" title="預備一個存放已選擇的圖片 Uri 列表的狀態"></a>預備一個存放已選擇的圖片 <code>Uri</code> 列表的狀態</h2><p>在這個範例中，我們會使用一組可變的 <code>List&lt;Uri?&gt;</code> 存放選擇了的圖片，<strong>預設是沒有選擇任何圖片</strong>，所以初始值為 <code>emptyList()</code>，即為空列表。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> selectedImagesUris = remember &#123;</span><br><span class="line">    mutableStateOf&lt;List&lt;Uri?&gt;&gt;(emptyList())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info simple"><p>如果你只是想實現選擇單張圖片，而<strong>沒有選擇多張圖片的必要</strong>，可以直接用 <code>Uri?</code> 作為狀態：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> selectedImageUri = remember &#123; mutableStateOf&lt;Uri?&gt;(<span class="literal">null</span>) &#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="設計一個開啟相片挑選工具的呼叫按鈕"><a href="#設計一個開啟相片挑選工具的呼叫按鈕" class="headerlink" title="設計一個開啟相片挑選工具的呼叫按鈕"></a>設計一個開啟相片挑選工具的呼叫按鈕</h2><p>我們會加入一個按鈕，供用戶開啟相片挑選工具來選擇相片。</p>
<h3 id="實現單選及多選的活動結果合約"><a href="#實現單選及多選的活動結果合約" class="headerlink" title="實現單選及多選的活動結果合約"></a>實現單選及多選的活動結果合約</h3><p>首先，我們會分別為單選及多選編寫 <code>ActivityResultLauncher</code>：</p>
<p>處理單選或多選需要使用不同的 Jetpack Activity 活動結果合約：</p>
<ul>
<li><code>PickVisualMedia</code>：用於選取單一圖片或影片。</li>
<li><code>PickMultipleVisualMedia</code>：用於選取多個圖片或影片。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> singleImageLauncher = rememberLauncherForActivityResult(</span><br><span class="line">    contract = ActivityResultContracts.PickVisualMedia(),</span><br><span class="line">    onResult = &#123; uri -&gt;</span><br><span class="line">        selectedImagesUris.value = listOf(uri)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">val</span> multipleImagesLauncher = rememberLauncherForActivityResult(</span><br><span class="line">    contract = ActivityResultContracts.PickMultipleVisualMedia(</span><br><span class="line">        maxItems = <span class="keyword">if</span> (maxSelectionCount &gt; <span class="number">1</span>) maxSelectionCount <span class="keyword">else</span> <span class="number">2</span></span><br><span class="line">    ),</span><br><span class="line">    onResult = &#123; uris -&gt;</span><br><span class="line">        selectedImagesUris.value = uris</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<div class="note info simple"><p>同樣道理，如果只是實現單選圖片，只需要 <code>singleImageLauncher</code>，而且 <code>onResult</code> 回調中只需執行：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">selectedImageUri.value = uri</span><br></pre></td></tr></table></figure></div>

<h3 id="根據情況呼叫相應-ActivityResultLauncher"><a href="#根據情況呼叫相應-ActivityResultLauncher" class="headerlink" title="根據情況呼叫相應 ActivityResultLauncher"></a>根據情況呼叫相應 <code>ActivityResultLauncher</code></h3><p>在這個範例中，我們會靈活使用 <code>maxSelectionCount</code> 變數，來判斷應該要使用單選或多選的行為，可以在可組合項函式內編寫一個 <code>launchImagePicker()</code> 嵌套函式呼叫 <code>ActivityResultLauncher</code> 。</p>
<div class="note info simple"><p>設置 <code>PickVisualMedia.ImageOnly</code> 僅允許用戶選擇圖像。</p>
</div>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">launchImagePicker</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> mediaType = ActivityResultContracts.PickVisualMedia.ImageOnly,</span><br><span class="line">    <span class="keyword">if</span> (maxSelectionCount &gt; <span class="number">1</span>)</span><br><span class="line">        multipleImagesLauncher.launch(PickVisualMediaRequest(mediaType))</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        singleImageLauncher.launch(PickVisualMediaRequest(mediaType))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完成按鈕視覺佈局"><a href="#完成按鈕視覺佈局" class="headerlink" title="完成按鈕視覺佈局"></a>完成按鈕視覺佈局</h3><p>把 <code>launchImagePicker()</code> 嵌套函式作為 <code>Button</code> 的點擊事件處理，並根據 <code>maxSelectionCount</code> 動態化處理選擇圖片數量的文字描述。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Button(</span><br><span class="line">    onClick = &#123;</span><br><span class="line">        launchImagePicker()</span><br><span class="line">    &#125;,</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">val</span> flag = <span class="keyword">if</span> (maxSelectionCount &gt; <span class="number">1</span>) <span class="string">&quot;<span class="variable">$maxSelectionCount</span> images&quot;</span></span><br><span class="line">        <span class="keyword">else</span> <span class="string">&quot;1 image&quot;</span></span><br><span class="line">    Text(text = <span class="string">&quot;Select <span class="variable">$flag</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="顯示已選擇圖片的-LazyColumn-列表"><a href="#顯示已選擇圖片的-LazyColumn-列表" class="headerlink" title="顯示已選擇圖片的 LazyColumn 列表"></a>顯示已選擇圖片的 <code>LazyColumn</code> 列表</h2><p>首先，由於相片挑選工具都屬於一個 <code>ActivityResultLauncher</code>，意昧着回傳的結果都是 <code>Uri</code>，而 Jetpack Compose 是<strong>無法根據 <code>Uri</code> 來顯示相應圖像</strong>的，這個時候就要使用 Coil 庫進行異步圖像載入。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation(<span class="string">&quot;io.coil-kt:coil-compose:2.5.0&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>我們會使用 Coil 函式庫提供的 <code>ImageRequest.Builder</code> 定義要使用的 <code>model</code>，並傳入已選擇圖片的 <code>Uri</code> 作為資料來源，再使用 <code>rememberAsyncImagePainter</code> 來異步載入圖片。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">LazyColumn(</span><br><span class="line">    modifier = Modifier.fillMaxSize(),</span><br><span class="line">    horizontalAlignment = Alignment.CenterHorizontally</span><br><span class="line">) &#123;</span><br><span class="line">    itemsIndexed(selectedImagesUris.value) &#123; _, uri -&gt;</span><br><span class="line">        <span class="keyword">val</span> model = ImageRequest.Builder(LocalContext.current)</span><br><span class="line">            .<span class="keyword">data</span>(uri)</span><br><span class="line">            .size(Size.ORIGINAL)</span><br><span class="line">            .crossfade(<span class="literal">true</span>)</span><br><span class="line">            .build()</span><br><span class="line">        Image(</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .fillMaxWidth()</span><br><span class="line">                .padding(vertical = <span class="number">8.</span>dp),</span><br><span class="line">            painter = rememberAsyncImagePainter(model = model),</span><br><span class="line">            contentDescription = <span class="literal">null</span>,</span><br><span class="line">            contentScale = ContentScale.FillWidth</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info simple"><p>Coil 函式庫亦提供了 <code>AsyncImage</code> 可組合項，這個方式亦可處理異步載入：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">AsyncImage(</span><br><span class="line">    model = model,</span><br><span class="line">    contentDescription = <span class="literal">null</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<h2 id="最後介面佈局參考"><a href="#最後介面佈局參考" class="headerlink" title="最後介面佈局參考"></a>最後介面佈局參考</h2><p>這裏是整個介面佈局的參考實作，在 <code>LaunchImagePickerButton</code> 可組合項函式的 <code>maxSelectionCount</code> 參數設置為 <code>4</code>，代表開啟相片挑選工具時，用戶<strong>最多可選擇</strong> 4 張圖片。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MainScreen</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> selectedImagesUris = remember &#123;</span><br><span class="line">        mutableStateOf&lt;List&lt;Uri?&gt;&gt;(emptyList())</span><br><span class="line">    &#125;</span><br><span class="line">    Column(</span><br><span class="line">        modifier = Modifier.fillMaxSize()</span><br><span class="line">    ) &#123;</span><br><span class="line">        LaunchImagePickerButton(</span><br><span class="line">            selectedImagesUris = selectedImagesUris,</span><br><span class="line">            maxSelectionCount = <span class="number">4</span></span><br><span class="line">        )</span><br><span class="line">        ImageList(</span><br><span class="line">            selectedImagesUris = selectedImagesUris</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="舊型裝置向後相容處理"><a href="#舊型裝置向後相容處理" class="headerlink" title="舊型裝置向後相容處理"></a>舊型裝置向後相容處理</h1><p>使用相片挑選工具的裝置必須要至少 Android 11 以上版本，如果要進行向後相容 (backward compatibility)，兼容低版本 (<strong>最低僅至到 Android 4.4 版本</strong>) 的裝置，有兩種方案：</p>
<ol>
<li>不支援相片挑選工具的裝置，預設會使用系統內置的檔案選擇器，選擇型別為 <code>ACTION_OPEN_DOCUMENT</code>，選擇任一媒體檔案。</li>
<li>為舊型裝置<strong>自動安裝</strong>相片挑選工具的向後移植版本，在 <code>AndroidManifest.xml</code> 的 <code>&lt;application&gt;</code> 加上 <code>ModuleDependencies</code>，讓系統為應用程式從外部安裝相片挑選工具的模塊：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Trigger Google Play services to install the backported photo picker module. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">&quot;com.google.android.gms.metadata.ModuleDependencies&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:enabled</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">tools:ignore</span>=<span class="string">&quot;MissingClass&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.google.android.gms.metadata.MODULE_DEPENDENCIES&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;photopicker_activity:0:required&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<div class="note info simple"><p>搭載 Android 4.4 (API 級別 19) 至 Android 10 (API 級別 29) 版本的舊型裝置，以及搭載 Android 11 或 12 版本且支援 Google Play 服務的 Android Go 裝置，皆可安裝相片挑選工具的向後移植版本。</p>
</div>

<hr>
<h1 id="根據圖像的調色盤進行樣式化"><a href="#根據圖像的調色盤進行樣式化" class="headerlink" title="根據圖像的調色盤進行樣式化"></a>根據圖像的調色盤進行樣式化</h1><p>如果你覺得選擇了的圖像，該圖像的色調，與應用程式的樣式風格格格不入，可以使用 Palette API 來<strong>根據圖像來獲取一系列的調色</strong>。首先需要匯入 Palette API 庫：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation(<span class="string">&quot;androidx.palette:palette-ktx:1.0.0&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>定義一個獲取調色盤的狀態，稍後用來擷取該調色盤執行個體的顏色設定檔。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> palette = remember &#123; mutableStateOf&lt;Palette?&gt;(<span class="literal">null</span>) &#125;</span><br></pre></td></tr></table></figure>

<p>更新 <code>singleImageLauncher</code> 的 <code>onResult</code> 回調，根據所選擇圖像來生成一個調色盤，把調色盤執行個體存放到 <code>palette</code> 狀態。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> inputStream = uri?.let &#123;</span><br><span class="line">    context.contentResolver.openInputStream(it)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> bitmap = BitmapFactory.decodeStream(inputStream)</span><br><span class="line">palette.value = Palette.from(bitmap).generate()</span><br></pre></td></tr></table></figure>

<div class="note info simple"><p>如果你想都支援 <code>multipleImageLauncher</code>，那麼你<strong>就要決定使用哪一張圖片來生成調色盤</strong>，比如，使用第一張圖片：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> inputStream = uris?.first()?.let &#123;</span><br><span class="line">    context.contentResolver.openInputStream(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="可用的顏色設定檔"><a href="#可用的顏色設定檔" class="headerlink" title="可用的顏色設定檔"></a>可用的顏色設定檔</h2><table>
<thead>
<tr>
<th>顏色設定檔</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Dominant Swatch（主要色彩）</td>
<td>調色盤中最主要的顏色，代表整個圖像的主要色彩。</td>
</tr>
<tr>
<td>Vibrant Swatch（活躍色彩）</td>
<td>調色盤中最活躍且飽和的顏色，通常是一個鮮豔的色彩。</td>
</tr>
<tr>
<td>Light Vibrant Swatch（淺色活躍色彩）</td>
<td>調色盤中較為淺色且活躍的顏色。</td>
</tr>
<tr>
<td>Dark Vibrant Swatch（深色活躍色彩）</td>
<td>調色盤中較為深色且活躍的顏色。</td>
</tr>
<tr>
<td>Muted Swatch（柔和色彩）</td>
<td>調色盤中較為柔和和淡化的顏色。</td>
</tr>
<tr>
<td>Light Muted Swatch（淺色柔和色彩）</td>
<td>調色盤中較為淺色且柔和的顏色。</td>
</tr>
<tr>
<td>Dark Muted Swatch（深色柔和色彩）</td>
<td>調色盤中較為深色且柔和的顏色。</td>
</tr>
</tbody></table>
<p>每個顏色設定檔都可以獲取其 <code>rgb</code>、<code>hsl</code>、<code>titleTextColor</code> 及 <code>bodyTextColor</code> 屬性。</p>
<p><img src="/post/jetpack-compose-photo-picker-for-android-13/img1.png" alt="指定調色盤預設色彩數量上限 (16) 的範例圖片及其擷取的色彩設定檔"></p>
<div class="note warning simple"><p>要注意的是，<strong>並非每一張圖片都能擁有及擷取以上所有顏色設定檔</strong>。</p>
</div>

<p>例如，我們可以為 <code>Button</code> 根據圖片的調色盤而使用的顏色。</p>
<ul>
<li><code>containerColor</code>：使用 <code>darkVibrantSwatch</code> 的 <code>rgb</code> 顏色值</li>
<li><code>contentColor</code>：使用 <code>darkVibrantSwatch</code> 的 <code>bodyTextColor</code> 顏色值</li>
</ul>
<p>如果沒有選擇圖像，預設的容器顏色 <code>containerColor</code> 及內容顏色 <code>contentColor</code> 分別會沿用預設的 Primary 及 OnPrimary 色彩。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> containerColor = palette.value?.darkVibrantSwatch?.let &#123;</span><br><span class="line">    Color(it.rgb)</span><br><span class="line">&#125; ?: MaterialTheme.colorScheme.primary</span><br><span class="line"><span class="keyword">val</span> contentColor = palette.value?.darkVibrantSwatch?.let &#123;</span><br><span class="line">    Color(it.bodyTextColor)</span><br><span class="line">&#125; ?: MaterialTheme.colorScheme.onPrimary</span><br><span class="line"></span><br><span class="line">Button(</span><br><span class="line">    onClick = &#123;</span><br><span class="line">        launchImagePicker()</span><br><span class="line">    &#125;,</span><br><span class="line">    colors = ButtonDefaults.buttonColors(</span><br><span class="line">        containerColor = containerColor,</span><br><span class="line">        contentColor = contentColor</span><br><span class="line">    )</span><br><span class="line">) &#123; ... &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
        <category>Jetpack Compose</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
</search>
