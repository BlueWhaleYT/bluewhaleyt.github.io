<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android 開發 | Jetbrains 研發的 Dokka API 文檔</title>
    <url>/post/android-dev-jetbrains-dokka.html</url>
    <content><![CDATA[<p>一起來科普一下，什麼是人類。</p>
<blockquote>
<p>人類就是抱怨人家不做某件事情，但當自己「理應」要做的時候，自己卻不想做。</p>
</blockquote>
<p>情況就正如我們都會吐嘈開發者不寫文案，那當自己開發了一些函式庫等工具程式碼，自己卻不想寫文案，一來花時間，二來太麻煩。</p>
<p>有見於此，親愛的 JetBrains 團隊開發了 Dokka，這個自動生成 API 文檔的系統，<strong>可以姑且解決「不想寫文案」的煩惱</strong>。</p>
<hr>
<h1 id="開始使用"><a href="#開始使用" class="headerlink" title="開始使用"></a>開始使用</h1><h2 id="引入-Dokka"><a href="#引入-Dokka" class="headerlink" title="引入 Dokka"></a>引入 Dokka</h2><ol>
<li><p>在根目錄 <code>build.gradle.kts</code> 的 <code>buildscripts</code> 區塊引入 <code>classpath</code> 配置檔</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">buildscript &#123;
    dependencies &#123;
        classpath(&quot;org.jetbrains.dokka:dokka-gradle-plugin:1.8.20&quot;)
        classpath(&quot;org.jetbrains.dokka:dokka-base:1.8.20&quot;)
    &#125;
&#125;</code></pre></li>
<li><p>在根目錄 <code>build.gradle.kts</code> 的 <code>plugins</code> 區塊引入 <code>org.jetbrains.dokka</code> 插件</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">&#x2F;&#x2F; Top-level build file where you can add configuration options common to all sub-projects&#x2F;modules.
@Suppress(&quot;DSL_SCOPE_VIOLATION&quot;) &#x2F;&#x2F; TODO: Remove once KTIJ-19369 is fixed
plugins &#123;
    ...
    id(&quot;org.jetbrains.dokka&quot;) version &quot;1.8.20&quot;
&#125;
true &#x2F;&#x2F; Needed to make the Suppress annotation work for the plugins block</code></pre>
</li>
<li><p>在模塊，如 <code>app</code> 的 <code>build.gradle.kts</code> 引入插件。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Suppress(&quot;DSL_SCOPE_VIOLATION&quot;) &#x2F;&#x2F; TODO: Remove once KTIJ-19369 is fixed
plugins &#123;
    ...
    id(&quot;org.jetbrains.dokka&quot;)
&#125;</code></pre></li>
</ol>
<h2 id="編寫文檔"><a href="#編寫文檔" class="headerlink" title="編寫文檔"></a>編寫文檔</h2><p>要寫的文檔會在程式的 Javadoc 或 Kdoc 註解標記編寫，例如現在寫一個 <code>Person</code> 類：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">&#x2F;**
 * Person
 *
 * @constructor Create empty Person
 *&#x2F;
class Person &#123;

    &#x2F;**
     * Set age
     *
     * @param age
     *&#x2F;
    fun setAge(age: Int) &#123;
        &#x2F;&#x2F; ...
    &#125;

    &#x2F;**
     * Set name
     *
     * @param name
     *&#x2F;
    fun setName(name: String) &#123;
        &#x2F;&#x2F; ...
    &#125;
&#125;</code></pre>

<h2 id="執行文檔"><a href="#執行文檔" class="headerlink" title="執行文檔"></a>執行文檔</h2><ul>
<li><code>./gradlew dokkaHtml</code> - 執行單個模塊的文檔</li>
<li><code>./gradlew dokkaHtmlMultiModule</code> - 執行所有模塊的文檔</li>
</ul>
<p>效果是這樣：</p>
<p><img src="https://i.imgur.com/LP6quDG.png" alt="Dokka preview"></p>
<hr>
<h1 id="附加插件"><a href="#附加插件" class="headerlink" title="附加插件"></a>附加插件</h1><p>Dokka 官方提供了一些插件：</p>
<ul>
<li><code>dokka-base</code></li>
<li><code>gfm-plugin</code></li>
<li><code>jekyll-plugin</code></li>
<li><code>javadoc-plugin</code></li>
<li><code>kotlin-as-java-plugin</code></li>
<li><code>android-documentation-plugin</code></li>
</ul>
<h2 id="kotlin-as-java-plugin-插件"><a href="#kotlin-as-java-plugin-插件" class="headerlink" title="kotlin-as-java-plugin 插件"></a><code>kotlin-as-java-plugin</code> 插件</h2><p><code>kotlin-as-java-plugin</code> 是主要把 Kotlin 的語法轉換為 Java 語法，即是把整個文檔以 Java 語法形式表示。</p>
<ol>
<li><p>在根目錄的 <code>build.gradle.kts</code> 中的 <code>buildscript</code> 區塊引入 <code>classpath</code> 配置檔：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">classpath(&quot;org.jetbrains.dokka:kotlin-as-java-plugin:1.8.20&quot;)</code></pre>
</li>
<li><p>在模塊的 <code>build.gradle.kts</code> 引入依賴：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">dependencies &#123;
    dokkaPlugin(&quot;org.jetbrains.dokka:kotlin-as-java-plugin:1.8.20&quot;)
&#125;</code></pre></li>
</ol>
]]></content>
      <categories>
        <category>程式編寫</category>
        <category>Android 開發</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能的圖像生成 - Stable Diffusion</title>
    <url>/post/ai-image-generation-stable-diffusion.html</url>
    <content><![CDATA[<p>在現今世代，人們除了善用 ChatGPT 的即時對話生成工具，還會藉著咒語 (Prompt) 生成圖像，，而要用到這個強大的圖像生成技術，便可使用 Stable Diffusion。</p>
<hr>
<h1 id="神奇的文轉圖黑魔法"><a href="#神奇的文轉圖黑魔法" class="headerlink" title="神奇的文轉圖黑魔法"></a>神奇的文轉圖黑魔法</h1><p>這個黑魔法就是剛才略略提及的 Stable Diffusion，它是一款深度學習文字到圖像的圖像生成模型，簡而言之，一個<strong>藉著所提供的文字敍述轉換所得的圖像</strong>，不但如此，它還支援進階特性操作，使其有別具一樹的實用價值。</p>
<hr>
<h1 id="黑魔法的秘笈"><a href="#黑魔法的秘笈" class="headerlink" title="黑魔法的秘笈"></a>黑魔法的秘笈</h1><h2 id="咒語-Prompt"><a href="#咒語-Prompt" class="headerlink" title="咒語 (Prompt)"></a>咒語 (Prompt)</h2><p>咒語 (Prompt) 就是你要透過文字的敍述，最後所得的圖像，要注意的是，<strong>不同模型所用的咒語都略有不同</strong>。關鍵是輸入關鍵字，如果該關鍵字支援目前所用的模型，便能夠得到預期效果，我個人喜歡使用 <a href="https://civitai.com/">Civitai</a> 來找找模型。</p>
<h3 id="使用咒語的撇步"><a href="#使用咒語的撇步" class="headerlink" title="使用咒語的撇步"></a>使用咒語的撇步</h3><ol>
<li>關鍵分割：利用 <code>,</code> 可以決定關鍵字的權重，優次為高至低，如 <code>girl, beautiful</code></li>
<li>通用的敍述格式：分為三個主要部分<br>  第一部分（前置設定）：說明使用的畫風、畫質、鏡頭、光照效果等圖像技術規格<br>  第二部分（主體設定）：說明人物、服裝、姿勢、道具等對該人員或對象的要求<br>  第三部分（後置設定）：說明人物置身的環境以及細節</li>
<li>調整權重：利用 <code>(</code> <code>)</code> 標點符號搭配 <code>xxx: 0.x</code> 語法可以為特定物件調整權重，如 <code>(details: 1.0)</code></li>
<li>選用 LoRA 或超網絡模型：透明 <code>&lt;</code> <code>&gt;</code> 標點符號, 語法分別為 <code>&lt;lora:xxx&gt;</code> 及 <code>&lt;hypernet:xxx&gt;</code>，選用合適的 LoRA 模型可以為圖像進行微調，好比一個小型的插件，通過<strong>交叉關注圖層</strong> (cross-attention layer) 從而影響最終的圖像生成結果，LoRA 模型可找找 <a href="https://civitai.com/">Civitai</a>。</li>
</ol>
<h3 id="優質的咒語"><a href="#優質的咒語" class="headerlink" title="優質的咒語"></a>優質的咒語</h3><h4 id="提高圖像質素的咒語"><a href="#提高圖像質素的咒語" class="headerlink" title="提高圖像質素的咒語"></a>提高圖像質素的咒語</h4><table>
<thead>
<tr>
<th>咒語</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>HDR, UHD, 4K, 8K</td>
<td>不同的解像度說明</td>
</tr>
<tr>
<td>best quality</td>
<td>最佳的質素</td>
</tr>
<tr>
<td>masterpiece</td>
<td>傑作</td>
</tr>
<tr>
<td>highly detailed</td>
<td>繪製更多細節</td>
</tr>
<tr>
<td>studio lighting</td>
<td>加入演播室的燈光效果，為圖像加入漂亮的紋理</td>
</tr>
<tr>
<td>ultra-fine painting</td>
<td>超精細的繪圖</td>
</tr>
<tr>
<td>sharp focus</td>
<td>聚焦清晰</td>
</tr>
<tr>
<td>physically-based rendering</td>
<td>基於物理渲染</td>
</tr>
<tr>
<td>extreme detail description</td>
<td>極度詳細的刻劃</td>
</tr>
<tr>
<td>Professional</td>
<td>改善圖像的色彩對比及細節</td>
</tr>
<tr>
<td>Vivid Colors</td>
<td>加入鮮艷的顏色，增添活力的色彩</td>
</tr>
<tr>
<td>Bokeh</td>
<td>虛化模糊背景，從而突出主體或人物</td>
</tr>
<tr>
<td>(EOS R8, 50mm, F1.2, 8K, RAW photo:1.2)</td>
<td>攝影師對圖像的攝像機的攝製規格</td>
</tr>
</tbody></table>
<h4 id="選用不同藝術風格的咒語"><a href="#選用不同藝術風格的咒語" class="headerlink" title="選用不同藝術風格的咒語"></a>選用不同藝術風格的咒語</h4><table>
<thead>
<tr>
<th>咒語</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Portraits</td>
<td>肖像畫</td>
</tr>
<tr>
<td>Landscape</td>
<td>風景畫</td>
</tr>
<tr>
<td>Horror</td>
<td>恐怖畫</td>
</tr>
<tr>
<td>Anime</td>
<td>動漫畫</td>
</tr>
<tr>
<td>Sci-fi</td>
<td>科幻畫</td>
</tr>
<tr>
<td>Photography</td>
<td>攝影畫</td>
</tr>
<tr>
<td>Concept artists (video game)</td>
<td>概念藝術（電玩及遊戲）</td>
</tr>
</tbody></table>
<h2 id="負面咒語-Negative-Prompt"><a href="#負面咒語-Negative-Prompt" class="headerlink" title="負面咒語 (Negative Prompt)"></a>負面咒語 (Negative Prompt)</h2><p><strong>負面咒語</strong> (Negative Prompt)，當中的 <code>Negative</code>，顧名思義就是負面的意思，所以負面咒語是用來<strong>避免或阻止圖像所得的元素及特性</strong>。</p>
<p>常用的負面咒語如下：</p>
<table>
<thead>
<tr>
<th>負面咒語</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>mutated hands and fingers</td>
<td>變異的手和手指</td>
</tr>
<tr>
<td>deformed</td>
<td>畸形的</td>
</tr>
<tr>
<td>bad anatomy</td>
<td>人體解剖不良</td>
</tr>
<tr>
<td>disfigured</td>
<td>毁容的</td>
</tr>
<tr>
<td>poorly drawn face</td>
<td>臉部繪製不良</td>
</tr>
<tr>
<td>mutated</td>
<td>變異的</td>
</tr>
<tr>
<td>extra limb</td>
<td>多餘的肢體</td>
</tr>
<tr>
<td>ugly</td>
<td>醜陋</td>
</tr>
<tr>
<td>poorly drawn hands</td>
<td>手部繪製不良</td>
</tr>
<tr>
<td>missing limb</td>
<td>缺少的肢體</td>
</tr>
<tr>
<td>floating limbs</td>
<td>漂浮的肢體</td>
</tr>
<tr>
<td>disconnected limbs</td>
<td>肢體不連貫</td>
</tr>
<tr>
<td>malformed hands</td>
<td>畸形的手</td>
</tr>
<tr>
<td>out of focus</td>
<td>脫離焦點</td>
</tr>
<tr>
<td>long neck</td>
<td>長頸</td>
</tr>
<tr>
<td>long body</td>
<td>長的身軀</td>
</tr>
</tbody></table>
<p>這個是我在用的負面咒語，順便展示一下用法：</p>
<pre class="line-numbers language-none"><code class="language-none">(painting by bad-artist-anime:0.9), (painting by bad-artist:0.9), watermark, text, error, blurry, 
jpeg artifacts, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, 
watermark, username, artist name, (worst quality, low quality:1.4), bad anatomy</code></pre>

<details class="folding-tag"><summary> 讓我們來問 ChatGPT 解說這些負面咒語的作用。 </summary>
              <div class="content">
              <table><thead><tr><th>負面咒語</th><th>描述</th></tr></thead><tbody><tr><td><code>(painting by bad-artist-anime:0.9)</code></td><td>指的是由一位不太擅長繪畫的動漫畫家創作的畫作，故意將其評級為 <code>0.9</code> 以顯示其較差的質量水平。</td></tr><tr><td><code>(painting by bad-artist:0.9)</code></td><td>同樣是指由一位不太擅長繪畫的藝術家創作的畫作，同樣評級為 <code>0.9</code> 以表示其質量較差。</td></tr><tr><td><code>watermark</code></td><td></td></tr><tr><td><code>text</code></td><td>指的是圖像中的文字元素，這可能會干擾圖像的視覺效果或專注點。</td></tr><tr><td><code>error</code></td><td>指的是圖像中的錯誤或瑕疵，這可能會降低圖像的品質或可觀賞性。</td></tr><tr><td><code>blurry</code></td><td>指的是圖像模糊或不清晰，這可能會影響圖像的可見度或觀賞體驗。</td></tr><tr><td><code>jpeg artifacts</code></td><td>指的是由於壓縮導致的圖像失真或雜訊，這可能會影響圖像的細節或質量。</td></tr><tr><td><code>cropped</code></td><td>指的是圖像被裁剪過，這可能會使圖像缺乏完整性或導致重要元素缺失。</td></tr><tr><td><code>worst quality</code></td><td>指的是圖像的最差質量，暗示圖像可能存在嚴重的問題或瑕疵。</td></tr><tr><td><code>low quality</code></td><td>指的是圖像的低質量，暗示圖像可能存在一些問題或瑕疵。</td></tr><tr><td><code>normal quality</code></td><td>指的是圖像的正常質量，意味著圖像沒有明顯的問題或瑕疵。</td></tr><tr><td><code>signature</code></td><td>指的是圖像上的簽名，這可能會影響圖像的可觀賞性或專注點。</td></tr><tr><td><code>username</code></td><td>指的是圖像上的使用者名稱，這可能會影響圖像的視覺效果或專注點。</td></tr><tr><td><code>artist name</code></td><td>指的是圖像上的藝術家名稱，這可能會影響圖像的可觀賞性或專注點。</td></tr><tr><td><code>(worst quality, low quality:1.4)</code></td><td>指的是質量最差和低質量的圖像組合，以 <code>1.4</code> 倍的權重表示其質量較差。</td></tr><tr><td><code>bad anatomy</code></td><td>指的是圖像中的人體解剖不正確，這可能會影響圖像的真實感或質量。</td></tr></tbody></table>
              </div>
            </details>

<h2 id="取樣方法-Sampler"><a href="#取樣方法-Sampler" class="headerlink" title="取樣方法 (Sampler)"></a>取樣方法 (Sampler)</h2><p>取樣方法 (Sampler) 是 Stable Diffusion 通過內部的複雜數學及科學計算，從而讓圖像的最終生成結果有顯著的差異。</p>
<p>Stable Diffusion 常見的取樣方法有：</p>
<ul>
<li>DDIM</li>
<li>PNDM (PLMS)</li>
<li>Euler</li>
<li>Euler a</li>
<li>Heun</li>
<li>DPM2</li>
<li>DPM2 a</li>
<li>LMS</li>
<li>DPM++ 2M</li>
<li>DPM++ 2M Karras</li>
<li>DPM++ 2M SDE</li>
<li>DPM++ 2M SDE Karras</li>
<li>DPM++ SDE</li>
<li>LMS Karras</li>
</ul>
<p>我最常用的是 Euler 及 DPM2，但根據圖像而有所變動。</p>
<h2 id="隨機種子-Seed"><a href="#隨機種子-Seed" class="headerlink" title="隨機種子 (Seed)"></a>隨機種子 (Seed)</h2><p>隨機種子 (Seed) 是基於 Stable Diffusion 的擴散過程的生成，而為圖像設立的起始的狀態。種子碼是一個隨機數，<strong>不同的種子碼，都會顯著影響最終圖像生成的結果</strong>，即是說，<strong>如果所予的種子碼相同，便可重現特定圖像</strong>，從而藉咒語附加額外元素。</p>
<h2 id="縮放因子-CFG-scale"><a href="#縮放因子-CFG-scale" class="headerlink" title="縮放因子 (CFG scale)"></a>縮放因子 (CFG scale)</h2><p>縮放因子是對生成的圖像所要求的細節程度，縮放因子愈大，生成的圖像將具有更多咒語中描述關鍵字中的要求，從而愈細緻，而愈小只會生成較簡單的圖像。</p>
<!--
## 降噪強度 (Denoising strength)

...
-->

<h2 id="進階操作使用"><a href="#進階操作使用" class="headerlink" title="進階操作使用"></a>進階操作使用</h2><p>雖然 Stable Diffusion 生成的圖像，或會滿足你的心意，但同是或會令你大失所望，主要是可能你所描述的咒語，不足夠概括想要的目的，以致生成的結果與預期不同。這個時候，便可藉著進階操作，嘗試彌補生成後圖像的缺失。</p>
<p>常見的進階操作如下：</p>
<ul>
<li>內補繪製 (Inpaint)：像是 AI 為你修圖，在圖片新增或去除物件。它是透過填充及選取遮罩 (mask) 區域，從而在遮罩部分新增或去除物件。</li>
<li>外補繪製 (Outpaint)</li>
</ul>
<h1 id="推薦使用的圖像生成工具"><a href="#推薦使用的圖像生成工具" class="headerlink" title="推薦使用的圖像生成工具"></a>推薦使用的圖像生成工具</h1><div calss="anzhiyu-tag-link"><a class="tag-Link" target="_blank" href="https://playgroundai.com/canvas/files">
    <div class="tag-link-tips">引用站外地址</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style>
          <i class="anzhiyufont anzhiyu-icon-link" style></i>
        </div>
        <div class="tag-link-right">
            <div class="tag-link-title">Playground AI</div>
            <div class="tag-link-sitename"> 免費使用無限制</div>
        </div>
        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>
    </div>
    </a></div>

<div calss="anzhiyu-tag-link"><a class="tag-Link" target="_blank" href="https://tensor.art/">
    <div class="tag-link-tips">引用站外地址</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style>
          <i class="anzhiyufont anzhiyu-icon-link" style></i>
        </div>
        <div class="tag-link-right">
            <div class="tag-link-title">TensorArt</div>
            <div class="tag-link-sitename"> 每天可獲 100 能量點數，一般設定下，每生成一張圖片需要花費 1 點</div>
        </div>
        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>
    </div>
    </a></div>

<div calss="anzhiyu-tag-link"><a class="tag-Link" target="_blank" href="https://pixai.art/submit">
    <div class="tag-link-tips">引用站外地址</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style>
          <i class="anzhiyufont anzhiyu-icon-link" style></i>
        </div>
        <div class="tag-link-right">
            <div class="tag-link-title">PixAI</div>
            <div class="tag-link-sitename"> 每天可獲 10000 點數，一般設定下，每生成一張圖片需要大概花費多於 1000 點</div>
        </div>
        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>
    </div>
    </a></div>]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
  </entry>
  <entry>
    <title>Android 開發 | Sora Editor 編輯器函式庫</title>
    <url>/post/android-dev-sora-editor-lib-notes.html</url>
    <content><![CDATA[<p>以往如果要寫一個設有語法高亮的文本編輯器，可能會用到基本的正則表達式 (Regex) 配合使用 <code>TextWatcher</code> 來實現。</p>
<details class="folding-tag"><summary> 以往大概實現方式 </summary>
              <div class="content">
              <div class="tabs" id="legacy_way"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="legacy_way-1">Code</button><button type="button" class="tab " data-href="legacy_way-2">Usage</button></ul><div class="tab-contents"><div class="tab-item-content active" id="legacy_way-1"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SyntaxHighlightTextWatcher implements TextWatcher &#123;

    private final EditText editText;
    private final Pattern pattern;
    private final int highlightColor;

    public SyntaxHighlightTextWatcher(EditText editText, String regex, int highlightColor) &#123;
        this.editText &#x3D; editText;
        this.pattern &#x3D; Pattern.compile(regex);
        this.highlightColor &#x3D; highlightColor;
    &#125;

    @Override
    public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123;
    &#125;

    @Override
    public void onTextChanged(CharSequence s, int start, int before, int count) &#123;
    &#125;

    @Override
    public void afterTextChanged(Editable editable) &#123;
        String text &#x3D; editable.toString();

        Spannable spannable &#x3D; Spannable.Factory.getInstance().newSpannable(text);
        Matcher matcher &#x3D; pattern.matcher(text);

        while (matcher.find()) &#123;
            int matchStart &#x3D; matcher.start();
            int matchEnd &#x3D; matcher.end();
            spannable.setSpan(new ForegroundColorSpan(highlightColor), matchStart, matchEnd, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
        &#125;

        editText.removeTextChangedListener(this);
        editText.setText(spannable);
        editText.setSelection(text.length());
        editText.addTextChangedListener(this);
    &#125;
&#125;</code></pre></div><div class="tab-item-content" id="legacy_way-2"><pre class="line-numbers language-java" data-language="java"><code class="language-java">String regex &#x3D; &quot;(public|protected|private|return|if|else|for|while)&quot;;
int highlightColor &#x3D; getResources().getColor(R.color.highlight_color);
RegexSyntaxHighlightTextWatcher textWatcher &#x3D; new RegexSyntaxHighlightTextWatcher(editText, regex, highlightColor);
editText.addTextChangedListener(textWatcher);</code></pre></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>
              </div>
            </details>

<p>但這樣做太繁複，而且有很多限制，亦都會因為過份地對 <code>EditText</code> 文本進行語法顏色編製，會令到在輸入時不流暢，降低應用程式的效率。所以，這個情況如果改用 Sora Editor 就最好不過了。</p>
<p>Sora Editor 是由 <a href="https://github.com/Rosemoe">Rosemoe</a> 作者開發的一個供 Android 開發的程式使用的代碼編輯器組件，如提供基本的行號顯示、程式診斷輔助指標、乃至可以匯入額外的模塊，如常見的支援語法高亮特性，使整個函式庫生息不少。</p>
<hr>
<h1 id="匯入依賴庫"><a href="#匯入依賴庫" class="headerlink" title="匯入依賴庫"></a>匯入依賴庫</h1><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">dependencies &#123;
    implementation(platform(&quot;io.github.Rosemoe.sora-editor:bom:0.21.1&quot;))
    
    &#x2F;&#x2F; 啟用 Editor 基本模組庫
    implementation(&quot;io.github.Rosemoe.sora-editor:editor&quot;)
    
    &#x2F;&#x2F; 啟用 TextMate 語法高亮模組庫
    implementation(&quot;io.github.Rosemoe.sora-editor:language-textmate&quot;)
    
    &#x2F;&#x2F; 啟用 Java 語言模組庫
    implementation(&quot;io.github.Rosemoe.sora-editor:language-java&quot;)
    
    &#x2F;&#x2F; 其他處於開發階段的試驗性模組庫，有興趣可以使用
    &#x2F;&#x2F; 啟用語言伺服器協定 (LSP) 的 Editor 模組庫
    implementation(&quot;io.github.Rosemoe.sora-editor:editor-lsp&quot;)
    
    &#x2F;&#x2F; 啟用 Tree-Sitter 語法高亮模組庫
    implementation(&quot;io.github.Rosemoe.sora-editor:language-treesitter&quot;)
&#125;</code></pre>

<p>接下來，我會稱 <code>editor</code> 為核心庫，因為這個函式庫必須要首先匯入的就是 <code>editor</code> 庫。</p>
<hr>
<h1 id="editor-核心庫"><a href="#editor-核心庫" class="headerlink" title="editor 核心庫"></a><code>editor</code> 核心庫</h1><h2 id="嵌入編輯器到-XML-佈局"><a href="#嵌入編輯器到-XML-佈局" class="headerlink" title="嵌入編輯器到 XML 佈局"></a>嵌入編輯器到 XML 佈局</h2><ol>
<li>定義 <code>CodeEditor</code> 組件，就是一個核心編輯器<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;io.github.rosemoe.sora.widget.CodeEditor
    android:id&#x3D;&quot;@+id&#x2F;editor&quot;
    android:layout_width&#x3D;&quot;match_parent&quot;
    android:layout_height&#x3D;&quot;match_parent&quot; &#x2F;&gt;</code></pre></li>
<li>定義 <code>SymbolInputView</code> 組件，這個是用來插入常用符號的工具列，但有時候，如果增設太多符號項到工具列，可能會超出可視區域，所以通常都會連同 <code>HorizontalScrollView</code> 水平滾動佈局加入。<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;HorizontalScrollView
    android:layout_width&#x3D;&quot;match_parent&quot;
    android:layout_height&#x3D;&quot;wrap_content&quot;
    android:orientation&#x3D;&quot;horizontal&quot;&gt;
    &lt;io.github.rosemoe.sora.widget.SymbolInputView
        android:id&#x3D;&quot;@+id&#x2F;symbol_input_view&quot;
        android:layout_width&#x3D;&quot;match_parent&quot;
        android:layout_height&#x3D;&quot;match_parent&quot; &#x2F;&gt;
&lt;&#x2F;LinearLayout&gt;</code></pre>
預設是沒有符號項加入到工具列的，這裏要準備兩個陣列：<pre class="line-numbers language-java" data-language="java"><code class="language-java">String[] displayText &#x3D; &#123;&quot;→&quot;, &quot;&#123;&quot;, &quot;&#125;&quot;, &quot;(&quot;, &quot;)&quot;, &quot;[&quot;, &quot;]&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;,&quot;, &quot;.&quot;, &quot;;&quot;, &quot;\&quot;&quot;, &quot;&#39;&quot;, &quot;?&quot;, &quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;&#x2F;&quot;, &quot;&#x3D;&quot;&#125;;
String[] insertText &#x3D; &#123;&quot;\t&quot;, &quot;&#123;&#125;&quot;, &quot;&#125;&quot;, &quot;()&quot;, &quot;)&quot;, &quot;[]&quot;, &quot;]&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;,&quot;, &quot;.&quot;, &quot;;&quot;, &quot;\&quot;&quot;, &quot;&#39;&quot;, &quot;?&quot;, &quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;&#x2F;&quot;, &quot;&#x3D;&quot;&#125;;

symbolInputView.addSymbols(displayText, insertText);
symbolInputView.bindEditor(editor);</code></pre>
<div class="note info simple"><p><code>displayText</code> 用來顯示的符號，而 <code>insertText</code> 用來插入的符號</p>
</div></li>
</ol>
<h2 id="設置診斷程序的提示和指標器"><a href="#設置診斷程序的提示和指標器" class="headerlink" title="設置診斷程序的提示和指標器"></a>設置診斷程序的提示和指標器</h2><p><code>CodeEditor</code> 並沒有提供診斷程式程序，這個功能你要自行編寫代碼實現，但提供了設置診斷程序的提示和指標器。</p>
<p>支援的嚴重程度 (Severity) 如下：</p>
<ul>
<li><code>SEVERITY_ERROR</code> ：紅色，代表錯誤</li>
<li><code>SEVERITY_WARNING</code>：黃色，代表警告</li>
<li><code>SEVERITY_TYPO</code>：綠色，代表錯別字</li>
</ul>
<p>這裏有一個預覽圖：</p>
<p><img src="https://i.imgur.com/vOyMhjm.png" alt="CodeEditor Diagnostics Preview"></p>
<div class="note warning simple"><p>在進行 <code>setDiagnostic()</code> 前要先 <code>setDiagnostics(new DiagnosticsContainer());</code>。</p>
</div>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">editor.setDiagnostics(new DiagnosticsContainer());

setDiagnostic(36, 44, DiagnosticRegion.SEVERITY_ERROR, &quot;Error&quot;, &quot;Message&quot;, List.of(
    new Quickfix(&quot;Fix&quot;, 0L, null),
    new Quickfix(&quot;Other&quot;, 0L, null)
));

public void setDiagnostic(int startIndex, int endIndex, short type, String briefMessage, String detailedMessage, List&lt;Quickfix&gt; list) &#123;
    getDiagnostics().addDiagnostic(
        new DiagnosticRegion(startIndex, endIndex, type, 0L,
                new DiagnosticDetail(
                        briefMessage,
                        detailedMessage,
                        list,
                        null
                )
        )
    );
&#125;</code></pre>

<div class="note warning simple"><p>每個 <code>setDiagnostic()</code> 方法裏的第一個的 <code>QuickFix</code> 實例，如 <code>Fix</code>，都會顯示在首席位置，隨後的所有新增的 <code>QuickFix</code> 實例都會最後在 <code>More Actions...</code> 下拉式功能選單中顯示。</p>
</div>

<h3 id="設置-QuickFix-按鈕點擊事件"><a href="#設置-QuickFix-按鈕點擊事件" class="headerlink" title="設置 QuickFix 按鈕點擊事件"></a>設置 <code>QuickFix</code> 按鈕點擊事件</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">new Quickfix(&quot;Fix&quot;, 0L, new Runnable() &#123;
    @Override
    public void run() &#123;
        &#x2F;&#x2F; 執行的代碼
    &#125;
&#125;)</code></pre>

<h2 id="加入事件"><a href="#加入事件" class="headerlink" title="加入事件"></a>加入事件</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">editor.subscribeEvent(XXX.class, new EventReciever&lt;&gt; &#123;
    ...
&#125;);</code></pre>

<p>可用的事件如下：</p>
<ul>
<li><code>ClickEvent</code></li>
<li><code>ColorSchemeUpdateEvent</code></li>
<li><code>ContentChangeEvent</code></li>
<li><code>DoubleClickEvent</code></li>
<li><code>EditorReleaseEvent</code></li>
<li><code>SelectionChangeEvent</code></li>
</ul>
<p>還有更多，可到<a href="https://github.com/Rosemoe/sora-editor/tree/main/editor/src/main/java/io/github/rosemoe/sora/event">這裏</a>看。</p>
<h3 id="內容變動事件"><a href="#內容變動事件" class="headerlink" title="內容變動事件"></a>內容變動事件</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">editor.subscribeEvent(ContentChangeEvent.class, new EventReceiver&lt;ContentChangeEvent&gt;() &#123;
    @Override
    public void onReceive(@NonNull ContentChangeEvent event, @NonNull Unsubscribe unsubscribe) &#123;
        &#x2F;&#x2F; 執行的代碼
    &#125;
&#125;);</code></pre>

<hr>
<h1 id="language-textmate-模組庫"><a href="#language-textmate-模組庫" class="headerlink" title="language-textmate 模組庫"></a><code>language-textmate</code> 模組庫</h1><p>這個模組庫主要是擴充 <code>editor</code> 庫的編輯器，使用 TextMate 支援語法高亮功能。</p>
]]></content>
      <categories>
        <category>程式編寫</category>
        <category>Android 開發</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Java</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title>程式編寫 | 由 Java 遷移到 Kotlin 的基礎</title>
    <url>/post/dev-migrate-to-kotlin-from-java.html</url>
    <content><![CDATA[<h1 id="好端端的，為什麼要轉寫-Kotlin？"><a href="#好端端的，為什麼要轉寫-Kotlin？" class="headerlink" title="好端端的，為什麼要轉寫 Kotlin？"></a>好端端的，為什麼要轉寫 Kotlin？</h1><p>其實都挺無奈的，但這個是一個別無選擇的出路。在 Android 開發中，我看不到 Java 在未來還有立足之地。</p>
<ol>
<li>Java 不爭氣，在最初時期是很風光的，但往後加入的大部分特性，Android 都不支援。</li>
<li>已經被 Google 官方斷言，往後推出的 Android 開發特性都以 Kotlin 為首，有目共睹，Jetpack Compose 就是一個 Java 開發者哭暈的證據。</li>
</ol>
<hr>
<h1 id="Java-與-Kotlin-語法差異"><a href="#Java-與-Kotlin-語法差異" class="headerlink" title="Java 與 Kotlin 語法差異"></a>Java 與 Kotlin 語法差異</h1><h2 id="方法-x2F-函數定義"><a href="#方法-x2F-函數定義" class="headerlink" title="方法&#x2F;函數定義"></a>方法&#x2F;函數定義</h2><p>有一個約定俗成的理念，就是雖然大家做的都是一樣的東西，但 Java 就是稱方法 (method)，而 Kotlin 則沿用 C 語言的函數 (function) 為名稱。</p>
<p>在 Java 中，例如定義一個傳回 <code>int</code> 型別的方法是這樣的：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">int sum(int a, int b) &#123;
    return a + b;
&#125;</code></pre>

<p>而在 Kotlin 可以有不同的玩法</p>
<ol>
<li><p>一般寫法</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun sum(a: Int, b: Int) &#123;
    return a + b
&#125;</code></pre>
<div class="note info simple"><p>會看到差異：</p>
<ol>
<li>是先以 <code>fun</code> (function 的縮寫) 作區塊開首，開宗明義的跟你說這個就是函數</li>
<li>參數型別或函數傳回型別會用 <code>:</code> 形式，在後面定義參數型別，都看到 Java 用 <code>int</code> 而 Kotlin 則用類別 (Class) 而成的 <code>Int</code></li>
<li>不用寫 <code>;</code> 作語句結尾</li>
</ol>
</div>
</li>
<li><p>隱式表達寫法</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun sum(a: Int, b: Int): Int &#x3D; a + b</code></pre>
<div class="note info simple"><p>這裏的 <code>=</code> 就是 <code>return</code> 的意思了。</p>
</div>
</li>
<li><p>擴展函數<br>假設現在寫一個 <code>MathKt</code> 類，如果只是寫擴充函數，這裏不用寫 <code>class MathKt &#123; ... &#125;</code>。<br>例如寫一個看 <code>Int</code> 型別加 <code>1</code> 的函數</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun Int.increment() &#x3D; this + 1</code></pre>
<div class="note info simple"><p>擴展函數是為單一型別擴充的函數，你可以用這個方式寫 Utils，相當好用，至於 <code>this</code> 即是指明了的至別 i.e. <code>Int</code>。</p>
<p>用法就是：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun main() &#123;
    print(4.increment())
&#125;</code></pre></div></li>
</ol>
<h2 id="變量定義"><a href="#變量定義" class="headerlink" title="變量定義"></a>變量定義</h2><p>在 Kotlin 有重點關注可變與不可變變量，就是變量及常量吧。</p>
<p>Java 要定義它們，例如用 <code>int</code> 為例子，是寫：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">int num &#x3D; 5

final int LUCKY_NUMBER &#x3D; 5</code></pre>

<p>在 Kotlin，就要善用 <code>var</code> 和 <code>val</code> 關鍵字。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">var num &#x3D; 5
var num: Int &#x3D; 5 &#x2F;&#x2F; 可省略

val LUCKY_NUMBER &#x3D; 5</code></pre>

<p>為什麼 Kotlin 要 <code>val</code> 就可以寫常量呢，這裏稍後再說。</p>
<h2 id="字串與變量拼合"><a href="#字串與變量拼合" class="headerlink" title="字串與變量拼合"></a>字串與變量拼合</h2><p>簡單來說，就是例如：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">String name &#x3D; &quot;Steve&quot;;
System.out.println(&quot;I am &quot; + name);</code></pre>

<p>在 Java 要用 <code>+</code> 來把變量拼合一起，而在 Kotlin 都可以用 <code>+</code> 來這樣做，但亦可以像 EcmaScript 的 <code>$&#123;&#125;</code> 寫法，唯一不同的就是不用 <code>`</code> 這個符號。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val name &#x3D; &quot;Steve&quot;
print(&quot;I am $&#123;name&#125;&quot;)</code></pre>

<hr>
<h2 id="條件語句"><a href="#條件語句" class="headerlink" title="條件語句"></a>條件語句</h2><p>Java 寫的有幾種方法：</p>
<ol>
<li><p>一般寫法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">if (a &gt; 5) &#123;
    System.out.println(&quot;True&quot;);
&#125; else &#123;
    System.out.println(&quot;False&quot;);
&#125;</code></pre>
</li>
<li><p>三元運算</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">System.out.println((a &gt; 5) ? &quot;True&quot; : &quot;False&quot;);</code></pre></li>
</ol>
<p>在 Kotlin 都有不同寫法</p>
<ol>
<li><p>一般寫法</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">if (a &gt; 5) &#123;
    print(&quot;True&quot;)
&#125; else &#123;
    print(&quot;False&quot;)
&#125;</code></pre></li>
<li><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val flag
val result &#x3D; if (a &gt; 5) &#123;
    flag &#x3D; &quot;True&quot;
&#125; else &#123;
    flag &#x3D; &quot;False&quot;
&#125;
print(result)</code></pre>
</li>
<li><p>類似三元運算</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">print(if (a &gt; 5) &quot;True&quot; else &quot;False&quot;)</code></pre></li>
</ol>
<h2 id="情況判斷語句"><a href="#情況判斷語句" class="headerlink" title="情況判斷語句"></a>情況判斷語句</h2><p>Java 是用 <code>switch</code> 寫法的，而 Kotlin 是用 <code>when</code> 的，而且用法更強大。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">when (obj) &#123;
    1 -&gt; print(&quot;One&quot;)
    &quot;Hello&quot; -&gt; print(&quot;Greeting&quot;)
    is Long -&gt; print(&quot;Long&quot;)
    !is String -&gt; print(&quot;Not a string&quot;)
    else -&gt; print(&quot;Unknown&quot;)
&#125; </code></pre>

<h2 id="型別判斷"><a href="#型別判斷" class="headerlink" title="型別判斷"></a>型別判斷</h2><p>Java 會用 <code>instanceof</code> 來進行型別判斷。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">if (obj instanceof String) &#123;
    &#x2F;&#x2F; ...
&#125; else if (obj instanceof int) &#123;
    &#x2F;&#x2F; ...
&#125;</code></pre>

<p>Kotlin 則用 <code>is</code> 關鍵字。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">if (obj is String) &#123;
    &#x2F;&#x2F; ...
&#125; else if (obj is Int) &#123;
    &#x2F;&#x2F; ...
&#125;</code></pre>

<h2 id="空指針異常處理"><a href="#空指針異常處理" class="headerlink" title="空指針異常處理"></a>空指針異常處理</h2><p><code>null</code> 就是一個變量所存的空值，即是一個無效物件，強迫要這個 <code>null</code> 值變量做事，只會讓程式崩潰。寫 Java 經常會遇到空指針異常 (<code>NullPointerException</code>)，在 Kotlin 有相關的處理方案。</p>
<div class="note warning simple"><p>Kotlin 宣告變量 <strong>不可以預設定義值為 <code>null</code></strong> ，所以也算擊退了空指針問題。</p>
</div>

<h3 id="可空-Nullable-與不可空-Non-null-型別"><a href="#可空-Nullable-與不可空-Non-null-型別" class="headerlink" title="可空 (Nullable) 與不可空 (Non-null) 型別"></a>可空 (Nullable) 與不可空 (Non-null) 型別</h3><p>雖然 Kotlin 不可以預設定義 <code>null</code> 值，但不代表 Kotlin 沒有 <code>null</code> 值的存在。</p>
<p>如果，我們直接宣告 <code>null</code> 值變量，會在編譯時拋出異常</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val name: String &#x3D; null</code></pre>

<p>這個情況，就要加上 <code>?</code>，它是用來把變量設為可空型別，這個時候就可以用 <code>null</code>：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val name: String? &#x3D; null</code></pre>

<h3 id="考慮變量為空的情況"><a href="#考慮變量為空的情況" class="headerlink" title="考慮變量為空的情況"></a>考慮變量為空的情況</h3><p>現在，如果你直接用 <code>name</code> 變量，例如 <code>name.length</code> 會出現這個問題：</p>
<pre class="line-numbers language-none"><code class="language-none">Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable reciever of type String?</code></pre>

<p>編譯器會引導你用 <code>?.</code> 或 <code>!!</code> 符號解決問題</p>
<p>如果，你想判斷一個變量是否空，當然你可以這樣做：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">if (name !&#x3D; null)
    println(name.length)</code></pre>

<p>但是 Kotlin 有一個更簡單的做法，就是用 <code>?.</code> 直接寫：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">println(name?.length)</code></pre>

<p>通常，我們都會用 <code>let</code> 語法糖搭配使用，如果處理沒有 <code>?</code> 即不可空型別變量，就不必要用 <code>let</code>。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">name?.let &#123;
    println(it.length)
&#125;</code></pre>

<div class="note info simple"><p>這裏的 <code>it</code> 是編譯器推斷的，如果推斷成功，它就認定了這個 <code>it</code> 是指 <code>name</code>。</p>
</div>

<p>非空斷言 <code>!!.</code> 不推薦用的，這裏不重點說，因為有時你跟 IDE 提議用 <code>!!.</code> 都會拋錯誤：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">IllegalArgumentException：Parameter specified as non-null is null</code></pre>

<h2 id="Getter-amp-Setter"><a href="#Getter-amp-Setter" class="headerlink" title="Getter &amp; Setter"></a>Getter &amp; Setter</h2><p>在 Java，你會經常用到 Getter &amp; Setter，(如硬要說中文的話，也就是存取子及變異子)，例如你有一個 <code>Person</code> 對象：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Person &#123;
    String name &#x3D; &quot;&quot;;
    int age &#x3D; 0;
&#125;</code></pre>

<p>你就會編寫 Getter &amp; Setter：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public void setName(String name) &#123;
    this.name &#x3D; name;
&#125;
public void setAge(int age) &#123;
    this.age &#x3D; age;
&#125;
public String getName() &#123;
    return name;
&#125;
public String getAge() &#123;
    return age;
&#125;</code></pre>

<p>嗯，很長，畢竟這是 Java，但一旦你使用 Kotlin 就可以簡化代碼了。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">class Person &#123;
    var name: String &#x3D; &quot;&quot;
    var age: Int &#x3D; 0
&#125;</code></pre>

<p>JVM (Java 虛擬機) 就會預設自動生成 Getter &amp; Setter，可以直接使用了。</p>
<h3 id="這個情況的-val-跟-var-分別"><a href="#這個情況的-val-跟-var-分別" class="headerlink" title="這個情況的 val 跟 var 分別"></a>這個情況的 <code>val</code> 跟 <code>var</code> 分別</h3><p>在 Kotlin 會有兩種宣告變量方法：</p>
<ul>
<li><code>val</code>: 宣告<strong>不可變</strong>變量，類似 Java 的 <code>final</code> 關鍵字</li>
<li><code>var</code>: 宣告<strong>可變</strong>變量</li>
</ul>
<p>在這個情況下，生成 Getter 以及 Setter 有一個關鍵</p>
<div class="note info simple"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">class Person &#123;
    var name: String &#x3D; &quot;&quot;   &#x2F;&#x2F; 宣告可變變量
    val age: Int &#x3D; 0        &#x2F;&#x2F; 宣告不可變變量
&#125;</code></pre>

<p>最終，JVM 會：</p>
<ul>
<li>對 <code>name</code> 變量，生成 Getter 及 Setter 方法</li>
<li>對 <code>age</code> 變量，只會生成 Getter 方法</li>
</ul>
</div>

<p>由此可得，要 Setter 的話就要用 <code>var</code>，否則用 <code>val</code>。</p>
<h2 id="脫離-Kotlin-關鍵字"><a href="#脫離-Kotlin-關鍵字" class="headerlink" title="脫離 Kotlin 關鍵字"></a>脫離 Kotlin 關鍵字</h2><p>Kotlin 加了很多新的關鍵字，例如 <code>is</code>、<code>data</code> 等關鍵字，有時候不是想以關鍵字語法用途，例如在 Java 有一個這樣的方法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MyClass &#123;
   static void is()&#123;
       System.out.print(&quot;Hello World&quot;);
   &#125;
&#125;</code></pre>

<p>在 Kotlin 調用這個 <code>is()</code> 函數，因為 <code>is</code> 是認定為關鍵字，所以要加一對 <code>``</code> 符號。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun main(args: Array&lt;String&gt;) &#123;
   MyClass.&#96;is&#96;()   
&#125;</code></pre>]]></content>
      <categories>
        <category>程式編寫</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetpack Compose 開發 | 解決卡頓的關鍵：使用 release 版本運行</title>
    <url>/post/jetpack-compose-dev-keystore-release.html</url>
    <content><![CDATA[<p>Jetpack Compose 是一個近年來新興的開發架構，在開發 Compose 程式時，往往都會遇到一件事相當困擾，就是程式卡卡的，運作不流暢，這很影響用戶體驗，而令到 Compose 程式卡頓不外乎是有關兩項因素：</p>
<ol>
<li>在 <code>@Composable</code> 可組合項執行及計算複雜的程式邏輯</li>
<li>使用 <code>debug</code> 模式調試程式</li>
</ol>
<p>如果你是第一種，那就可以去學一下使用 <code>ViewModel</code> 把程式邏輯與界面設計分開，因為可組合項主要是用來使界面設計的，它因為會重組的可能，所以<strong>不建議把邏輯放在內計算</strong>。</p>
<p>至於如果你是第二種，那就來對地方，這裏會記錄一下使用 Keystore 編譯及運行 <code>release</code> 版本。</p>
<hr>
<h1 id="構建及簽署應用程式"><a href="#構建及簽署應用程式" class="headerlink" title="構建及簽署應用程式"></a>構建及簽署應用程式</h1><p>要進行 <code>release</code> 版本，最重要的就是要範為應用程式簽署，在 Android Studio，上面選單列的 <code>Build</code> 找 <code>Generate Signed Bundle / APK</code></p>
<p>它會問你選擇 AAB (Android App Bundle) 或是 APK，這裏選擇 APK</p>
<p><img src="/post/jetpack-compose-dev-keystore-release/img1.png" alt="img1"></p>
<p>如果你之前已經有建立了的 Keystore 就按 Choose existing… 不然就按 Create new</p>
<p><img src="/post/jetpack-compose-dev-keystore-release/img2.png" alt="img2"></p>
<h2 id="建立-Keystore"><a href="#建立-Keystore" class="headerlink" title="建立 Keystore"></a>建立 Keystore</h2><p>建立一個 Keystore 需要填妥表格，包括以下項目</p>
<p><img src="/post/jetpack-compose-dev-keystore-release/img3.png" alt="img3"></p>
<ul>
<li><code>Key store path</code>: Keystore 檔案 (副檔名為 <code>.keystore</code>) 存放位置，通常如果是獨立只為獨有應用程式用的 Keystore，這個檔案路徑可以存放到專案的根目錄位置 e.g. <code>AndroidStudioProjects/MyApp/myapp_release.keystore</code></li>
<li><code>Password</code>: 設置 Keystore 的密碼</li>
</ul>
<p>而 <code>Key</code> 有幾項需要注意：</p>
<ul>
<li><code>Alias</code>: Key 的名稱，可以用 <code>key</code> 為前綴 e.g. <code>keyMyApp</code>，不規定。</li>
<li><code>Password</code>: 設置 Key 的密碼，如沒有太大問題，這裏可以都使用 Keystore 密碼</li>
<li><code>Validity</code>: 以年數作計算，預設是 <code>25</code>，就是 Key 的有效期為 25 年</li>
</ul>
<p>而 <code>Certificate</code> 細項中：</p>
<ul>
<li><code>First and Last Name</code>: 用戶名稱</li>
</ul>
<p>其餘的按需要就填。</p>
<h2 id="完成-Keystore"><a href="#完成-Keystore" class="headerlink" title="完成 Keystore"></a>完成 Keystore</h2><p>例如完成好的 Keystore，再按 Next</p>
<p><img src="/post/jetpack-compose-dev-keystore-release/img4.png" alt="img4"></p>
<p>這裏會問 Keystore 應用到 <code>debug</code> 或是 <code>release</code>，選擇 <code>release</code>，按 Create</p>
<p><img src="/post/jetpack-compose-dev-keystore-release/img5.png" alt="img5"></p>
<hr>
<h1 id="配置-release-構建代碼"><a href="#配置-release-構建代碼" class="headerlink" title="配置 release 構建代碼"></a>配置 <code>release</code> 構建代碼</h1><p>在 <code>app</code> 模塊的 <code>build.gradle.kts</code> 加入代碼：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">buildTypes &#123;
    signingConfigs &#123;
        create(&quot;release&quot;) &#123;
            keyAlias &#x3D; &quot;XXX&quot;
            keyPassword &#x3D; &quot;XXX&quot;         &#x2F;&#x2F; Key 密碼
            storeFile &#x3D; file(&quot;XXX&quot;)
            storePassword &#x3D; &quot;XXX&quot;       &#x2F;&#x2F; Keystore 密碼
        &#125;
    &#125;
    release &#123;
        isMinifyEnabled &#x3D; false
        proguardFiles(
            getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),
            &quot;proguard-rules.pro&quot;
        )
        signingConfig &#x3D; signingConfigs.getByName(&quot;release&quot;)
    &#125;
&#125;</code></pre>

<p><code>storeFile</code> 是 Keystore 檔案存放路徑，例子 </p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">storeFile &#x3D; file(&quot;&#x2F;Users&#x2F;bluewhaleyt&#x2F;AndroidStudioProjects&#x2F;MyApp&#x2F;myapp_release.keystore&quot;)</code></pre>

<hr>
<h1 id="使用-release-構建程式"><a href="#使用-release-構建程式" class="headerlink" title="使用 release 構建程式"></a>使用 <code>release</code> 構建程式</h1><p>把專案 <code>app</code> 的 <code>Build Variant</code> 更改為 <code>release</code> 版本</p>
<div class="note info simple"><p>一旦改 <code>app</code> 的 <code>Build Variant</code> (構建模式)，其他的模塊都會用該構建模式，即一併使用 <code>release</code> 模式。</p>
</div>

<p><img src="/post/jetpack-compose-dev-keystore-release/img6.png" alt="img6"></p>
<p>現在 Run 程式就是用 <code>release</code> 模式了</p>
]]></content>
      <categories>
        <category>程式編寫</category>
        <category>Jetpack Compose 開發</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>程式編寫 | 實作自訂常用的程式碼片段</title>
    <url>/post/dev-vscode-custom-snippets.html</url>
    <content><![CDATA[<p>有沒有想過自己在編寫程式碼時，能夠借助自動完成選單來完成一整塊的程式碼？在 VSCode 軟件，它能夠支援自訂程式碼片段，使你能夠<strong>在輸入關鍵字的前綴後，便能插入一整塊程式碼！</strong>大大提升你編程的效率。</p>
<p>在這篇文章，我們將會學到如何新增自己的程式碼片段。</p>
<hr>
<h1 id="為編輯器進行設定"><a href="#為編輯器進行設定" class="headerlink" title="為編輯器進行設定"></a>為編輯器進行設定</h1><p>首先，為了<strong>避免所新增的程式碼片段無法透過自動完成選單中顯示</strong>，我們可以為編輯器直接啟用自訂程式碼選單片段。</p>
<p>按編輯器選單列的齒輪裏的設定，或者直接用快捷鍵 <kbd>⌘ Cmd</kbd> + <kbd>,
<p>把設定界面更換為以 JSON 格式開啟。</p>
<p><img src="/post/dev-vscode-custom-snippets/img1.png" alt="img1"></p>
<p>在 <code>settings.json</code> 進行以下設定：</p>
<pre class="line-numbers language-json" data-language="json"><code class="language-json">&quot;editor.tabCompletion&quot;: &quot;on&quot;</code></pre>

<p>如果你自己已經安裝一些同樣是附加程式碼片段的擴充插件，例如是 <code>Extension Pack for Java</code>，裏面包含附加程式碼片段，你可以透過編輯器設定把程式碼片段自動完成選單的權重提高。</p>
<pre class="line-numbers language-json" data-language="json"><code class="language-json">&quot;editor.snippetSuggestions&quot;: &quot;top&quot;,</code></pre>

<hr>
<h1 id="新增程式碼片段"><a href="#新增程式碼片段" class="headerlink" title="新增程式碼片段"></a>新增程式碼片段</h1><p>透過快捷鍵 <kbd>⇧ Shift</kbd> + <kbd>⌘ Cmd</kbd> + <kbd>P</kbd> 前往命令輸入界面。</p>
<p>然後在輸入欄中輸入 <code>snippet</code>，你會找到<kbd class="menu">程式碼片段：設定使用者程式碼片段</kbd> &#x2F; <kbd class="menu">Snippets: Configure User Snippets</kbd>，再按 <kbd>⏎ Enter</kbd>。</p>
<p>或者，<kbd class="menu">Code</kbd> &gt; <kbd class="menu">喜好設定</kbd> &gt; <kbd class="menu">設定使用者程式碼片段</kbd></p>
<p><img src="/post/dev-vscode-custom-snippets/img8.png" alt="img8"></p>
<p><img src="/post/dev-vscode-custom-snippets/img6.png" alt="img6"></p>
<hr>
<p>它會要你設定應用程式碼片段的特定語言，即是設定<strong>只能在特定的程式語言文件中使用裏面的程式碼片段</strong>。<br>或者，你要設定全域還是局部新增。</p>
<p><img src="/post/dev-vscode-custom-snippets/img7.png" alt="img7"></p>
<hr>
<p>即是你有三個選項，因應自己所需，選擇其一：</p>
<ol>
<li>設定應用程式碼片段的特定語言：只能在<strong>特定的程式語言文件</strong>中使用該程式碼片段。</li>
<li>為 “<code>[資料夾名稱]</code>“ 新增程式碼片段檔案：只能在<strong>目前的父資料夾</strong>才可以使用該程式碼片段。</li>
<li>新增全域程式碼片段檔案：<strong>所有檔案都可以使用</strong>該程式碼片段。</li>
</ol>
<p>另外，它會要求你輸入任意程式碼片段名稱。</p>
<div class="note info simple"><p>例如你想為 Java 語言新增自己一整套的程式碼片段，你可以把它命名為 <code>My Java Snippet</code>，總之就是隨你喜歡。</p>
</div>

<p>例如，現在我的父資料夾是 <code>hexo</code>，而且我要<strong>為自己的 Hexo 網誌的 Markdown 語法建立程式碼片段</strong>，所以我會選擇<strong>選項 2</strong>，並命名 <code>Blog components</code>，它會在這個資料夾新增 <code>.vscode</code> 資料夾，裏面再新增一個名為 <code>Blog components.code-snippets</code> 檔案。</p>
<p>檔案結構大概是這樣：</p>
<pre class="line-numbers language-none"><code class="language-none">hexo&#x2F;
└── .vscode&#x2F;
    └── Blog-components.code-snippets</code></pre>

<hr>
<h1 id="編寫程式碼片段"><a href="#編寫程式碼片段" class="headerlink" title="編寫程式碼片段"></a>編寫程式碼片段</h1><div class="note info simple"><p>程式碼片段是用 JSON 語言編寫的。</p>
</div>

<p>在建立前，先來瞭解一下裏面的語法。</p>
<pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;
    &quot;Generate Java Entry Point&quot;: &#123;
        &quot;scope&quot;: &quot;java&quot;,
        &quot;prefix&quot;: &quot;javaEntryPoint&quot;,
        &quot;body&quot;: [
            &quot;public class $&#123;1:ClassName&#125; &#123;&quot;,
            &quot;   public static void main(String[] args) &#123;&quot;,
            &quot;       $&#123;2&#125;&quot;,
            &quot;   &#125;&quot;,
            &quot;&#125;&quot;,
        ],
        &quot;description&quot;: &quot;Generate the entry point of Java.&quot;
    &#125;
&#125;</code></pre>

<p>當然，你或許會想到這個是一個生成 Java <strong>入口點</strong>的程式碼片段，但是，當中的設定是什麼意思呢？</p>
<hr>
<h2 id="語法解構"><a href="#語法解構" class="headerlink" title="語法解構"></a>語法解構</h2><p><code>&quot;Generate Java Entry Point&quot;</code> 是一個 JSON <strong>物件</strong>，它將會是程式碼片段其中一個片段，就是<strong>為該片段命名，並會在自動完成選單中該項目右方顯示這名稱</strong>。</p>
<p><code>scope</code> 是指定<strong>這個單一片段可以在哪些語法模式中使用</strong>，例如這裏設定了 java，就只能在 Java 語法文件使用這個單一片段。</p>
<div class="note info simple"><p>它是可以設定<strong>多個語法模式規限</strong>的，做法如下：</p>
<pre class="line-numbers language-json" data-language="json"><code class="language-json">&quot;scope&quot;: &quot;java, html, markdown&quot;</code></pre>

<p>這樣的話，不僅 Java，還有 HTML 和 Markdown 語法文件都可以使用。</p>
</div>

<p><code>prefix</code> 是透過自動完成選單所召喚的該單一片段項目，例如你設定 <code>javaEntryPoint</code>，當你<strong>輸入這個前綴甚至逐漸完成輸入這個字，過程中會出現相關字類</strong>。</p>
<p>例如 Java 中的<strong>關鍵字</strong> <code>instanceof</code>，你<strong>毋須把這個字完全輸入，只需要輸入頭幾個字</strong>就會出現這個字，<code>prefix</code> 就是這個用法。</p>
<p><code>body</code> 就是單一片段所儲存的一整塊程式碼內容。</p>
<p><code>description</code> 純粹是為單一片段作簡單描述，可有可無。</p>
<h3 id="佔位符與定位點"><a href="#佔位符與定位點" class="headerlink" title="佔位符與定位點"></a>佔位符與定位點</h3><p>除了以上提及的語法，你還會看到 <code>$&#123;1:ClassName&#125;</code> 和 <code>$&#123;2&#125;</code>。</p>
<p>原來，我們可以利用這些佔位符，從而在程式碼片段插入後，把<strong>指標器能夠導向至佔位符的位置進行即時編輯</strong>。</p>
<p><code>$&#123;1:ClassName&#125;</code> 是一個佔位符，用來在插入該片段段可以即時編輯的部分，而這個 <code>ClassName</code> 將會是插入片段後的一個可見提示，這個名稱是任意命名的。</p>
<p>而當中的 <code>1</code> 就是一個用於<strong>為指標器辨識位置</strong>，可寫成 <code>$1</code> 或 <code>$&#123;1&#125;</code>。</p>
<p>如果要辨識指標器下一個位置，就要用 <code>$2</code> 或 <code>$&#123;2&#125;</code>，如此類推。</p>
<p>換句話說：</p>
<ol>
<li>如果你想指標器停留在 <code>body</code> 結構內<strong>最終位置</strong>，就要用 <code>$0</code>。</li>
<li>如果你想指標器停留在 <code>body</code> 結構內<strong>指定位置</strong>，就要用 <code>$1</code>。</li>
<li>如果你想指標器停留在 <code>body</code> 結構內<strong>指定位置</strong>，<strong>並要進行即時編輯</strong>，就要用 <code>$1&#123;佔位符名稱&#125;</code>。</li>
</ol>
<div class="note info simple"><p>按鍵盤 <kbd>↹ Tab</kbd> 鍵可以導向下一個定位點的指標器位置。<br>按鍵盤 <kbd>⇧ Shift</kbd> + <kbd>↹ Tab</kbd> 鍵可以導向上一個定位點的指標器位置。</p>
</div>

<hr>
<h3 id="可選擇佔位符"><a href="#可選擇佔位符" class="headerlink" title="可選擇佔位符"></a>可選擇佔位符</h3><p>佔位符不只是有一個值，還可以儲存多個數值，例如，我想它儲存 Java <strong>數據類型</strong> <code>int</code>、<code>double</code>、<code>String</code> 這三個類型，做法如下：</p>
<pre class="line-numbers language-json" data-language="json"><code class="language-json">&quot;body&quot;: [
    &quot;$&#123;1|int,double,String|&#125; value;&quot;
]</code></pre>

<p>同樣，我們都要使用 <code>$&#123;&#125;</code> 語法把佔位符記寫，但不同的是，為了要表達多種選擇數值，我們要用 <kbd>|</kbd> 定義範圍，並用 <kbd>,</kbd> 分隔。</p>
<hr>
<h2 id="格式釐清"><a href="#格式釐清" class="headerlink" title="格式釐清"></a>格式釐清</h2><div class="note warning simple"><p>程式碼片段區塊需要在 <code>{...}</code> 內編寫；往下新增程式碼片段，需要用 <kbd>,</kbd> 分隔。</p>
</div>


<pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;
    &#x2F;&#x2F; 由這裏開始新增第一個程式碼片段
    &#x2F;&#x2F; 往下新增程式碼片段，需要用 &quot;,&quot; 分隔。
    &#x2F;&#x2F; 如下：

    &quot;Test 1&quot;: &#123;
        &#x2F;&#x2F; ...
    &#125;, &#x2F;&#x2F; 這裏分隔
    
    &quot;Test 2&quot;: &#123;
        &#x2F;&#x2F; ...
    &#125;

&#125;</code></pre>

<p>在這裏，簡單為語法和格式釐清一下：</p>
<pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;
    &quot;程式碼片段名稱&quot;: &#123;
        &quot;scope&quot;: &quot;程式語言&quot;,
        &quot;prefix&quot;: &quot;插入程式碼片段要輸入的關鍵字&quot;,
        &quot;body&quot;: [
            &quot;程式碼片段內容&quot;
        ],
        &quot;description&quot;: &quot;程式碼片段簡述&quot;
    &#125;
&#125;</code></pre>

<div class="note info simple"><p><code>scope</code> 可以經以下步驟找到：</p>
<p><kbd class="menu">程式碼片段：設定使用者程式碼片段</kbd> &#x2F; <kbd class="menu">Snippets: Configure User Snippets</kbd>，再按 <kbd>⏎ Enter</kbd>。</p>
<p><img src="/post/dev-vscode-custom-snippets/img6.png" alt="img6"></p>
<p>滾動鼠標或按鍵盤的向下按鈕可以看更多程式語言名稱。</p>
<p><img src="/post/dev-vscode-custom-snippets/img7.png" alt="img7"></p>
</div>

<hr>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>例如，現在我要編寫一個簡單的 <code>for</code> 迴圈，做法如下。</p>
<pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;
    &quot;For loop&quot;: &#123;
        &quot;scope&quot;: &quot;java, c, cpp, csharp&quot;,
        &quot;prefix&quot;: &quot;fori&quot;,
        &quot;body&quot;: [
            &quot;for ($&#123;3|int,double,short,float,long|&#125; i &#x3D; 0; i &lt;&#x3D; $&#123;1:range&#125;; i++) &#123;&quot;,
            &quot;    $2&quot;,
            &quot;&#125;&quot;
        ]
    &#125;
&#125;</code></pre>
<p>當正在輸入 <code>fori</code> 時，會出現這個項目。</p>
<p><img src="/post/dev-vscode-custom-snippets/img2.png" alt="img2"></p>
<p>當插入程式碼片段後：</p>
<p><img src="/post/dev-vscode-custom-snippets/img3.png" alt="img3"></p>
<hr>
<h1 id="使用-snippet-generator"><a href="#使用-snippet-generator" class="headerlink" title="使用 snippet generator"></a>使用 snippet generator</h1><p>如果你覺得編寫 JSON，要瞭解和使用語法有點吃力，你可以用 <a href="https://snippet-generator.app" target="_blank">snippet generator</a>，這個是一個程式碼片段線上生成器，它支援 VSCode、Sublime Text 和 Atom 這三個軟件。</p>
<p><img src="/post/dev-vscode-custom-snippets/img4.png" alt="img4"></p>
<p>玩法一樣，不過透過圖形用戶界面簡化了編寫程序，提供了 <code>Description</code>、<code>Tab trigger</code> 和 <code>Snippet</code> 輸入欄。</p>
<p><code>Tab trigger</code> 就是 <code>prefix</code> 那部分。<br><code>Snippet</code> 就是 <code>body</code> 那部分。</p>
<hr>
<p><img src="/post/dev-vscode-custom-snippets/img5.png" alt="img5"></p>
<p>右邊可以看到 JSON 格式的程式碼顯示，如果你選其他編輯器，則顯示其他程式語言的程式碼。</p>
<p>點擊 <code>Copy snippet</code> 便可以把程式碼複製貼上使用。</p>
<div class="note info simple"><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;
    &#x2F;&#x2F; 在此處貼上
&#125;</code></pre></div>

<hr>
<p>更多關於使用程式碼片段詳見 <a href="https://code.visualstudio.com/docs/editor/userdefinedsnippets" target="_blank">官方文案</a>。</p>
</kbd></p>]]></content>
      <categories>
        <category>程式編寫</category>
      </categories>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetpack Compose 開發 | 實作自訂設計系統</title>
    <url>/post/jetpack-compose-dev-custom-design-system-notes.html</url>
    <content><![CDATA[<p>有時候，我們想寫應用程式時，由其是現在使用 Jetpack Compose 框架，可能會用到 Compose 跨平台架構，實現 Android 及 iOS 雙平台手機程式，如果沿用官方提供的質感設計 3 來做程式，依然沒問題，只是有點不能突顯程式的獨特性。</p>
<p>所以，你看到大部分熱門及大型公司製造的應用程式，有些雖然都是沿用質感設計 3，但是其實是以這個為根基，之後再客製化的，從而反映程式別具一樹的設計風格。</p>
<p>這裏會記錄一下實際上一個設計系統怎做。</p>
<hr>
<h1 id="以官方提供的-API-寫自訂的設計系統"><a href="#以官方提供的-API-寫自訂的設計系統" class="headerlink" title="以官方提供的 API 寫自訂的設計系統"></a>以官方提供的 API 寫自訂的設計系統</h1><p>首先，有一點是無庸置疑的就是官方寫的質感設計 3 都是用這個 API 寫出來的，意味着只要我們參考這個質感設計 3 主題的實現代碼，就可以做一個自訂主題。</p>
<hr>
<h1 id="擴充現有主題設定"><a href="#擴充現有主題設定" class="headerlink" title="擴充現有主題設定"></a>擴充現有主題設定</h1><p>如果是論擴充，這裏就不是自訂主題，純粹是擴充而已，但如果你只有擴充的需要，你可以考慮選擇個別擴充還是整體擴充。</p>
<ol>
<li><p>個別擴充：若是你想純粹在預設的質感設計系統中，擴充新的設計指標，如色彩、字型等，你可以輕鬆運用擴充函數進行擴展。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val Colors.snackbarAction: Color
    get() &#x3D; if (isLight) Red300 else Red700</code></pre>
<p>要使用這個顏色，可以沿用 <code>MaterialTheme</code> 對象：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val color &#x3D; MaterialTheme.colors.snackbarAction</code></pre>
<details class="folding-tag"><summary> 其他例子 </summary>
              <div class="content">
              <p>其他都可以：<br>字型</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">&#x2F;&#x2F; Use with MaterialTheme.typography.textFieldInput
val Typography.textFieldInput: TextStyle
    get() &#x3D; TextStyle(...)</code></pre><p>形狀</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">&#x2F;&#x2F; Use with MaterialTheme.shapes.card
val Shapes.card: Shape
    get() &#x3D; RoundedCornerShape(size &#x3D; 20.dp)</code></pre>
              </div>
            </details>
</li>
<li><p>整體擴充：為現時的主題進行額外的擴展，不再局限於某部分組件的應用設計指標。<br>例如，目前的主題只有 primary (主色) 及 secondary (次色)，現在想新增 tertiary (第三色)。</p>
<details class="folding-tag"><summary> 點我看代碼 </summary>
              <div class="content">
              <ol><li>構建新的數據類<br>這個數據類將會用於設置顏色值。<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Immutable
data class ExtendedColors(
    val tertiary: Color,
    val onTertiary: Color
)</code></pre><div class="note info simple"><p><code>@Immutable</code> 是 Compose 特有的註解，可以提高重組性能。</p></div></li><li>構建本機範圍資料<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val LocalExtendedColors &#x3D; staticCompositionLocalOf &#123;
    ExtendedColors(
        tertiary &#x3D; Color.Unspecified,
        onTertiary &#x3D; Color.Unspecified,
    )
&#125;</code></pre></li><li>構建擴充主題<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Composable
fun ExtendedTheme(
    &#x2F;* ... *&#x2F;
    content: @Composable () -&gt; Unit
) &#123;
    val extendedColors &#x3D; ExtendedColors(
        tertiary &#x3D; Color(0xFFA8EFF0),
        onTertiary &#x3D; Color(0xFF002021)
    )
    CompositionLocalProvider(LocalExtendedColors provides extendedColors) &#123;
        MaterialTheme(
            &#x2F;* colors &#x3D; ..., typography &#x3D; ..., shapes &#x3D; ... *&#x2F;
            content &#x3D; content
        )
    &#125;
&#125;

&#x2F;&#x2F; Use with eg. ExtendedTheme.colors.tertiary
object ExtendedTheme &#123;
    val colors: ExtendedColors
        @Composable
        get() &#x3D; LocalExtendedColors.current
&#125;</code></pre></li><li>應用 <code>ExtendedTheme</code> 提供的顏色至組件<br>這個 <code>ExtendedTheme</code> 是繼承了 <code>MaterialTheme</code> 的設計指標，所以運用 <code>ExtendedTheme</code> 可保留使用 <code>MaterialTheme</code> 的巢狀結構.<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Composable
fun ExtendedButton(
    onClick: () -&gt; Unit,
    modifier: Modifier &#x3D; Modifier,
    content: @Composable RowScope.() -&gt; Unit
) &#123;
    Button(
        colors &#x3D; ButtonDefaults.buttonColors(
            backgroundColor &#x3D; ExtendedTheme.colors.tertiary,
            contentColor &#x3D; ExtendedTheme.colors.onTertiary
            &#x2F;* Other colors use values from MaterialTheme *&#x2F;
        ),
        onClick &#x3D; onClick,
        modifier &#x3D; modifier,
        content &#x3D; content
    )
&#125;</code></pre></li></ol>
              </div>
            </details></li>
</ol>
<hr>
<h1 id="構建自訂的設計主題"><a href="#構建自訂的設計主題" class="headerlink" title="構建自訂的設計主題"></a>構建自訂的設計主題</h1><p>以上說的，純粹是<strong>以現有的主題進行擴充</strong>，但如果真的要自訂全新的設計系統，其實並不難！</p>
<h2 id="瞭解設計系統指標"><a href="#瞭解設計系統指標" class="headerlink" title="瞭解設計系統指標"></a>瞭解設計系統指標</h2><p>檢查 <code>MaterialTheme</code> 的源代碼：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Composable
fun MaterialTheme(
    colors: Colors &#x3D; MaterialTheme.colors,
    typography: Typography &#x3D; MaterialTheme.typography,
    shapes: Shapes &#x3D; MaterialTheme.shapes,
    content: @Composable () -&gt; Unit
)</code></pre>

<p>你會發現，設計指標有顏色、字型及形狀，不過，或許你會覺得不足夠的情況，例如間距 (Spaces)，設置內距或外距的值。</p>
<h2 id="構建主題"><a href="#構建主題" class="headerlink" title="構建主題"></a>構建主題</h2><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">object CustomTheme &#123;
    val colors: CustomColors
        @Composable
        @ReadOnlyComposable
        get() &#x3D; LocalColors.current

    val typography: CustomTypography
        @Composable
        @ReadOnlyComposable
        get() &#x3D; LocalTypography.current

    val shapes: Shapes
        @Composable
        @ReadOnlyComposable
        get() &#x3D; LocalShapes.current

    val spaces: CustomSpaces
        @Composable
        @ReadOnlyComposable
        get() &#x3D; LocalSpaces.current
&#125;</code></pre>

<h3 id="釐定主題指標"><a href="#釐定主題指標" class="headerlink" title="釐定主題指標"></a>釐定主題指標</h3><h4 id="顏色"><a href="#顏色" class="headerlink" title="顏色"></a>顏色</h4><p>大概需要的顏色如下：</p>
<ul>
<li><code>primary</code></li>
<li><code>content</code></li>
<li><code>background</code></li>
<li><code>success</code></li>
<li><code>error</code></li>
</ul>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">data class CustomColors(
    val primary: Color,
    val content: Color,
    val background: Color,
    val success: Color,
    val error: Color
) &#123;
    val primary by mutableStateOf(primary)
        private set
    val content by mutableStateOf(content)
        private set
    val background by mutableStateOf(background)
        private set
    val success by mutableStateOf(success)
        private set
    val error by mutableStateOf(error)
        private set
    
    fun copy(
        primary: Color &#x3D; this.primary,
        content: Color &#x3D; this.content,
        background: Color &#x3D; this.background,
        success: Color &#x3D; this.success,
        error: Color &#x3D; this.error,
    ) &#x3D; CustomColors(
        primary &#x3D; primary,
        content &#x3D; content,
        background &#x3D; background,
        success &#x3D; success,
        error &#x3D; error,
    )
    fun updateColorsFrom(other: CustomColors) &#123;
        primary &#x3D; other.primary
        content &#x3D; other.content
        background &#x3D; other.background
        success &#x3D; other.success
        error &#x3D; other.error
    &#125;
&#125;</code></pre>

<h4 id="字型"><a href="#字型" class="headerlink" title="字型"></a>字型</h4><p>通常字型都需要處理標題 1 至標題 6，段落文字的不同大小，這裏先簡單做 2 個：</p>
<ul>
<li><code>heading1</code></li>
<li><code>body1</code></li>
</ul>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">data class CustomTypography(
    val heading1: TextStyle &#x3D; TextStyle(
        fontFamily &#x3D; FontFamily.SansSerif,
        fontWeight &#x3D; FontWeight.Bold,
        fontSize &#x3D; 24.sp
    ),
    val body1: TextStyle &#x3D; TextStyle(
        fontFamily &#x3D; FontFamily.SansSerif,
        fontWeight &#x3D; FontWeight.Normal,
        fontSize &#x3D; 16.sp
    ),
)</code></pre>

<h4 id="間距"><a href="#間距" class="headerlink" title="間距"></a>間距</h4><p>這個主題的間距指標會有 3 個，例如：</p>
<ul>
<li><code>small</code></li>
<li><code>medium</code></li>
<li><code>large</code></li>
</ul>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">data class CustomSpaces(
    val small: Dp &#x3D; 4.dp,
    val medium: Dp &#x3D; 8.dp,
    val large: Dp &#x3D; 16.dp
)</code></pre>

<h3 id="判定淺色及深色主題顏色值"><a href="#判定淺色及深色主題顏色值" class="headerlink" title="判定淺色及深色主題顏色值"></a>判定淺色及深色主題顏色值</h3><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun lightColors() &#x3D; CustomColors(
    primary &#x3D; Color(0xFFE67E22),
    content &#x3D; Color(0xFF000000),
    background &#x3D; Color(0xFFF5F5F5),
    success &#x3D; Color(0xFF2ECC71),
    error &#x3D; Color(0xFFE74C3C),
)

fun darkColors() &#x3D; CustomColors(
    primary &#x3D; Color(0xFFDF6900),
    content &#x3D; Color(0xFFFFFFFF),
    background &#x3D; Color(0xFF353B48),
    success &#x3D; Color(0xFF44BD32),
    error &#x3D; Color(0xFFC23616),
)</code></pre>

<h3 id="構建本機範圍資料"><a href="#構建本機範圍資料" class="headerlink" title="構建本機範圍資料"></a>構建本機範圍資料</h3><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val LocalSpaces &#x3D; staticCompositionLocalOf &#123; CustomSpaces() &#125;

val LocalColors &#x3D; staticCompositionLocalOf &#123; lightColors() &#125;

val LocalTypography &#x3D; staticCompositionLocalOf &#123; CustomTypography() &#125;</code></pre>

<h3 id="構建主題-1"><a href="#構建主題-1" class="headerlink" title="構建主題"></a>構建主題</h3><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Composable
fun CustomTheme(
    spaces: CustomSpaces &#x3D; CustomTheme.spaces,
    typography: CustomTypography &#x3D; CustomTheme.typography,
    colors: CustomColors &#x3D; CustomTheme.colors,
    content: @Composable () -&gt; Unit,
) &#123;
    val rememberedColors &#x3D; remember &#123; colors.copy() &#125;.apply &#123; updateColorsFrom(colors) &#125;
    CompositionLocalProvider(
        LocalColors provides rememberedColors,
        LocalSpaces provides spaces,
        LocalTypography provides typography,
    ) &#123;
        ProvideTextStyle(typography.body1, content &#x3D; content)
    &#125;
&#125;</code></pre>

<h2 id="應用主題"><a href="#應用主題" class="headerlink" title="應用主題"></a>應用主題</h2><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">class MainActivity : ComponentActivity() &#123;
    override fun onCreate(savedInstanceState: Bundle?) &#123;
        super.onCreate(savedInstanceState)
        setContent &#123;
            CustomTheme &#123;
                App()
            &#125;
        &#125;
    &#125;
&#125;</code></pre>]]></content>
      <categories>
        <category>程式編寫</category>
        <category>Jetpack Compose 開發</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>程式編寫 | 綜合整理 Kotlin 筆記</title>
    <url>/post/dev-kotlin-integrated-notes.html</url>
    <content><![CDATA[<div class="note info simple"><p>使用的軟件是 Fleet，由 JetBrains 所研發的。</p>
</div>

<h1 id="入口點"><a href="#入口點" class="headerlink" title="入口點"></a>入口點</h1><p>入口點就是程式一開始在哪裏執行。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun main() &#123;
    print(&quot;hello world&quot;)
&#125;</code></pre>

<p><img src="/post/dev-kotlin-integrated-notes/img1.png" alt="img1"></p>
<div class="note info simple"><p>Kotlin 的 <code>main.kt</code> 實際上是有類別的，它叫做 <code>MainKt</code>，因為 Kotlin 的編譯器歸根到底都是最後轉換到 Java</p>
</div>

<h2 id="修改入口點或類別名稱"><a href="#修改入口點或類別名稱" class="headerlink" title="修改入口點或類別名稱"></a>修改入口點或類別名稱</h2><p>因為一開始預設是 <code>MainKt</code>，要修改的這就要用 <code>@file:JvmName()</code> 註解，這個註解會直接修改 JVM。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@file:JvmName(&quot;Hello World Program&quot;)</code></pre>

<p><img src="/post/dev-kotlin-integrated-notes/img2.png" alt="img2"></p>
<hr>
<h1 id="輸入數值"><a href="#輸入數值" class="headerlink" title="輸入數值"></a>輸入數值</h1><h2 id="使用操控台輸入"><a href="#使用操控台輸入" class="headerlink" title="使用操控台輸入"></a>使用操控台輸入</h2><p>在 Kotlin，不用 Java 這樣麻煩用 <code>Scanner</code> 來輸入數值至操控台 (console)，可以直接用 <code>readln()</code> 方法。不過，編譯器會<strong>推薦用 <code>readLineOrNull()</code></strong> ，因為這個可以檢查空指針，內部實現代碼純粹是返回一個 <code>String?</code>：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">public actual fun readlnOrNull(): String? &#x3D; readLine()</code></pre>

<div class="note info simple"><p><code>actual</code> 是跨平台（不限於 Compose 跨平台）用的，因為 Kotlin 語法庫支援 JVM 及 JS 編譯。</p>
</div>

<ol>
<li><p>基本使用</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">println(&quot;Enter two numbers&quot;)                &#x2F;&#x2F; 說明用戶輸入數值的目的

print(&quot;Enter a: &quot;) 
val a &#x3D; readlnOrNull()                      &#x2F;&#x2F; 用戶所輸入的值再按 Enter，會賦值至 a
print(&quot;Enter b: &quot;)
val b &#x3D; readlnOrNull()                      &#x2F;&#x2F; 用戶所輸入的值再按 Enter，會賦值至 b

println(&quot;Result: a: $a, b: $b&quot;)             &#x2F;&#x2F; 顯示結果</code></pre>
<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">Enter two numbers
Enter a: 5  
Enter b: 2
Result: a: 5, b: 2</code></pre>
</li>
<li><p>分割形式<br>例如想在單一輸入的時候，輸入多個數值，可以用 <code>split()</code> 裏面接受 <code>delimiters</code> 的 <code>vararg</code> 參數。</p>
<div class="note info simple"><p>這裏寫的是 <code>&quot; &quot;</code>，代表以空格分割。</p>
</div>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">println(&quot;Enter two numbers&quot;)

val (a, b) &#x3D; readln().split(&quot; &quot;)

println(&quot;Result: a: $a, b: $b&quot;)</code></pre>
<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">Enter two numbers
3 7
Result: a: 3, b: 7</code></pre></li>
</ol>
<h2 id="使用-GUI-視窗輸入"><a href="#使用-GUI-視窗輸入" class="headerlink" title="使用 GUI 視窗輸入"></a>使用 GUI 視窗輸入</h2><p>例如是用 Javax Swing 庫</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val num1 &#x3D; JOptionPane.showInputDialog(&quot;Enter first integer&quot;)
val num2 &#x3D; JOptionPane.showInputDialog(&quot;Enter second integer&quot;)

val result &#x3D; num1.toInt() + num2.toInt()
JOptionPane.showMessageDialog(null, &quot;sum: $result&quot;)</code></pre>

<hr>
<h1 id="套件與匯入"><a href="#套件與匯入" class="headerlink" title="套件與匯入"></a>套件與匯入</h1><p>Kotlin 預設匯入了這些套件</p>
<ul>
<li>Kotlin: <code>kotlin.*</code>、<code>kotlin.annotation.*</code>、<code>kotlin.collections.*</code>、<code>kotlin.comparisons.*</code>、<code>kotlin.io.*</code>、<code>kotlin.ranges.*</code>、<code>kotlin.sequences.*</code>、<code>kotlin.text.*</code></li>
<li>JVM: <code>java.lang.*</code>、<code>kotlin.jvm.*</code></li>
<li>JavaScript: <code>kotlin.js.*</code></li>
</ul>
<div class="note danger simple"><p>Kotlin 不支援靜態匯入 (<code>import static</code>)，只用 <code>import</code> 便可以。</p>
</div>

<h2 id="套件類別命名衝突"><a href="#套件類別命名衝突" class="headerlink" title="套件類別命名衝突"></a>套件類別命名衝突</h2><p>Kotlin 不支援套件類別名稱重複，需要用 <code>as</code> 關鍵字重新定義。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">import foo.a.Bar
import foo.b.Bar as BBar</code></pre>

<hr>
<h1 id="存取修飾子"><a href="#存取修飾子" class="headerlink" title="存取修飾子"></a>存取修飾子</h1><table>
<thead>
<tr>
<th>修飾子</th>
<th>Kotlin</th>
<th>Java</th>
</tr>
</thead>
<tbody><tr>
<td><code>public</code></td>
<td>所有類可存取 <strong>（預設）</strong></td>
<td>所有類可存取</td>
</tr>
<tr>
<td><code>private</code></td>
<td>當前類可存取</td>
<td>當前類可存取</td>
</tr>
<tr>
<td><code>protected</code></td>
<td>當前類、子類可存取</td>
<td>當前類、子類、同一套件路徑下的類可存取</td>
</tr>
<tr>
<td><code>default</code></td>
<td>無</td>
<td>同一套件路徑下的類可存取 <strong>（預設）</strong></td>
</tr>
<tr>
<td><code>internal</code></td>
<td>同一模組中的類可存取</td>
<td>無</td>
</tr>
</tbody></table>
<h2 id="可繼承類"><a href="#可繼承類" class="headerlink" title="可繼承類"></a>可繼承類</h2><p>Kotlin 預設寫的 <code>Class</code> 是不能繼承 (inherit) 的，如果要讓其他 <code>Class</code> 可繼承這個 <code>Class</code>，就要加 <code>open</code> 關鍵字。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">open class ClassA

class ClassB : ClassA()</code></pre>

<hr>
<h1 id="對象與建構式"><a href="#對象與建構式" class="headerlink" title="對象與建構式"></a>對象與建構式</h1><h2 id="單例模式-Singleton"><a href="#單例模式-Singleton" class="headerlink" title="單例模式 (Singleton)"></a>單例模式 (Singleton)</h2><p>我們可以使用 <code>object</code> 關鍵字來定義 Singleton，可以在其他地方使用 <code>SingletonObject</code> 來訪問其屬性和方法。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">object SingletonObject &#123;
    &#x2F;&#x2F; 屬性和方法
&#125;</code></pre>

<div class="note info simple"><p>Java 調用 Kotlin Singleton 需要加上 <code>INSTANCE</code>。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">SingletonObject.INSTANCE.xxx</code></pre></div>

<h2 id="伴生對象"><a href="#伴生對象" class="headerlink" title="伴生對象"></a>伴生對象</h2><p>我們可以使用 <code>companion object</code> 關鍵字在類內部定義一個伴生物件。伴生物件可以訪問類的私有成員，就像是該類的靜態成員一樣，但它不同於靜態成員，因為它可以訪問類的非靜態成員。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">class MyClass &#123;
    companion object &#123;
        &#x2F;&#x2F; 屬性和方法
    &#125;
&#125;</code></pre>

<div class="note info simple"><p>Java 調用 Kotlin Companion object 需要加上 <code>Companion</code>。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">MyClass.Companion.xxx</code></pre></div>

<h2 id="建構子建構"><a href="#建構子建構" class="headerlink" title="建構子建構"></a>建構子建構</h2><h3 id="主要建構子"><a href="#主要建構子" class="headerlink" title="主要建構子"></a>主要建構子</h3><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">class MyClass(
    val str: String
) &#123;
    &#x2F;&#x2F; ...
&#125;</code></pre>
<h3 id="次要-x2F-多個建構子"><a href="#次要-x2F-多個建構子" class="headerlink" title="次要 &#x2F; 多個建構子"></a>次要 &#x2F; 多個建構子</h3><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">class MyClass &#123;
    var prop1 &#x3D; &quot;&quot;
    var prop2 &#x3D; 0
    
    constructor(prop1: String) &#123;
        this.prop1 &#x3D; prop1
    &#125;
    
    constructor(prop2: Int) &#123;
        this.prop2 &#x3D; prop2
    &#125;
&#125;</code></pre>

<h3 id="初始化程式"><a href="#初始化程式" class="headerlink" title="初始化程式"></a>初始化程式</h3><p>用 <code>init</code> 函數可以初始化建構子執行的程式。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">class MyClass &#123;
    init &#123;
        println(&quot;$&#123;this.javaClass.name&#125; loaded&quot;)
    &#125;
&#125;
val myClass &#x3D; MyClass()</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">MyClass loaded</code></pre>

<hr>
<h1 id="運算符"><a href="#運算符" class="headerlink" title="運算符"></a>運算符</h1><h2 id="位元運算符"><a href="#位元運算符" class="headerlink" title="位元運算符"></a>位元運算符</h2><ol>
<li>按位取反 <code>inv</code>：取反後的數字會變成原數字的補數<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val num &#x3D; 10
val result &#x3D; num.inv()
print(result)                       &#x2F;&#x2F; 輸出：-11</code></pre>
<div class="note info simple"><p><code>inv()</code> 函數會將數字的二進位表示中的每個位元取反，也就是 <code>0</code> 變成 <code>1</code>，<code>1</code> 變成 <code>0</code>。另外，這個操作還會將數字的正負號反轉。<br><code>10</code> 的二進位表示為 <code>00001010</code>。當我們對這個數字進行取反操作時，每個位元都會取反，得到的結果為 <code>11110101</code>。這個結果在二進位中也代表著數字 <code>-11</code>。</p>
</div></li>
<li>左移 <code>shl</code> (<code>&lt;&lt;</code>)：將數字的二進位表示向左移動指定的位數。左移操作會在右側填入 <code>0</code>，相當於將該數字乘以 <code>2</code> 的 <code>n</code> 次方，其中 <code>n</code> 是左移的位數。<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val number &#x3D; 5                      &#x2F;&#x2F; 左移的數字是 5
val shift &#x3D; 2                       &#x2F;&#x2F; 左移的位數是 2
val result &#x3D; number shl shift
println(result)                     &#x2F;&#x2F; 輸出：20 (將 5 左移 2 位相當於 5 * (2^2) )</code></pre></li>
<li>右移 <code>shr</code> (<code>&gt;&gt;</code>)：將數字的二進位表示向右移動指定的位數。右移操作會在左側填入原數字的最高位元，相當於將該數字除以 <code>2</code> 的 <code>n</code> 次方，其中 <code>n</code> 是右移的位數。<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val number &#x3D; 20                     &#x2F;&#x2F; 右移的數字是 20
val shift &#x3D; 2                       &#x2F;&#x2F; 右移的位數是 2
val result &#x3D; number shr shift
println(result)                     &#x2F;&#x2F; 輸出：5 (將 20 右移 2 位相當於 20 &#x2F; (2^2) )</code></pre></li>
</ol>
<hr>
<h1 id="變量及常量"><a href="#變量及常量" class="headerlink" title="變量及常量"></a>變量及常量</h1><p>我們可以使用變量和常量來存儲和管理數據。變量是可以改變其值的存儲位置，而常量則是一旦被賦值就無法更改的存儲位置。</p>
<div class="note info simple"><p>賦值語句格式，萬變不離其宗</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">var 變量名稱: 數據類型 &#x3D; 初始值</code></pre></div>

<ol>
<li>宣告變量：使用關鍵字 <code>var</code> 來定義可變變量。<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">var age: Int &#x3D; 15</code></pre></li>
<li>宣告常量：使用關鍵字 <code>val</code> 來定義常量 (不可變變量)。<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val age: Int &#x3D; 15</code></pre></li>
</ol>
<h2 id="存取與變異"><a href="#存取與變異" class="headerlink" title="存取與變異"></a>存取與變異</h2><p>考慮到用 <code>var</code> 還是 <code>val</code>，還有一個考量就是 Getter &amp; Setter</p>
<ul>
<li><code>var</code>：<code>private</code> 變量，但賦有 <code>public</code> 的 <code>set()</code> 和 <code>get()</code> 屬性</li>
<li><code>val</code>：<code>private</code> 變量，賦有 <code>public</code> 的 <code>get()</code> 屬性</li>
</ul>
<div class="note info simple"><p>一般而言，如果不肯定變量能不能被修改，就先用 <code>val</code>，當有修改的用途就改用 <code>var</code>。</p>
</div>

<p>此外，還有 <code>const</code> 關鍵字，看似與 <code>val</code> 能混為一談</p>
<p><code>const</code> 與 Java 的 <code>static</code> 相若，一般情況下，用不用 <code>const</code> 是絕沒太大影響，重點是</p>
<div class="note info simple"><ol>
<li><code>const</code> 變量必須是頂層級別 (top-level) 或者 <code>object</code> 或 <code>companion object</code> 中的屬性</li>
<li><code>val</code> 是在運行時計算；而 <code>const</code> 則是編譯時計算。</li>
<li>預設的 <code>val</code> 是私有 (<code>private</code>) 變量，當加上了 <code>const</code> 變成 <code>const val</code> 就會成為公共 (<code>public</code>) 變量。</li>
</ol>
</div>

<p>例子：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val hello &#x3D; test()          &#x2F;&#x2F; 編譯成功
const val DATA &#x3D; test()     &#x2F;&#x2F; 編譯錯誤
const val NAME &#x3D; &quot;&quot;         &#x2F;&#x2F; 編譯成功

fun test() &#x3D; &quot;&quot;</code></pre>

<hr>
<h1 id="函數"><a href="#函數" class="headerlink" title="函數"></a>函數</h1><p>函數是一個重要的程式結構，它可以接受輸入參數並返回一個結果。我們可以使用 <code>fun</code> 關鍵字來定義一個函數。</p>
<div class="note info simple"><p>函數預設返回的類型為 <code>Unit</code>，即是 Java 的 <code>void</code> 類型。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun greet1(): Unit &#123;
    print(&quot;Good morning&quot;)
&#125;

fun greet2() &#123;
    print(&quot;Good morning&quot;)
&#125;</code></pre>
<p><code>greet1()</code> 和 <code>greet2()</code> 方法是一樣的，基本上 <code>Unit</code> 可以省略不寫。</p>
</div>

<h2 id="函數類型"><a href="#函數類型" class="headerlink" title="函數類型"></a>函數類型</h2><h3 id="單行表達式"><a href="#單行表達式" class="headerlink" title="單行表達式"></a>單行表達式</h3><p>如果函數<strong>只有一行程式碼</strong>，可以使用單行表達式函數的語法簡化函數的定義。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun multiply(a: Int, b: Int): Int &#x3D; a * b</code></pre>

<div class="note info simple"><ol>
<li><p>這裏的 <code>=</code> 等同於 <code>return</code></p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun multiply(a: Int, b: Int): Int &#123;
    return a * b
&#125;</code></pre>
</li>
<li><p>返回類型可省略</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun multiply(a: Int, b: Int) &#x3D; a * b</code></pre></li>
</ol>
</div>

<h3 id="高階函數"><a href="#高階函數" class="headerlink" title="高階函數"></a>高階函數</h3><p>函數可以作為參數傳遞給其他函數，或者作為返回值返回。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun calculate(a: Int, b: Int, operation: (Int, Int) -&gt; Int): Int &#123;
    return operation(a, b)
&#125;</code></pre>

<div class="note info simple"><p><code>calculate()</code> 接受 3 個參數，其中 <code>operation</code> 參數比較複雜，這個運用了高階函數，接受兩個參數然後再返回一個 <code>Int</code> 類型的結果，至於是怎樣的結果，就是視乎 <code>operation()</code> 高階函數實現的邏輯。</p>
<p>假如我們用 <code>calculate()</code> 函數實現一個加法及乘法計算，需要一對 <code>{}</code> 區塊，區塊內需要傳入參數，就以 <code>x</code> 和 <code>y</code> 分別是對入 <code>operation(Int, Int)</code>，接著 <code>-&gt;</code> 後寫的代碼就是要實現的邏輯。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val sum &#x3D; calculate(3, 5) &#123; x, y -&gt; x + y &#125;
val product &#x3D; calculate(8, 3) &#123; x, y -&gt; x * y &#125;

print(&quot;sum: $sum, product: $product&quot;)</code></pre>
<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">sum: 8, product: 24</code></pre></div>

<h4 id="內聯函數"><a href="#內聯函數" class="headerlink" title="內聯函數"></a>內聯函數</h4><p><code>inline</code> 函數會在代碼編譯時，將被調用處代碼直接嵌入到調用處的函數中</p>
<div class="note warning simple"><p>過度使用 <code>inline</code> 會使字節碼膨脹。</p>
</div>

<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">&#x2F;&#x2F; 一般如果是這樣的程式碼，不會用 inline
inline fun hello() &#x3D; print(&quot;Hello World&quot;)

&#x2F;&#x2F; 如果沒有用 inline 來定義 hello() 函數
fun main() &#123;
    hello()
&#125;

&#x2F;&#x2F; 如果有用 inline 來定義 hello() 函數
fun main() &#123;
    print(&quot;Hello World&quot;)    &#x2F;&#x2F; 直接把 hello() 函數的代碼嵌入下來
&#125;</code></pre>

<p>實際用途是用來減少創建額外對象及函數，從而減少資源消耗。亦都增加執行速度（順序執行代碼的速度會較調用函數的速度快）。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">inline fun hello(block: () -&gt; Unit) &#123;
    println(&quot;Hello World&quot;)
    block()
&#125;

&#x2F;&#x2F; 你寫的程式碼
fun main() &#123;
    hello &#123;
        println(&quot;123&quot;)
    &#125;
&#125;

&#x2F;&#x2F; 實際編譯後的程式碼
fun main() &#123;
    println(&quot;Hello World&quot;)
    println(&quot;123&quot;)          &#x2F;&#x2F; 把 hello() 函數區塊內的程式碼嵌入下來
&#125;</code></pre>

<p>為 <code>inline</code> 函數使用的參數設定</p>
<p><code>noinline</code>：就是不內聯的意思</p>
<p>如果我們嘗試寫</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">inline fun hello(block: () -&gt; Unit): () -&gt; Unit &#123;
    println(&quot;Hello World&quot;)
    return block
&#125;</code></pre>
<p>因為 <code>hello()</code> 函數被內聯了，如果嘗試傳回 <code>block</code>，會在編譯器拋出：</p>
<p><img src="/post/dev-kotlin-integrated-notes/img6.png" alt="img6"></p>
<p>所以這個時候就要用 <code>noinline</code></p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">inline fun hello(noinline block: () -&gt; Unit): () -&gt; Unit &#123;
    println(&quot;Hello World&quot;)
    return block
&#125;</code></pre>

<p><code>crossinline</code>：強制內聯</p>
<h4 id="infix-函數"><a href="#infix-函數" class="headerlink" title="infix 函數"></a><code>infix</code> 函數</h4><p>不需要用 <code>()</code> 的函數</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">infix fun Int.add(count: Int) &#x3D; this + count

val result1 &#x3D; 5 add 3
println(&quot;Result: $result1&quot;)     &#x2F;&#x2F; 輸出：8</code></pre>

<h4 id="operator-函數"><a href="#operator-函數" class="headerlink" title="operator 函數"></a><code>operator</code> 函數</h4><p>就是重載運算符的函數，例如 <code>1 + 1</code>，對應的函數是 <code>plus()</code></p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val point &#x3D; Point(2, 3)
val a &#x3D; 1
val b &#x3D; a + point       &#x2F;&#x2F; 錯誤</code></pre>

<p>假如，我們嘗試把不支援的型別與例如 <code>Int</code> 相加，會在編譯時拋出錯誤：</p>
<p><img src="/post/dev-kotlin-integrated-notes/img5.png" alt="img5"></p>
<p>要令到這個 <code>+</code> 運算符可以用其他類型 e.g. <code>Point</code> 進行加法，就要用 <code>operator fun</code>。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">operator fun Int.plus(other: Point) &#x3D; this + other.x + other.y

val point &#x3D; Point(2, 3)
val a &#x3D; 1
val b &#x3D; a + point
print(&quot;b: $b&quot;)      &#x2F;&#x2F; 輸出 b: 6</code></pre>

<p>運算符函數表</p>
<table>
<thead>
<tr>
<th>運算符</th>
<th>函數</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td><code>plus()</code></td>
</tr>
<tr>
<td><code>-</code></td>
<td><code>minus()</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td><code>times()</code></td>
</tr>
<tr>
<td><code>/</code></td>
<td><code>div()</code></td>
</tr>
<tr>
<td><code>%</code></td>
<td><code>mod()</code> &#x2F; <code>rem()</code></td>
</tr>
<tr>
<td><code>++</code></td>
<td><code>inc()</code></td>
</tr>
<tr>
<td><code>!</code></td>
<td><code>not()</code></td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td><code>compareTo() &gt; 0</code></td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td><code>compareTo() &lt; 0</code></td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td><code>compareTo() &gt;= 0</code></td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td><code>compareTo &lt;= 0</code></td>
</tr>
<tr>
<td><code>in</code></td>
<td><code>contains()</code></td>
</tr>
</tbody></table>
<h3 id="匿名函數"><a href="#匿名函數" class="headerlink" title="匿名函數"></a>匿名函數</h3><p>匿名函數可使用 <code>fun()</code> 定義，並作為值賦值給變數。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val sum &#x3D; fun(a: Int, b: Int) &#x3D; a + b
val result &#x3D; sum(4, 6)

print(&quot;sum: $result&quot;)</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">sum: 10</code></pre>

<h3 id="標準-x2F-作用域函數"><a href="#標準-x2F-作用域函數" class="headerlink" title="標準 &#x2F; 作用域函數"></a>標準 &#x2F; 作用域函數</h3><p>這些函數可以幫助我們<strong>簡化程式碼並提高可讀性</strong>，對代碼邏輯沒有任何意義，只是語法糖。用途很廣泛，而且看情況。</p>
<table>
<thead>
<tr>
<th>函數</th>
<th>對象引用</th>
<th>返回值</th>
<th>是否擴展函數</th>
</tr>
</thead>
<tbody><tr>
<td><code>let</code></td>
<td><code>it</code></td>
<td>Lambda 表達式</td>
<td>是</td>
</tr>
<tr>
<td><code>run</code></td>
<td><code>this</code></td>
<td>Lambda 表達式</td>
<td>是</td>
</tr>
<tr>
<td><code>run</code></td>
<td>-</td>
<td>Lambda 表達式</td>
<td>不是，調用毋須 <code>Context</code></td>
</tr>
<tr>
<td><code>with</code></td>
<td><code>this</code></td>
<td>Lambda 表達式</td>
<td>不是，把 <code>Context</code> 當作參數</td>
</tr>
<tr>
<td><code>apply</code></td>
<td><code>this</code></td>
<td><code>Context</code></td>
<td>是</td>
</tr>
<tr>
<td><code>also</code></td>
<td><code>it</code></td>
<td><code>Context</code></td>
<td>是</td>
</tr>
</tbody></table>
<div class="note info simple"><ul>
<li><code>this</code>：當前引用的對象，例如 <code>this.text = ...</code> 可省略為 <code>text = ...</code>。</li>
<li><code>it</code>：常用於 Lambda 表達式，作為<strong>顯式單個參數聲明</strong>的暫代名稱，只可以為單個參數的函數，才可用 <code>it</code>。</li>
</ul>
<p>如果暫不使用參數，可用 <code>_</code> 作為佔位，未使用的參數，不會進行處理。</p>
</div>

<h4 id="let-函數"><a href="#let-函數" class="headerlink" title="let 函數"></a><code>let</code> 函數</h4><ol>
<li>對非空型別對象執行 Lambda 表達式<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val name: String? &#x3D; &quot;John&quot;
name?.let &#123;
    &#x2F;&#x2F; 在這裡可以使用非空的 name 變數
    println(&quot;Hello, $it!&quot;)
&#125;</code></pre></li>
<li>把表達式作為變量引入到局部作用域中<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val number &#x3D; 5
val doubled &#x3D; number.let &#123; it * 2 &#125;
println(doubled)            &#x2F;&#x2F; 輸出：10</code></pre></li>
</ol>
<h4 id="run-函數"><a href="#run-函數" class="headerlink" title="run 函數"></a><code>run</code> 函數</h4><p>跟 <code>apply</code> 函數用法相若，但 <code>run</code> 函數會傳回 Lambda 表達式，<code>apply</code> 函數沒有傳回值。而且<strong>可以為特定對象編寫邏輯</strong>，最後運算取得結果。</p>
<ol>
<li>擴展：對象配置並且計算結果<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val result &#x3D; &quot;Hello, Kotlin&quot;.run &#123;
    println(this)           &#x2F;&#x2F; 輸出：Hello, Kotlin
    length
&#125;
println(result)             &#x2F;&#x2F; 輸出：13</code></pre></li>
<li>非擴展：在需要表達式的地方執行語句<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val message &#x3D; run &#123;
    val greeting &#x3D; &quot;Hello&quot;
    val person &#x3D; &quot;Alice&quot;
    &quot;$greeting, $person!&quot;   &#x2F;&#x2F; 返回的值一定要放最後
&#125;
println(message)            &#x2F;&#x2F; 輸出：Hello, Alice!</code></pre></li>
</ol>
<h4 id="apply-函數"><a href="#apply-函數" class="headerlink" title="apply 函數"></a><code>apply</code> 函數</h4><p>可視為一種配置函數，傳入一個接收者，然後呼叫一系列函數來對接收者做設定。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">class Person &#123;
    var name: String? &#x3D; null
    var age: Int? &#x3D; null
&#125;

val person &#x3D; Person().apply &#123;
    name &#x3D; &quot;Alice&quot;
    age &#x3D; 25
&#125;</code></pre>

<h4 id="also-函數"><a href="#also-函數" class="headerlink" title="also 函數"></a><code>also</code> 函數</h4><p>附加效果，<code>also</code> 適合針對同一原始物件，透過副作用做事。當看到 <code>also</code> 的時候表示，同時還要針對該對象物件執行此動作。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val numbers &#x3D; mutableListOf(1, 2, 3)
val doubledNumbers &#x3D; numbers.also &#123;
    it.forEachIndexed &#123; index, value -&gt;
        it[index] &#x3D; value * 2
    &#125;
&#125;
println(doubledNumbers) &#x2F;&#x2F; 輸出：[2, 4, 6]</code></pre>

<h4 id="with-函數"><a href="#with-函數" class="headerlink" title="with 函數"></a><code>with</code> 函數</h4><p>一個對象的一組函數調用，<code>with</code> 函數是 <code>run</code> 函數的變形：他們的功能與行為一樣，接收者是使用 <code>with</code> 的對象物件。</p>
<div class="note warning simple"><p>但 <code>with</code> 的呼叫方式不同，使用 <code>with</code> 時，<strong>要求引數作為其第一個參數傳入</strong>，另外，若執行 <code>run</code> 的對象物件為 <code>null</code> ，則 <code>run</code> 區塊不會進入；反之， <code>with</code> 函數則是會進去操作。</p>
</div>

<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">data class Person(val name: String, val age: Int)

val person &#x3D; Person(&quot;Alice&quot;, 25)
with(person) &#123;
    println(&quot;Name: $name&quot;)
    println(&quot;Age: $age&quot;)
&#125;</code></pre>

<h3 id="擴展函數"><a href="#擴展函數" class="headerlink" title="擴展函數"></a>擴展函數</h3><p>允許我們<strong>為現有的類型添加新的函數</strong>，而不需要修改原始類型的程式碼。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun Int.isEven(): Boolean &#123;
    return this % 2 &#x3D;&#x3D; 0
&#125;

val number &#x3D; 5
println(number.isEven())        &#x2F;&#x2F; 輸出：false</code></pre>

<div class="note info simple"><p>這裏的 <code>this</code> 是指 <code>fun Int</code> 的 <code>Int</code> 型別，這個 <code>Int</code> 是一個接收者 (receiver)。</p>
<p>善用擴展函數可減少編寫 Utils 複用工具函數。</p>
</div>

<details class="folding-tag"><summary> 轉換為 Java 後的程式碼 </summary>
              <div class="content">
              <p>實際上有一個隱藏的類別會產生，根據檔案名稱如 <code>Extension.kt</code>，那就會在編譯過程生成 <code>ExtensionKt.class</code>，大概的 Java 程式碼就是：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ExtensionKt &#123;
    public static boolean isEven(receiver: Int) &#123; ... &#125;
&#125;</code></pre><p><code>receiver</code> 會在編譯過程寫入作為參數</p>
              </div>
            </details>

<h1 id="範圍"><a href="#範圍" class="headerlink" title="範圍"></a>範圍</h1><p>範圍 (Ranges) 是一個連續的數值區間，我們可以使用範圍來表示一系列連續的數字或字符。在 Kotlin 中，我們可以使用 <code>..</code> 運算符來創建一個範圍。範圍的起始值和結束值可以是整數、字符或其他可比較的型別。</p>
<ol>
<li><p>升序 (ascending)</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">for (i in 1..4) print(i)            &#x2F;&#x2F; 輸出 &quot;1234&quot;</code></pre>
<div class="note info simple"><p><img src="/post/dev-kotlin-integrated-notes/img3.png" alt="img3"></p>
<p>如果啟用了嵌入提示 (Inlay Hint)，可以看到 <code>..</code> 有 <code>&lt;=</code> 的意思。</p>
</div>
</li>
<li><p>降序 (descending)</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">for (i in 4 downTo 1) print(i)      &#x2F;&#x2F; 輸出 &quot;4321&quot;</code></pre>
<div class="note info simple"><p>而 <code>downTo</code> 則有 <code>&gt;=</code> 的意思。</p>
</div>
<div class="note danger simple"><p>降序不是這樣做：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">for (i in 4..1) print(i)            &#x2F;&#x2F; 沒有輸出</code></pre>

<p>編譯器會跟你說範圍是空的，因為 <code>4 &lt;= 1</code> 是異想天開的事。<br><img src="/post/dev-kotlin-integrated-notes/img4.png" alt="img4"></p>
</div>
</li>
<li><p>略過及調整步長 <code>step</code><br>例如是偶數</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">for (i in 2..10 step 2) print(i)    &#x2F;&#x2F; 輸出：246810</code></pre>
</li>
<li><p>直至 <code>until</code></p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">for (i in 1 until 10) print(i)      &#x2F;&#x2F; 輸出：123456789 (不計算 10)</code></pre></li>
</ol>
<h2 id="範圍函數"><a href="#範圍函數" class="headerlink" title="範圍函數"></a>範圍函數</h2><p>不一定只用在迴圈，亦可以以函數方式使用</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val descendingNumbers &#x3D; 5.downTo(1)
val evenNumbers &#x3D; (2..10).step(2)

println(&quot;Descending numbers:&quot;)
for (number in descendingNumbers) &#123;
    println(number)
&#125;

println(&quot;Even numbers:&quot;)
for (number in evenNumbers) &#123;
    println(number)
&#125;</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">Descending numbers:
5
4
3
2
1
Even numbers:
2
4
6
8
10</code></pre>

<hr>
<h1 id="陣列"><a href="#陣列" class="headerlink" title="陣列"></a>陣列</h1><p>陣列 (又稱數組) 是一種常用的資料結構，它可以儲存一組相同類型的元素。</p>
<h2 id="用-arrayOf-函數建立基本陣列"><a href="#用-arrayOf-函數建立基本陣列" class="headerlink" title="用 arrayOf() 函數建立基本陣列"></a>用 <code>arrayOf()</code> 函數建立基本陣列</h2><ol>
<li>空陣列<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val empty &#x3D; arrayOf&lt;String&gt;()</code></pre></li>
<li>一般陣列<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val numbers &#x3D; arrayOf(1, 2, 3, 4, 5)</code></pre></li>
</ol>
<h2 id="用-Array-建立不同陣列"><a href="#用-Array-建立不同陣列" class="headerlink" title="用 Array() 建立不同陣列"></a>用 <code>Array()</code> 建立不同陣列</h2><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val names &#x3D; Array(3) &#123; &quot;&quot; &#125;                          &#x2F;&#x2F; 預設是空陣列，設置了陣列大小為 3
names[0] &#x3D; &quot;Alice&quot;
names[1] &#x3D; &quot;Bob&quot;
names[2] &#x3D; &quot;Carol&quot;

println(&quot;Array of names: $names&quot;)
println(&quot;The first item of names: $&#123;names[0]&#125;&quot;)      &#x2F;&#x2F; 獲取 names 陣列首項元素
println(&quot;The size of names array: $&#123;names.size&#125;&quot;)    &#x2F;&#x2F; 獲取 names 陣列大小
</code></pre>

<div class="note info simple"><p>陣列的索引從 <code>0</code> 開始，所以 <code>names[0]</code> 代表陣列中的第一個元素。</p>
</div>

<h3 id="二維陣列"><a href="#二維陣列" class="headerlink" title="二維陣列"></a>二維陣列</h3><p>例如一個 <code>2 x 2</code> 的二維陣列</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val matrix &#x3D; Array(2) &#123; IntArray(2) &#125;
matrix[0][0] &#x3D; 1
matrix[0][1] &#x3D; 2
matrix[1][0] &#x3D; 3
matrix[1][1] &#x3D; 4

val element &#x3D; matrix[1][0]
println(&quot;matrix[1][0] 的值為 $element&quot;)</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">matrix[1][0] 的值為 3</code></pre>

<h3 id="三維陣列"><a href="#三維陣列" class="headerlink" title="三維陣列"></a>三維陣列</h3><p>例如一個 <code>2 x 3 x 4</code> 的三維陣列</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val cube &#x3D; Array(2) &#123; Array(3) &#123; IntArray(4) &#125; &#125;
cube[0][0][0] &#x3D; 1
cube[0][1][2] &#x3D; 2
cube[1][2][3] &#x3D; 3

val element &#x3D; cube[0][1][2]
println(&quot;cube[0][1][2] 的值為 $element&quot;)</code></pre>

<div class="note info simple"><p>這個 <code>2 x 3 x 4</code> 是假想三維空間的 <code>x</code> 軸、<code>y</code> 軸及 <code>z</code> 軸測量指標，其中 <code>x</code> 軸有 2 個元素，<code>y</code> 軸有 3 個元素，<code>z</code> 軸有 4 個元素。</p>
<p>以一個立方體來比喻的話，我們可以把 <code>x</code> 軸想像成立方體的寬度，<code>y</code> 軸想像成高度，<code>z</code> 軸想像成深度。而 <code>2 x 3 x 4</code> 的意思就是這個立方體有 2 個寬度、3 個高度和 4 個深度。</p>
</div>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">cube[0][1][2] 的值為 2</code></pre>

<hr>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合 (Collections) 是在程式開發中非常重要的一個主題，它們可以讓我們有效地儲存和操作多個元素。</p>
<div class="note info simple"><p>集合與陣列一樣，索引由 <code>0</code> 開始，即是第一個元素。</p>
</div>

<h2 id="集合類型"><a href="#集合類型" class="headerlink" title="集合類型"></a>集合類型</h2><h3 id="有序集合-List-列表"><a href="#有序集合-List-列表" class="headerlink" title="有序集合 List (列表)"></a>有序集合 <code>List</code> (列表)</h3><p>是一個有序的集合，可以包含重複的元素。我們可以使用索引來訪問和修改列表中的元素。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val numbers &#x3D; listOf(1, 2, 3, 4, 5)                             &#x2F;&#x2F; 定義不可變列表
val mutableNumbers &#x3D; mutableListOf(1, 2, 3, 4, 5)               &#x2F;&#x2F; 定義可變列表

println(&quot;List of numbers: $numbers&quot;)
println(&quot;List of mutableNumbers: $mutableNumbers&quot;)              &#x2F;&#x2F; 舊輸出

println(&quot;The first item of numbers: $&#123;numbers[0]&#125;&quot;)

mutableNumbers.add(6)                                           &#x2F;&#x2F; 為 mutableNumbers 新增一個元素為 6
println(&quot;New number for mutableNumbers: $&#123;mutableNumbers[5]&#125;&quot;)
println(&quot;List of mutableNumbers: $mutableNumbers&quot;)              &#x2F;&#x2F; 新輸出</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">List of numbers: [1, 2, 3, 4, 5]
List of mutableNumbers: [1, 2, 3, 4, 5]
The first item of numbers: 1
The newly added number for mutableNumbers: 6
List of mutableNumbers: [1, 2, 3, 4, 5, 6]</code></pre>

<h3 id="無序集合-Set-集合"><a href="#無序集合-Set-集合" class="headerlink" title="無序集合 Set (集合)"></a>無序集合 <code>Set</code> (集合)</h3><p>是一個不重複元素的集合，並且沒有特定的順序。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val fruits &#x3D; setOf(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;, &quot;orange&quot;)
val mutableFruits &#x3D; mutableSetOf(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;, &quot;orange&quot;)

println(&quot;Set of fruits: $fruits&quot;)
println(&quot;Set of mutableFruits: $mutableFruits&quot;)</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">Set of fruits: [apple, banana, orange]
Set of mutableFruits: [apple, banana, orange]</code></pre>

<p>相反，如果用 <code>List</code>，則會連同重複元素輸出：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val fruits &#x3D; listOf(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;, &quot;orange&quot;)
val mutableFruits &#x3D; mutableListOf(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;, &quot;orange&quot;)

println(&quot;List of fruits: $fruits&quot;)
println(&quot;List of mutableFruits: $mutableFruits&quot;)</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">List of fruits: [apple, banana, orange, orange]
List of mutableFruits: [apple, banana, orange, orange]</code></pre>

<h3 id="鍵值對集合-Map-映射"><a href="#鍵值對集合-Map-映射" class="headerlink" title="鍵值對集合 Map (映射)"></a>鍵值對集合 <code>Map</code> (映射)</h3><p>是一個鍵值對 (key-value) 的集合，每個元素都有一個唯一的鍵和對應的值。我們可以使用鍵來獲取相應的值。</p>
<div class="note info simple"><p>用 <code>to</code> 關鍵字進行鍵值對，格式：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val map &#x3D; mapOf(鍵 1 to 值 1, 鍵 2 to 值 2, ...)</code></pre></div>

<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val person &#x3D; mapOf(
    &quot;name&quot; to &quot;Steve&quot;,
    &quot;age&quot; to 15
)
val mutablePerson &#x3D; mutableMapOf(
    &quot;name&quot; to &quot;Heidi&quot;,
    &quot;age&quot; to 23
)

println(&quot;Map of person: $person&quot;)
println(&quot;Map of mutablePerson: $mutablePerson&quot;)     &#x2F;&#x2F; 舊輸出

println(&quot;The name of person: $&#123;person[&quot;name&quot;]&#125;&quot;)

mutablePerson[&quot;gender&quot;] &#x3D; &quot;F&quot;                       &#x2F;&#x2F; 為 mutablePerson 新增 gender 屬性，並設置為 &quot;F&quot; (女性)
println(&quot;Map of mutablePerson: $mutablePerson&quot;)     &#x2F;&#x2F; 新輸出</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">Map of person: &#123;name&#x3D;Steve, age&#x3D;15&#125;
Map of mutablePerson: &#123;name&#x3D;Heidi, age&#x3D;23&#125;
The name of person: Steve
Map of mutablePerson: &#123;name&#x3D;Heidi, age&#x3D;23, gender&#x3D;F&#125;</code></pre>

<h2 id="集合函數操作"><a href="#集合函數操作" class="headerlink" title="集合函數操作"></a>集合函數操作</h2><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val numbers &#x3D; listOf(1, 2, 3, 4, 5)
    
val evenNumbers &#x3D; numbers.filter &#123; it % 2 &#x3D;&#x3D; 0 &#125;            &#x2F;&#x2F; 篩選出偶數
val doubleNumbers &#x3D; numbers.map &#123; it * 2 &#125;                  &#x2F;&#x2F; 把每個數字都加倍
val sum &#x3D; numbers.reduce &#123; acc, i -&gt; acc + i &#125;              &#x2F;&#x2F; 計算總和 (即 1 + 2 + 3 + 4 + 5)

println(&quot;evenNumbers: $evenNumbers&quot;)
println(&quot;doubleNumbers: $doubleNumbers&quot;)
println(&quot;sum: $sum&quot;)</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">evenNumbers: [2, 4]
doubleNumbers: [2, 4, 6, 8, 10]
sum: 15</code></pre>

<div class="note info simple"><ul>
<li><code>filter</code>：返回的是 <code>Boolean</code> 型別</li>
<li><code>map</code>：對集合進行不同操作，沒有指定返回型別</li>
<li><code>reduce</code>：累積函數，第一個參數 <code>acc</code> (accumulation) 是用來疊加的返回值，第二個參數 <code>i</code> 是本次循環中列表的值</li>
<li><code>fold</code>：與 <code>reduce</code> 相似，但可設定初始值</li>
</ul>
</div>

<hr>
<h1 id="列舉"><a href="#列舉" class="headerlink" title="列舉"></a>列舉</h1><p>列舉是一組相關的常量的集合，它們可以幫助我們更好地組織和表示程式中的數據。在 Kotlin 中，我們可以使用 <code>enum class</code> 關鍵字來定義一個列舉類。</p>
<ol>
<li><p>基本列舉</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">enum class Direction &#123;
    NORTH, SOUTH, EAST, WEST
&#125;

val direction &#x3D; Direction.NORTH
println(direction)      &#x2F;&#x2F; 輸出：NORTH</code></pre>
</li>
<li><p>列舉初始值：可以像一般建構式擁有屬性和方法。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">enum class Color(val rgb: Int) &#123;
    RED(0xFF0000),
    GREEN(0x00FF00),
    BLUE(0x0000FF);

    fun printRgb() &#123;
        println(&quot;RGB value: $rgb&quot;)
    &#125;
&#125;

val color &#x3D; Color.RED
println(color.rgb)      &#x2F;&#x2F; 輸出：16711680
color.printRgb()        &#x2F;&#x2F; 輸出：RGB value: 16711680</code></pre></li>
</ol>
<hr>
<h1 id="註解"><a href="#註解" class="headerlink" title="註解"></a>註解</h1><p>註解 (Annotations) 是一種用於在程式碼中添加元數據（metadata）的特殊標記。它們可以應用於類、函數、變數等元素上，並提供額外的資訊給編譯器、工具或其他程式碼分析工具。</p>
<ol>
<li><p>使用 Kotlin 內建註解</p>
<table>
<thead>
<tr>
<th>註解</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>@JvmStatic</code></td>
<td>用於將 Kotlin 中的伴生對象（companion object）中的函數或屬性轉換為 Java 中的靜態函數或靜態屬性。</td>
</tr>
<tr>
<td><code>@JvmOverloads</code></td>
<td>用於在 Kotlin 中生成重載函數的所有可能的組合。</td>
</tr>
<tr>
<td><code>@Deprecated</code></td>
<td>標記已被棄用的函數、類或屬性，並提供一個建議的替代方案。</td>
</tr>
</tbody></table>
</li>
<li><p>編寫自訂註解</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">annotation class MyAnnotation

@MyAnnotation
class MyClass &#123;
    @MyAnnotation
    fun myFunction() &#123;
        &#x2F;&#x2F; 函數內容
    &#125;
&#125;</code></pre></li>
</ol>
<h2 id="元資訊"><a href="#元資訊" class="headerlink" title="元資訊"></a>元資訊</h2><table>
<thead>
<tr>
<th>元資訊</th>
<th>用途</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Target</code></td>
<td>用於指定註解可以應用的元素類型</td>
<td>如 <code>@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION)</code> 可以應用於類和函數上</td>
</tr>
<tr>
<td><code>@Retension</code></td>
<td>用於指定註解在編譯後的保留策略</td>
<td>例如 <code>@Retention(AnnotationRetention.RUNTIME)</code> 表示該註解在運行時仍然可用</td>
</tr>
<tr>
<td><code>@Repeatable</code></td>
<td>用於指定註解是否可以重複應用於同一個元素。通常，一個元素只能擁有一個特定註解的實例</td>
<td></td>
</tr>
<tr>
<td><code>@MustBeDocumented</code></td>
<td>用於指示該註解應該包含在生成的 API 文檔中</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><code>@Repeatable</code><br>通常，一個元素只能擁有一個特定註解的實例。但是，如果你將 <code>@Repeatable</code> 註解應用於註解定義上，則可以多次應用該註解於同一個元素。這需要使用一個容器註解來包裹重複的註解。<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Repeatable
annotation class MyAnnotation(val name: String)

@MyAnnotation(&quot;A&quot;)
@MyAnnotation(&quot;B&quot;)
class MyClass &#123;
    &#x2F;&#x2F; ...
&#125;</code></pre></li>
</ul>
<p>例子</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">@Target(AnnotationTarget.CONSTRUCTOR, AnnotationTarget.LOCAL_VARIABLE)
@Retention(AnnotationRetention.SOURCE)
@MustBeDocumented
annotation class MyAnnotation

class MyClass @MyAnnotation constructor(val count: Int) &#123;
    fun display()&#123;
        println(&quot;Constructor annotated&quot;)
        println(&quot;Count is $count&quot;)
    &#125;
&#125;

fun main() &#123;
    val obj &#x3D; MyClass(5)
    obj.display()
    @MyAnnotation val str &#x3D; &quot;Hello&quot; 
    println(&quot;Local parameter annotated&quot;)
    println(str)
&#125;</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">Constructor annotated
Count is 5
Local parameter annotated
Hello</code></pre>

<hr>
<h1 id="條件判斷"><a href="#條件判斷" class="headerlink" title="條件判斷"></a>條件判斷</h1><h2 id="決策邏輯"><a href="#決策邏輯" class="headerlink" title="決策邏輯"></a>決策邏輯</h2><h3 id="if-語句"><a href="#if-語句" class="headerlink" title="if 語句"></a><code>if</code> 語句</h3><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val age &#x3D; 18
if (age &gt;&#x3D; 18) &#123;
    println(&quot;你已經成年了&quot;)
&#125; else &#123;
    println(&quot;你還未成年&quot;)
&#125;</code></pre>

<h3 id="else-if-語句"><a href="#else-if-語句" class="headerlink" title="else if 語句"></a><code>else if</code> 語句</h3><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val grade &#x3D; 75
if (grade &gt;&#x3D; 90) &#123;
    println(&quot;A&quot;)
&#125; else if (grade &gt;&#x3D; 80) &#123;
    println(&quot;B&quot;)
&#125; else if (grade &gt;&#x3D; 70) &#123;
    println(&quot;C&quot;)
&#125; else &#123;
    println(&quot;D&quot;)
&#125;</code></pre>

<h3 id="單行-if-表達式"><a href="#單行-if-表達式" class="headerlink" title="單行 if 表達式"></a>單行 <code>if</code> 表達式</h3><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val score &#x3D; 80
val result &#x3D; if (score &gt;&#x3D; 60) &quot;及格&quot; else &quot;不及格&quot;
println(result)</code></pre>

<h2 id="情況邏輯"><a href="#情況邏輯" class="headerlink" title="情況邏輯"></a>情況邏輯</h2><p><code>when</code> 表達式類似於 Java 使用的 <code>switch</code> 語句，可以用於根據不同的值執行不同的程式邏輯。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val dayOfWeek &#x3D; 3
when (dayOfWeek) &#123;
    1 -&gt; println(&quot;星期一&quot;)
    2 -&gt; println(&quot;星期二&quot;)
    3 -&gt; println(&quot;星期三&quot;)
    4 -&gt; println(&quot;星期四&quot;)
    5 -&gt; println(&quot;星期五&quot;)
    else -&gt; println(&quot;週末&quot;)
&#125;</code></pre>

<p><code>when</code> 比 Java 的 <code>switch</code> 更勝一籌，表達式還可以用於檢查範圍、類型和其他條件。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val names &#x3D; listOf(&quot;John&quot;, &quot;Sarah&quot;, &quot;Tim&quot;, &quot;Maggie&quot;) 
when (x) &#123;
    in names -&gt; print(&quot;I know that name!&quot;)
    !in 1..10 -&gt; print(&quot;Argument was not in the range from 1 to 10&quot;)
    is String -&gt; print(x.length)
&#125;</code></pre>

<h1 id="迴圈"><a href="#迴圈" class="headerlink" title="迴圈"></a>迴圈</h1><h2 id="while-迴圈"><a href="#while-迴圈" class="headerlink" title="while 迴圈"></a><code>while</code> 迴圈</h2><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">var i &#x3D; 0
while (i &lt; 5) &#123;
    i++
    println(i)
&#125;</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">1
2
3
4
5</code></pre>

<h2 id="for-迴圈"><a href="#for-迴圈" class="headerlink" title="for 迴圈"></a><code>for</code> 迴圈</h2><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">for (i in 1..5) println(i)</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">1
2
3
4
5</code></pre>

<h2 id="forEach-迴圈"><a href="#forEach-迴圈" class="headerlink" title="forEach 迴圈"></a><code>forEach</code> 迴圈</h2><p>可以運用集合 (Collections) 與<code>forEach</code> 函數簡化 <code>for</code> 語法代碼操作。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val list &#x3D; listOf(1, 2, 3, 4, 5)
list.forEach &#123;
    println(it)
&#125;</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">1
2
3
4
5</code></pre>

<hr>
<h1 id="智慧轉型"><a href="#智慧轉型" class="headerlink" title="智慧轉型"></a>智慧轉型</h1><p>Kotlin 很聰明，當我們使用 <code>is</code> 關鍵字檢查一個變數是否為特定類型後，Kotlin 會自動將該變數轉型為該類型。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun printLength(obj: Any) &#123;
    if (obj is String) &#123;
        &#x2F;&#x2F; 在這裡，Kotlin 自動將 obj 轉型為 String 類型
        println(obj.length)
    &#125;
&#125;</code></pre>

<p>而 Java 則要手動轉型</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public void printLength(Object obj) &#123;
    if (obj instanceof String) &#123;
        &#x2F;&#x2F; 在這裡，我們需要手動將 obj 轉型為 String 類型
        String str &#x3D; (String) obj;
        System.out.println(str.length());
    &#125;
&#125;</code></pre>

<hr>
<h1 id="空安全"><a href="#空安全" class="headerlink" title="空安全"></a>空安全</h1><p>空安全是 Kotlin 中一個非常重要的特性，它可以幫助我們避免許多空指針異常（<code>NullPointerException</code>）。</p>
<h2 id="從陣列中清除空值"><a href="#從陣列中清除空值" class="headerlink" title="從陣列中清除空值"></a>從陣列中清除空值</h2><p>如果你想從可為空的 <code>Iterable</code> 或陣列中消除 <code>null</code> 值，你可以使用 <code>filterNotNull()</code> 函數。這個函數將返回一個新的集合，其中不包含 <code>null</code> 值。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val listWithNulls: List&lt;Int?&gt; &#x3D; listOf(1, 2, null, 4, null, 6)
val listWithoutNulls &#x3D; listWithNulls.filterNotNull()

println(listWithNulls)                  &#x2F;&#x2F; 輸出：[1, 2, null, 4, null, 6]
println(listWithoutNulls)               &#x2F;&#x2F; 輸出：[1, 2, 4, 6]</code></pre>

<h2 id="空合併及-Elvis-運算符"><a href="#空合併及-Elvis-運算符" class="headerlink" title="空合併及 Elvis 運算符 ?:"></a>空合併及 Elvis 運算符 <code>?:</code></h2><p>可以在變數為 <code>null</code> 時提供一個默認值。如果變數為 <code>null</code>，則 Elvis 運算符將返回其右側的表達式作為結果，否則返回變數本身。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val name: String? &#x3D; null
val length1 &#x3D; name?.length
val length2 &#x3D; name?.length ?: &quot;0&quot;

println(&quot;Length 1: $length1&quot;)           &#x2F;&#x2F; 輸出：null
println(&quot;Length 2: $length2&quot;)           &#x2F;&#x2F; 輸出：0</code></pre>

<h2 id="安全調用符"><a href="#安全調用符" class="headerlink" title="安全調用符 ?."></a>安全調用符 <code>?.</code></h2><p>處理可為空的變數時，我們需要使用安全調用運算符（<code>?.</code>）來訪問它的屬性或呼叫它的方法。這樣可以避免空指針異常。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val name: String? &#x3D; null
val length &#x3D; name?.length

println(&quot;Length: $length&quot;)              &#x2F;&#x2F; 輸出：null</code></pre>

<p>通常會連同 <code>let</code> 標準函數一起使用</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val name: String? &#x3D; null
name?.let &#123;
    println(&quot;Length: $&#123;it.length&#125;&quot;)     &#x2F;&#x2F; 沒有輸出
&#125;</code></pre>

<h2 id="非空斷言"><a href="#非空斷言" class="headerlink" title="非空斷言 !!"></a>非空斷言 <code>!!</code></h2><p>可以在確定變數不為 <code>null</code> 的情況下強制執行操作。</p>
<div class="note warning simple"><p>使用 <code>!!</code> 運算符需要謹慎使用，因為它可能引發空指針異常 (<code>KotlinNullPointerException</code>)。</p>
<p>只有在你確定變數不為 <code>null</code> 的情況下才應該使用非空斷言運算符 <code>!!</code>。否則，建議使用安全調用運算符 <code>?.</code> 來處理可為空的變數，以避免空指針異常的風險。</p>
</div>

<p><img src="/post/dev-kotlin-integrated-notes/img7.png" alt="img7"></p>
<hr>
<h1 id="委託"><a href="#委託" class="headerlink" title="委託"></a>委託</h1><p>指物件將一個請求委派給另一個物件來處理，將其讀取和寫入操作委託給其他對象。</p>
<ol>
<li><p>例如現在我想要一個新的 <code>OnlyHelloClass</code> 支援 <code>AllClass</code> 的 <code>sayHello()</code> 函數，如果直接把其繼承，就有失原意，因為我只想要支援 <code>sayHello()</code> 函數，結果把 <code>sayGoodbye()</code> 都帶過來了。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">open class AllClass &#123;
    fun sayHello() &#x3D; println(&quot;Hello&quot;)
    fun sayGoodbye() &#x3D; println(&quot;Goodbye&quot;)
&#125;
class OnlyHelloClass : AllClass()</code></pre>
<p><img src="/post/dev-kotlin-integrated-notes/img8.png" alt="img8"><br>要解決這個問題，可以用介面（interface）</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">interface HelloDelegate &#123;
    fun sayHello() &#x3D; AllClass().sayHello()
&#125;
class OnlyHelloClass : HelloDelegate</code></pre>
<p>現在這個 <code>OnlyHelloClass</code> 就只可以用 <code>sayHello()</code> 函數了。<br><img src="/post/dev-kotlin-integrated-notes/img9.png" alt="img9"><br>亦可以用 <code>by</code> 關鍵字委託哪一個 <code>Class</code> 去處理：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">interface HelloDelegate &#123;
    fun sayHello() &#x3D; AllClass().sayHello()
&#125;

open class AllClass: HelloDelegate &#123;
    override fun sayHello() &#x3D; println(&quot;Hello&quot;)
    fun sayGoodbye() &#x3D; println(&quot;Goodbye&quot;)
&#125;

class OnlyHelloClass(private val delegate: HelloDelegate): HelloDelegate by delegate

fun main() &#123;
    OnlyHelloClass(AllClass()).sayHello()
&#125;</code></pre>
</li>
<li><p>有些情況下，我們可能不希望立即刪除被棄用的屬性，因為有一些舊有的程式碼可能還在使用這個屬性。為了向後兼容性，我們可以將存取委託給新的屬性，這樣舊有的程式碼仍然可以使用這個屬性，同時建議開發者在新的程式碼中使用替代方案。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">class DelegateTest &#123;
    var newName &#x3D; &quot;New Name&quot;
    @Deprecated(&quot;Use &#39;newName&#39; instead&quot;, ReplaceWith(&quot;newName&quot;))
    var oldName by this::newName
&#125;

val test &#x3D; DelegateTest()
test.oldName &#x3D; &quot;Old Name&quot;
println(test.newName)         &#x2F;&#x2F; 輸出：Old Name</code></pre></li>
</ol>
<h2 id="委託屬性"><a href="#委託屬性" class="headerlink" title="委託屬性"></a>委託屬性</h2><h3 id="lazy-屬性"><a href="#lazy-屬性" class="headerlink" title="lazy 屬性"></a><code>lazy</code> 屬性</h3><p>這個委託屬性用於<strong>惰性初始化</strong>。它只有在第一次訪問屬性時才會計算其值，以後的訪問將直接返回已計算的值。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val result by lazy &#123;
    println(&quot;初始化&quot;)
&#125;
println(&quot;執行: $result&quot;)
println(&quot;執行: $result&quot;)            &#x2F;&#x2F; 即使第二次執行，都不會再出現 &quot;初始化&quot;</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">初始化
執行: kotlin.Unit
執行: kotlin.Unit</code></pre>

<h3 id="observable-屬性"><a href="#observable-屬性" class="headerlink" title="observable 屬性"></a><code>observable</code> 屬性</h3><p>這個委託屬性用於觀察屬性的變化。它接收一個初始值和一個回調函數，當屬性的值發生變化時，將調用回調函數。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">class ObservableTest &#123;
    var name by Delegates.observable(&quot;初始值&quot;) &#123; property, oldValue, newValue -&gt;  
        println(&quot;結果: $oldValue -&gt; $newValue&quot;)
    &#125;
&#125;
val observableTest &#x3D; ObservableTest() 
observableTest.name &#x3D; &quot;first&quot;
observableTest.name &#x3D; &quot;second&quot;

print(observableTest)</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">結果: 初始值 -&gt; first
結果: first -&gt; second</code></pre>

<h3 id="vetoable-屬性"><a href="#vetoable-屬性" class="headerlink" title="vetoable 屬性"></a><code>vetoable</code> 屬性</h3><p>這個委託屬性用於在設置屬性值之前進行驗證。它接收一個初始值和一個驗證回調函數，當設置屬性的新值時，將調用驗證回調函數以確定是否接受該值。如果驗證回調函數返回 <code>false</code>，則不接受該值並保持原始值。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">var value by Delegates.vetoable(0) &#123; _, oldValue, newValue -&gt;
    newValue &gt; oldValue
&#125;

value &#x3D; 5           &#x2F;&#x2F; 設置新值，將通過驗證
println(value)

value &#x3D; 2           &#x2F;&#x2F; 設置新值，將被驗證拒絕
println(value)</code></pre>

<p>執行結果：</p>
<pre class="line-numbers language-none"><code class="language-none">5
5</code></pre>]]></content>
      <categories>
        <category>程式編寫</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Roblox 開發 | 建立插件</title>
    <url>/post/roblox-dev-create-plugins.html</url>
    <content><![CDATA[<p>進行 Roblox 開發時，我們往往都會用到一些插件。比如是熱門的 AutoScale 插件，一個轉換 Offset 為 Scale 的實用插件，這個插件點擊後，會出現一個 GUI 視窗，這裏會簡單記錄怎寫 GUI 視窗插件。</p>
<hr>
<h1 id="釐定插件及-GUI-資訊及設定"><a href="#釐定插件及-GUI-資訊及設定" class="headerlink" title="釐定插件及 GUI 資訊及設定"></a>釐定插件及 GUI 資訊及設定</h1><p>這步主要是做類似組態 (Configuration)，可做可不做。</p>
<pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">--&gt; 插件名稱
local NAME &#x3D; &quot;PluginName&quot;
--&gt; 插件描述
local DESCRIPTION &#x3D; &quot;This is my first plugin&quot;
--&gt; 插件按鈕圖示
local ICON &#x3D; &quot;rbxassetid:&#x2F;&#x2F;4458901886&quot;

--&gt; GUI 視窗預設寬度
local WINDOW_DEFAULT_WIDTH &#x3D; 500
--&gt; GUI 視窗預設高度
local WINDOW_DEFAULT_HEIGHT &#x3D; 300
--&gt; GUI 視窗最小寬度
local WINDOW_MINIMUM_WIDTH &#x3D; 500
--&gt; GUI 視窗最小高度
local WINDOW_MINIMUM_HEIGHT &#x3D; 300</code></pre>

<hr>
<h1 id="增設工具列"><a href="#增設工具列" class="headerlink" title="增設工具列"></a>增設工具列</h1><p>要把插件啟用之前，要先把它寫入工具列 (Toolbar)。</p>
<pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">local toolbar &#x3D; plugin:CreateToolbar(NAME)</code></pre>

<p>然後就要配置插件的 GUI 視窗。</p>
<pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">local widgetInfo &#x3D; DockWidgetPluginGuiInfo.new(
    Enum.InitialDockState.Float, false, false, WINDOW_DEFAULT_WIDTH, WINDOW_DEFAULT_HEIGHT, WINDOW_MINIMUM_WIDTH, WINDOW_MINIMUM_HEIGHT
)

--&gt; GUI 視窗
local mainWindow &#x3D; plugin:CreateDockWidgetPluginGui(NAME, WidgetInfo)
mainWindow.Title &#x3D; NAME
</code></pre>

<h2 id="加入按鈕至工具列"><a href="#加入按鈕至工具列" class="headerlink" title="加入按鈕至工具列"></a>加入按鈕至工具列</h2><p>基本上，都是用按鈕來觸發插件。</p>
<pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">local button &#x3D; Toolbar:CreateButton(NAME, DESCRIPTION, ICON)</code></pre>

<p>這裏可以做一個行為就是，開啟&#x2F;關閉 GUI 視窗。</p>
<pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">button.Click:Connect(function()
    mainWindow.Enabled &#x3D; not mainWindow.Enabled
end)</code></pre>

<div class="note info simple"><p>要注意的是這裏是寫插件，按鈕點擊事件是用 <code>Click</code> 而不是 <code>Activated。</code></p>
</div>

<hr>
<h1 id="加入內容至-GUI-視窗"><a href="#加入內容至-GUI-視窗" class="headerlink" title="加入內容至 GUI 視窗"></a>加入內容至 GUI 視窗</h1><p>剛才我們已經定義了 <code>mainWindow</code> 這個東西，所以如果你要寫入 UI 元素，並放到 <code>Parent</code> 就用 <code>mainWindow。</code></p>
<p>例如：</p>
<pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">local Frame &#x3D; Instance.new(&quot;Frame&quot;)
Frame.Name &#x3D; &quot;MainFrame&quot;
Frame.Parent &#x3D; mainWindow

--&gt; 其他在 MainFrame 內的 UI 元素</code></pre>

<p>那基本上就完成了。</p>
]]></content>
      <categories>
        <category>程式編寫</category>
        <category>Roblox 開發</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>Roblox</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetpack Compose 開發 | 跨平台項目開發筆記</title>
    <url>/post/jetpack-compsoe-dev-compose-multiplatform-notes.html</url>
    <content><![CDATA[<div class="note info simple"><p>現在可使用官方的生成模板。<br><a href="https://kmp.jetbrains.com/">https://kmp.jetbrains.com/</a></p>
</div>

<h1 id="新建跨平台-KMM-項目"><a href="#新建跨平台-KMM-項目" class="headerlink" title="新建跨平台 (KMM) 項目"></a>新建跨平台 (KMM) 項目</h1><details class="folding-tag"><summary> 如果還沒設置環境，這裏簡單說一下 </summary>
              <div class="content">
              <p>在開始前，可以用 KDoctor 工具來檢查所配置的環境是正確的。</p><ol><li><p>透過使用 Homebrew 安裝 KDoctor</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brew install kdoctor</code></pre></li><li><p>在終端機執行 KDoctor</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kdoctor</code></pre></li><li><p>如果配置的環境是正確的，會得出以下的結果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Environment diagnose (to see all details, use -v option):
[✓] Operation System
[✓] Java
[✓] Android Studio
[✓] Xcode
[✓] Cocoapods

Conclusion:
✓ Your system is ready for Kotlin Multiplatform Mobile development!</code></pre></li></ol><div class="note danger simple"><p>如果在執行 <code>kdoctor</code> 時，可能會在最後的階段 Cocoapods 報錯：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Environment diagnose (to see all details, use -v option):
[✓] Operation System
[✓] Java
[✓] Android Studio
[✓] Xcode
[✖] Cocoapods
✖ System ruby is currently used
    CocoaPods is not compatible with system ruby installation on Apple M1 computers.
    Please install ruby via Homebrew, rvm, rbenv or other tool and make it default
    Detailed information: https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;64901180&#x2F;how-to-run-cocoapods-on-apple-silicon-m1&#x2F;66556339#66556339
✖ CocoaPods requires your terminal to be using UTF-8 encoding.
    Consider adding the following to ~&#x2F;.zprofile
    export LC_ALL&#x3D;en_US.UTF-8</code></pre><p>雖然錯誤訊息提議你按照做法，加入以下的代碼：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">✖ CocoaPods requires your terminal to be using UTF-8 encoding.
    Consider adding the following to ~&#x2F;.profile:
    export LANG&#x3D;en_US.UTF-8</code></pre><p>但是還是不行，就納了個悶了。要是這樣，</p><ol><li>先狠狠的刪掉 Cocapods：<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 若使用 Homebrew 安裝
brew uninstall cocoapods

# 若使用 gem 安裝
sudo gem uninstall cocoapods</code></pre></li><li>再用 <code>gem</code> 重新安裝，並指定安裝版本為 <code>1.10.2</code><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo gem install cocoapods -v 1.10.2 -n &#x2F;usr&#x2F;local&#x2F;bin</code></pre></li></ol></div>
              </div>
            </details>

<ol>
<li>打開 Android Studio，選擇 Compose Multiplatform Template，選擇 Regular 依賴管理項。</li>
<li>在 <code>gradle.properties</code> 新增以下設定：<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">kotlin.version&#x3D;1.8.20
agp.version&#x3D;8.0.1
compose.version&#x3D;1.4.0

org.jetbrains.compose.experimental.uikit.enabled&#x3D;true
kotlin.native.cacheKind&#x3D;none</code></pre></li>
<li>打開根目錄 <code>build.gradle.kts</code> 然後在 <code>plugins</code> 區塊，使用以下代碼取代原有代碼：<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">kotlin(&quot;multiplatform&quot;).apply(false)
id(&quot;com.android.application&quot;).apply(false)
id(&quot;com.android.library&quot;).apply(false)
id(&quot;org.jetbrains.compose&quot;).apply(false)</code></pre></li>
<li>在 <code>shared</code> 模塊<br><code>build.gradle.kts</code> 的 <code>plugins</code> 區塊新增：<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">id(&quot;org.jetbrains.compose&quot;)</code></pre>
然後找 <code>baseName = &quot;shared&quot;</code>，在下方新增：<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">isStatic &#x3D; true</code></pre>
在 <code>sourceSets</code> 區塊新增以下代碼:<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val commonMain by getting &#123;
    dependencies &#123;
        implementation(compose.runtime)
        implementation(compose.foundation)
        implementation(compose.material)
        @OptIn(org.jetbrains.compose.ExperimentalComposeLibrary::class)
        implementation(compose.components.resources)
    &#125;
&#125;</code></pre></li>
<li>在 <code>androidApp</code> 模塊 <code>build.gradle.kts</code> 的 <code>plugins</code> 區塊新增：<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">id(&quot;org.jetbrains.compose&quot;)</code></pre></li>
<li>打開 <code>settings.gradle.kts</code>，然後找 <code>repositories</code> 區塊，<code>pluginManagement</code> 和 <code>dependencyResolutionManagement</code> 的 <code>repositories</code> 區塊都要新增：<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">maven(&quot;https:&#x2F;&#x2F;maven.pkg.jetbrains.space&#x2F;public&#x2F;p&#x2F;compose&#x2F;dev&quot;)</code></pre>
然後在 <code>pluginManagement</code> 區塊下方新增：<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">plugins &#123;
    val kotlinVersion &#x3D; extra[&quot;kotlin.version&quot;] as String
    val agpVersion &#x3D; extra[&quot;agp.version&quot;] as String
    val composeVersion &#x3D; extra[&quot;compose.version&quot;] as String

    kotlin(&quot;jvm&quot;).version(kotlinVersion)
    kotlin(&quot;multiplatform&quot;).version(kotlinVersion)
    kotlin(&quot;android&quot;).version(kotlinVersion)

    id(&quot;com.android.application&quot;).version(agpVersion)
    id(&quot;com.android.library&quot;).version(agpVersion)

    id(&quot;org.jetbrains.compose&quot;).version(composeVersion)
&#125;</code></pre></li>
<li>按 Sync Project</li>
</ol>
<hr>
<h1 id="跨平台配置"><a href="#跨平台配置" class="headerlink" title="跨平台配置"></a>跨平台配置</h1><h2 id="iOS-應用程式支援"><a href="#iOS-應用程式支援" class="headerlink" title="iOS 應用程式支援"></a>iOS 應用程式支援</h2><ol>
<li><p>在 <code>shared</code> 模塊裏的 <code>iosMain</code> 新增 <code>App.kt</code></p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">fun MainController() &#x3D; ComposeUIController &#123; App &#125;</code></pre>
</li>
<li><p>打開 Xcode，在 <code>iosApp</code> 新增 Swift 檔案 <code>ComposeView.swift</code></p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">import Foundation
import SwiftUI
import shared

struct ComposeView: UIViewControllerRepresentable &#123;
    func updateUIViewController(_ uiViewController: UIViewControllerType, context: Context) &#123;&#125;
    
    func makeUIViewController(context: Context) -&gt; some UIViewController &#123;
        AppKt.MainViewController()
    &#125;
&#125;</code></pre>
</li>
<li><p>然後在 <code>ContentView.swift</code> 的 <code>body</code> 加入剛寫的 <code>ComposeView</code></p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">struct ContentView: View &#123;
    var body: some View &#123;
        ComposeView()
    &#125;
&#125;</code></pre></li>
</ol>
<!-- ## Desktop 應用程式支援

無論是 Windows 或是 macOS 都可以。



## Web (網頁) 應用程式支援 -->]]></content>
      <categories>
        <category>程式編寫</category>
        <category>Jetpack Compose 開發</category>
        <category>跨平台開發</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Android</tag>
        <tag>Swift</tag>
        <tag>HTML</tag>
        <tag>iOS</tag>
        <tag>Desktop</tag>
      </tags>
  </entry>
  <entry>
    <title>Roblox 開發 | 入手編寫筆記</title>
    <url>/post/roblox-dev-get-started-notes.html</url>
    <content><![CDATA[<div class="note info simple"><p>這篇基本上是我入手編寫 Roblox 體驗手稿的筆記，這裏公開出來，給大家可以一起參透一下。<br>更何況，我在這個範疇 (Roblox 體驗手稿開發) 單純是「業餘」意思，只是輕輕接觸一下而已，順便嘗一嘗我未曾接觸過的 Luau （又稱 Lua，Roblox 官方稱其為 Luau）手稿語言。</p>
</div>

<hr>
<h1 id="Lua，對我而言，是新的程式語言"><a href="#Lua，對我而言，是新的程式語言" class="headerlink" title="Lua，對我而言，是新的程式語言"></a>Lua，對我而言，是新的程式語言</h1><p>在 Roblox 體驗開發中，無論是編寫客戶端（即是玩家自己），或是伺服器端，都要用到 Lua 手稿語言編寫。</p>
<p>Roblox 使用 Lua 的原因：</p>
<ol>
<li>一個仿似 C、C# 或 C++ 的程式語言，但省略繁瑣的工序，例如毋須起始定義 <code>Main</code>，而是可以直接在手稿程式中立即編寫。</li>
<li>Roblox 認受性以及對象絕大多數都是來自較年輕的玩家，所以以這種<strong>高階程式語言</strong>編寫，有助輕鬆處理遊戲邏輯。</li>
</ol>
<p>Lua 不只應用於編寫 Roblox 體驗及遊戲，還可以進行：</p>
<ul>
<li>網頁開發：因為 Lua 能與伺服器端溝通，所以可以建置及編寫網上應用程式以及開發人員工具。</li>
<li>數據分析：常應用於<strong>機器學習</strong>，建構數據預測的模型及算法。</li>
<li>軟件開發：編寫邏輯複雜的遊戲之餘，亦可以為手機應用程序編寫伺服器端的邏輯。</li>
<li>學術研究：<strong>原型開發</strong>及<strong>概念驗證</strong>實作，如<strong>領域特定語言</strong> (DSL) 就是其中一項成功的試驗。</li>
</ul>
<hr>
<h1 id="萬變不離其宗：界面與編程"><a href="#萬變不離其宗：界面與編程" class="headerlink" title="萬變不離其宗：界面與編程"></a>萬變不離其宗：界面與編程</h1><h2 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h2><p>在 Roblox Studio 中，我們可以在總管內的 <code>StarterGui</code> 新建一個新的 <code>ScreenGui</code>，來設計界面。</p>
<p>常用組件：</p>
<ul>
<li><code>Frame</code>：一個仿似容器的框，用來顯示特定的 UI 元素，亦可使用框來分類，如： <code>MainFrame</code>、<code>TopBarFrame</code>、<code>ContentFrame</code>。</li>
<li><code>TextLabel</code>：顯示文字的基本元素。</li>
<li><code>TextButton</code>：與 <code>TextLabel</code> 一樣，不過增設了點擊事件等的附加操作。</li>
<li><code>TextBox</code>：輸入文本的框。</li>
<li><code>ImageLabel</code>：顯示圖像的基本元素。</li>
<li><code>ImageButton</code>：<code>ImageLabel</code> 及 <code>TextButton</code> 的結合品。</li>
</ul>
<p>設計界面時要注意的要點：</p>
<ol>
<li>因為 Roblox 是跨平台的，所以要同時考慮其他裝置的屏幕顯示界面的結果。</li>
<li>拖曳 UI 元素的時候，預設更改的值是 <code>Offset</code> (偏移量)，要同時兼顧所有屏幕，需要改用 <code>Scale</code> 比例 (<code>0</code> 至 <code>1</code>)。</li>
</ol>
<h2 id="編程"><a href="#編程" class="headerlink" title="編程"></a>編程</h2><h3 id="界面編程"><a href="#界面編程" class="headerlink" title="界面編程"></a>界面編程</h3><p>剛剛才說完界面拖曳 UI 元素，其實都可以編寫客戶端手稿來構建界面。</p>
<div class="note info simple"><p>在 Lua 的單行註釋 (comment) 中，因為用的語法符是 <code>--</code>，不太輕易閱讀，所以我會以 <code>--&gt;</code> 樣式進行註解（某些開發者的偏好以 <code>--//</code> 樣式），用哪個都沒差，看個人偏好而已。</p>
</div>

<pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">--&gt; 服務 (Services)
local Players &#x3D; game:GetService(&quot;Players&quot;)

--&gt; 獲取目前的玩家 (玩家自己)
local Player &#x3D; Players.LocalPlayer

--&gt; 從玩家自己中獲取 PlayerGui
local PlayerGui &#x3D; Players.LocalPlayer:WaitForChild(&quot;PlayerGui&quot;)</code></pre>

<div class="note danger simple"><p>常見的痛病：</p>
<pre class="line-numbers language-diff" data-language="diff"><code class="language-diff">-local StarterGui &#x3D; game:GetService(&quot;StarterGui&quot;)
+local PlayerGui &#x3D; Players.LocalPlayer:WaitForChild(&quot;PlayerGui&quot;)</code></pre>

<p>用了 <code>StarterGui</code> 而不是 <code>PlayerGui</code>，所以<strong>寫完出來的界面依舊沒有顯示</strong>，因為 <code>StarterGui</code> 在運行遊戲時是不存在的，如果在 <code>StarterGui</code> <strong>利用拖曳 UI 元素方式構建界面，最終是會被遷移到玩家的 <code>PlayerGui</code> 的</strong>，所以要用的是 <code>PlayerGui</code>。</p>
<p>至於為什麼要 <code>WaitForChild(&quot;PlayerGui&quot;)</code> 呢？因為這個 <code>PlayerGui</code> 不是即時出來的，需要等待玩家加入遊戲了，然後玩家的角色模型加載好了，才有 <code>PlayerGui</code>。</p>
</div>

<h2 id="客戶端與伺服器端"><a href="#客戶端與伺服器端" class="headerlink" title="客戶端與伺服器端"></a>客戶端與伺服器端</h2><p>剛剛都講到。寫這門程式是分客戶端和伺服器端，官方提供了 3 類 Scripts：</p>
<ol>
<li><code>LocalScript</code> 客戶端</li>
<li><code>Script</code> 伺服器端</li>
<li><code>ModuleScript</code>：如果在客戶端執行模塊內函數程式，就是客戶端，反之就是伺服器端</li>
</ol>
<h3 id="客戶端"><a href="#客戶端" class="headerlink" title="客戶端"></a>客戶端</h3><p>客戶端寫的程式就是只會對玩家自己，不會對所有玩家造成影響，例如：</p>
<pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">local function setSkinHeadColor(player, brickColor)
    local Character &#x3D; player.Character
    for _, _ in pairs(Character:GetChildren()) do
        local bodyColors &#x3D; Character:FindFirstChild(&quot;Body Colors&quot;)
        if bodyColors then
            bodyColors.HeadColor &#x3D; brickColor
        end
    end
end

setSkinHeadColor(Players.LocalPlayer, BrickColor.Red())</code></pre>

<p>改變了的頭部顏色，只有你看到，其他玩家看不到你有這個外觀改變。如果你想其他玩家都看到，就要學會寫伺服器端和遠端事件。</p>
<h3 id="伺服器端-遠端事件"><a href="#伺服器端-遠端事件" class="headerlink" title="伺服器端 - 遠端事件"></a>伺服器端 - 遠端事件</h3><p>遠端事件是伺服器端最常用的一個東西，就是當某些官方提供的 API，例如你在客戶端執行它創，可能會報錯：</p>
<pre class="line-numbers language-none"><code class="language-none">xxx can only be called from the Server</code></pre>

<p>這個時候，遠端事件就大派用場了。</p>
<p>你可以直接在工作區總管在 <code>ReplicatedStorage</code> 加入 <code>RemoteEvent</code> 或者直接用程式新增一個：</p>
<pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">local MyRemoteEvent &#x3D; Instance.new(&quot;RemoteEvent&quot;, ReplicatedStorage)
MyRemoteEvent.Name &#x3D; &quot;MyRemoteEvent&quot;</code></pre>

<table>
<thead>
<tr>
<th align="center">客戶端 → 伺服器端</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">客戶端</td>
<td><code>RemoteEvent:FireServer(args)</code></td>
</tr>
<tr>
<td align="center">伺服器端</td>
<td><code>RemoteEvent.OnServerEvent:Connect(function(player, args))</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">伺服器端 → 客戶端</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">伺服器端</td>
<td><code>RemoteEvent:FireClient(player, args)</code></td>
</tr>
<tr>
<td align="center">客戶端</td>
<td><code>RemoteEvent.OnClientEvent:Connect(function(args))</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">伺服器端 → 所有客戶端（所有玩家）</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">伺服器端</td>
<td><code>RemoteEvent:FireAllClients(args)</code></td>
</tr>
<tr>
<td align="center">客戶端</td>
<td><code>RemoteEvent.OnClientEvent:Connect(function(args))</code></td>
</tr>
</tbody></table>
<h4 id="客戶端-→-伺服器端"><a href="#客戶端-→-伺服器端" class="headerlink" title="客戶端 → 伺服器端"></a>客戶端 → 伺服器端</h4><p>在 <code>LocalScript</code> 用 <code>FireServer()</code> 觸發在伺服器端的遠端事件所寫程式</p>
<div class="note warning simple"><p><code>OnServerEvent:Connect()</code> 接受的參數首先一定要是 <code>Player</code> 類型的參數。</p>
</div>

<div class="tabs" id="c2s_code"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="c2s_code-1">伺服器端</button><button type="button" class="tab " data-href="c2s_code-2">客戶端</button></ul><div class="tab-contents"><div class="tab-item-content active" id="c2s_code-1"><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">ReplicatedStorage.MyRemoteEvent:Connect(function(player, brickColor)
    setSkinHeadColor(player, brickColor)
end)</code></pre></div><div class="tab-item-content" id="c2s_code-2"><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">ReplicatedStorage.MyRemoteEvent:FireServer(BrickColor.Red())</code></pre></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      <categories>
        <category>程式編寫</category>
        <category>Roblox 開發</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>Roblox</tag>
      </tags>
  </entry>
  <entry>
    <title>網頁開發 | Eruda 網頁源始碼在線檢查器</title>
    <url>/post/web-dev-eruda-online-web-inspect-tool.html</url>
    <content><![CDATA[<p>相信大家都知道，在桌上電腦利用滑鼠點擊右鍵會釋出選項界面，點擊「<strong>檢視原始碼」</strong> 或於網頁鏈結的 HTTP 或 HTTPS 協定的前綴加上 <code>view-source:</code> 可以檢視目前網頁所編寫的編碼，如 HTML、JavaScript 等編碼，但我們<strong>往往不能利用它檢視更詳細的資訊</strong>。有見於此，Google Chrome 開發了一個原始碼檢查器。</p>
<p>Google Chrome 桌上網頁版以及軟件都提供一個原始碼檢查器，用戶只需要點擊實體鍵盤上的「F12」鍵，即可呼喚它出來。可是，這個功能並<strong>沒有兼容手機版本</strong>的 Google Chrome，但這不代表我們不能嚐一嚐這玩意。</p>
<p><img src="/post/web-dev-eruda-online-web-inspect-tool/img1.jpeg" alt="img1"></p>
<p>最近，我找到一個 JavaScript 編碼，是用以直接呼喚該程序顯示於網頁上，雖然，這工具<strong>並非還原的相當完整</strong> ，但基本的功能都是支援的。</p>
<hr>
<h1 id="預備適合的瀏覽器"><a href="#預備適合的瀏覽器" class="headerlink" title="預備適合的瀏覽器"></a>預備適合的瀏覽器</h1><p>先從 <a target="_blank" href="https://play.google.com/store/apps/details?id=com.android.chrome">Google Play 商店</a> 或 <a target="_blank" href="https://apps.apple.com/hk/app/google-chrome/id535886823">App Store</a> 下載 Google Chrome 瀏覽器，並把其開啟。（<strong>此功能或許不適用予其他瀏覽器）</strong></p>
<hr>
<h1 id="新增書籤"><a href="#新增書籤" class="headerlink" title="新增書籤"></a>新增書籤</h1><p>隨便輸入一個網址，導向一個網站，然後，在左上角的<strong>豎式三點圖標</strong>內，點擊 <strong>「加入標籤」</strong> ，若手機用戶，則點擊<strong>空心星星圖標</strong>。</p>
<p>完成後，會顯示該書籤已成功加入。這時候，我們可以編輯該書籤。</p>
<hr>
<h1 id="編輯書籤並加入-JavaScript-編碼"><a href="#編輯書籤並加入-JavaScript-編碼" class="headerlink" title="編輯書籤並加入 JavaScript 編碼"></a>編輯書籤並加入 JavaScript 編碼</h1><p>把網址修改為以下編碼並把<code>名稱</code>修改為任意名稱，如輸入「Inspect」，並於網址的輸入框中加入以下編碼。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">javascript:
  (function () &#123;
    %C2%A0%C2%A0%C2%A0
    var script &#x3D; %C2%A0
    document.createElement(&#39;script&#39;);
    %C2%A0%C2%A0%C2%A0
    script.src&#x3D;&quot;&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;eruda&quot;;
    %C2%A0%C2%A0%C2%A0
    document.body.appendChild(script); 
    %C2%A0%C2%A0%C2%A0
    script.onload &#x3D; function () &#123;
      %C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0
      eruda.init()
      %C2%A0%C2%A0%C2%A0
    &#125;
  &#125;)();</code></pre>

<hr>
<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>在瀏覽器上方的搜尋框輸入「Inspect」（這是剛剛所命名的任意名稱），點擊確定便會出現該工具的懸浮圖標，點擊它便會出現其懸浮視窗。<strong>（若重新加載目前網頁，懸浮視窗會自動關閉，需要再次呼喚書籤）</strong></p>
<div class="note warning simple"><p>iOS 或 iPad 裝置或許需要點擊書籤直接呼喚，而不是輸入「Inspect」。</p>
</div>

<hr>
<h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>這個程序提供了許多功能，如<strong>檢視標示屬性、控制台，實時偵錯</strong>等，就由大家自己發掘嘍～</p>
<p><img src="/post/web-dev-eruda-online-web-inspect-tool/img2.jpeg" alt="img2"></p>
<div class="note warning simple"><p>Eruda 線上檢查器不能應用於本地網址的網頁。</p>
</div>

<hr>
<p>更多關於 Eruda 線上網頁檢查器可 <a href="https://eruda.liriliri.io/" target="_blank">按此</a>。</p>
]]></content>
      <categories>
        <category>網頁開發</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>網頁開發 | RESTful API 實作筆記</title>
    <url>/post/web-dev-restful-api-implementation-notes.html</url>
    <content><![CDATA[<p>在編程和開發時，都會可能接觸過使用人家寫的 API，例如可能是 Github API，有沒想過，實際是怎樣自家製一個 API 呢？那就要認識一下 RESTful API。</p>
<hr>
<h1 id="什麼是-RESTful-API"><a href="#什麼是-RESTful-API" class="headerlink" title="什麼是 RESTful API"></a>什麼是 RESTful API</h1><p>RESTful API (又稱 REST API，也就是廣泛使用的名稱)是一種設計風格，用於<strong>建立網絡應用程序和服務之間的通信</strong>。它基於HTTP協議，並使用常見的HTTP方法（如<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>）來執行操作。RESTful API的設計原則包括資源的唯一標識、資源的狀態轉換以及輕量級的通信。通過遵循這些原則，RESTful API可以提供<strong>可擴展性、可靠性和易於理解</strong>和使用的接口。</p>
<hr>
<h1 id="利用-Express-框架初建"><a href="#利用-Express-框架初建" class="headerlink" title="利用 Express 框架初建"></a>利用 Express 框架初建</h1><p>事前準備：</p>
<ol>
<li>安裝 <a href="https://nodejs.org/en/download">node 環境</a></li>
<li>新建一個任意名稱的資料夾，如 <code>rest-api-test</code></li>
</ol>
<p>透過 npm 安裝 Express 框架</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install express</code></pre>

<p>新建兩個檔案：</p>
<ul>
<li><code>app.js</code>: API 設定檔，定義 RESTful API</li>
<li><code>server.js</code>: 伺服設定檔</li>
</ul>
<h2 id="匯入-express-庫"><a href="#匯入-express-庫" class="headerlink" title="匯入 express 庫"></a>匯入 <code>express</code> 庫</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const express &#x3D; require(&#39;express&#39;);
const app &#x3D; express();</code></pre>

<h2 id="基本的幾個-Method"><a href="#基本的幾個-Method" class="headerlink" title="基本的幾個 Method"></a>基本的幾個 Method</h2><ul>
<li><code>POST</code>: <code>app.post()</code></li>
<li><code>GET</code>: <code>app.get()</code></li>
<li><code>PUT</code>: <code>app.put()</code></li>
<li><code>DELETE</code>: <code>app.delete()</code></li>
</ul>
<p>當然還有其他。</p>
<p>例如先簡單寫一個 <code>GET</code> method，輸出 <code>request /GET</code></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">app.get(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; &#123;
    res.send(&#39;request &#x2F;GET&#39;);
&#125;);</code></pre>

<p>完成編寫後，記得匯出模塊</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">module.exports &#x3D; app</code></pre>

<p>例如：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">app.get(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; &#123;
    res.send(&#39;request &#x2F;GET&#39;);
&#125;);
app.post(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; &#123;
    res.send(&#39;request &#x2F;POST&#39;);
&#125;);
app.put(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; &#123;
    res.send(&#39;request &#x2F;PUT&#39;);
&#125;);
app.delete(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; &#123;
    res.send(&#39;request &#x2F;DELETE&#39;);
&#125;);

module.exports &#x3D; app;</code></pre>

<div class="note info simple"><p><code>/</code> 是指起始的 API 網域，即 <code>localhost:3000</code>，如加了 <code>/api</code> 就是 <code>localhost:3000/api</code></p>
</div>

<h2 id="設定伺服器"><a href="#設定伺服器" class="headerlink" title="設定伺服器"></a>設定伺服器</h2><p>在 <code>server.js</code> 加入代碼：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const app &#x3D; require(&#39;.&#x2F;app&#39;);
const port &#x3D; process.env.PORT || 3000;
const server &#x3D; app.listen(port, function () &#123;
    console.log(&#96;Express started on port $&#123;port&#125;&#96;);
&#125;);</code></pre>

<div class="note info simple"><p><code>3000</code> 是設置啟動伺服器的端口為 <code>3000</code></p>
</div>

<h2 id="啟動伺服器並進行操作"><a href="#啟動伺服器並進行操作" class="headerlink" title="啟動伺服器並進行操作"></a>啟動伺服器並進行操作</h2><p>輸入指令可以啟動伺服器</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm start</code></pre>

<p>應該會有這個執行結果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; start
&gt; node server.js

Express started on port 3000</code></pre>

<p>開新一個終端機（我在用的是 VSCode）進行相關操作。</p>
<p>例如，測試 <code>GET</code> method，就輸入：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl -X GET localhost:3000</code></pre>

<div class="note info simple"><p><code>curl</code>: Linux 常用的指令，用於通過互聯網傳輸數據<br><code>-X</code>: (或可使用 <code>-request</code>)，指定 HTTP method 發出 HTTP request</p>
</div>

<p>輸入後應該會輸出：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">request &#x2F;GET</code></pre>

<hr>
<h1 id="瞭解更多"><a href="#瞭解更多" class="headerlink" title="瞭解更多"></a>瞭解更多</h1><h2 id="狀態碼-Status-code-處理"><a href="#狀態碼-Status-code-處理" class="headerlink" title="狀態碼 (Status code) 處理"></a>狀態碼 (Status code) 處理</h2><p>通常，一個 API 回應，都會有輸出狀態碼，這裏是基本的狀態碼說明：</p>
<p>大致分為 5 種：</p>
<ol>
<li>資訊回應 (Informational responses, <code>100</code> – <code>199</code>)</li>
<li>成功回應 (Successful responses, <code>200</code> – <code>299</code>)</li>
<li>重定向 (Redirects, <code>300 </code>– <code>399</code>)</li>
<li>用戶端錯誤 (Client errors, <code>400</code> – <code>499</code>)</li>
<li>伺服器端錯誤 (Server errors, <code>500</code> – <code>599</code>)</li>
</ol>
<p>資訊量太多了，我們先暫時使用我們最熟悉的 <code>202</code> 和 <code>404</code> 狀態碼。</p>
<div class="note info simple"><p>如果你不知道的話，這裏說一下：<br><code>202</code>: 表示 OK，請求成功<br><code>404</code>: 即是 “404 Not Found”，網絡上常見的用戶端錯誤，找不到請求資源</p>
</div>

<p>例如在 <code>GET</code> method 中寫狀態碼為 <code>200</code> 時的輸出。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">res.status(200).send(
    &#123;
        status: &#123;
            type: &#39;ok&#39;,
            message: &#39;request &#x2F;GET&#39;
        &#125;,
        data: null
    &#125;
);</code></pre>

<p>如果是 <code>404</code> 狀態碼：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">res.status(404).send(
    &#123;
        status: &#123;
            type: &#39;error&#39;,
            message: &#39;Invalid request.&#39;
        &#125;,
        data: null
    &#125;
);</code></pre>

<h2 id="查找字串參數-Query-parameter"><a href="#查找字串參數-Query-parameter" class="headerlink" title="查找字串參數 (Query parameter)"></a>查找字串參數 (Query parameter)</h2><p>宣找字串參數就是在URL中用於向服務器傳遞參數的一種方法。它們通常用於指定特定的查詢條件，以便在請求中傳遞給服務器。</p>
<div class="note info simple"><p>查詢參數出現在URL的問號（<code>?</code>）後面，並以<strong>鍵值對</strong>的形式表示。</p>
</div>

<p>例如現在有這樣的 URL 仍然是 <code>localhost:3000</code>，不過新建端點 (endpoint) <code>api</code>，即：</p>
<pre class="line-numbers language-none"><code class="language-none">localhost:3000&#x2F;api</code></pre>

<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">app.get(&#39;&#x2F;api&#39;, (req, res) &#x3D;&gt; &#123;
    let data &#x3D; decodeURI(req.query.question);
    res.json(&#123;
        result: data
    &#125;);
&#125;)</code></pre>

<div class="note info simple"><p>你也可以直接在 <code>server.js</code> 加入以下代碼：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">app.use(express.json());
app.use(express.urlencoded(&#123;
    extended: true
&#125;));</code></pre>
<p>那就可以不用額外加上 <code>decodeURI()</code></p>
</div>

<p>測試結果：</p>
<ol>
<li>不輸入查詢參數，報未下定義<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl -X GET localhost:3000&#x2F;api</code></pre>

輸出:<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#123;&quot;result&quot;:&quot;undefined&quot;&#125;</code></pre></li>
<li>輸入查詢參數<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl -X GET localhost:3000&#x2F;api\?question&#x3D;HelloWorld</code></pre>

輸出:<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#123;&quot;result&quot;:&quot;HelloWorld&quot;&#125;</code></pre>

<div class="note warning simple"><p>終端機輸入指令時，要記得轉義，不然報錯：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">zsh: no matches found: localhost:3000&#x2F;api?question&#x3D;HelloWorld</code></pre></div></li>
</ol>
<!--
## 表單參數 (Form parameter)

表單參數是在網頁表單中使用者輸入或選擇的數據。當使用者提交表單時，這些數據會被打包並以鍵值對的形式傳送到伺服器端。每個表單參數都有一個名稱和對應的值。當使用 `POST` 方法提交表單時，這些參數會被包含在請求主體中。
-->]]></content>
      <categories>
        <category>網頁開發</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>網頁開發 | 建構並用 Github 頁面寄存 Hexo 網誌</title>
    <url>/post/web-dev-create-hexo-blog-tutorial.html</url>
    <content><![CDATA[<p>大家好，歡迎來到我的網誌。欸。。？這裏為什麼好像。。整個樣子都不一樣啊。。</p>
<p>對啦，因為我「搬家」了。</p>
<hr>
<h1 id="棄暗投明轉用-Hexo"><a href="#棄暗投明轉用-Hexo" class="headerlink" title="棄暗投明轉用 Hexo"></a>棄暗投明轉用 Hexo</h1><p>為什麼我要由 Google Blogspot 轉用 Hexo？因為 Blogspot 在加載網誌實在太慢了！！！！有時還要跑不起來。。。於是就改用 Hexo 建立網誌了，安裝方法不複雜，現在開始。</p>
<hr>
<h1 id="版本與系統環境"><a href="#版本與系統環境" class="headerlink" title="版本與系統環境"></a>版本與系統環境</h1><p>本文章將會根據以下規格建立 Hexo 網誌。</p>
<table>
<thead>
<tr>
<th>軟體&#x2F;作業系統</th>
<th>版本號碼</th>
</tr>
</thead>
<tbody><tr>
<td>作業系統</td>
<td>macOS Ventura 13</td>
</tr>
<tr>
<td>Git</td>
<td>v2.39.0</td>
</tr>
<tr>
<td>Nodejs</td>
<td>v18.12.1</td>
</tr>
<tr>
<td>hexo</td>
<td>v6.3.0</td>
</tr>
<tr>
<td>hexo-cli</td>
<td>v4.3.0</td>
</tr>
<tr>
<td>文本編輯軟件</td>
<td>Visual Studio Code</td>
</tr>
</tbody></table>
<div class="note info simple"><p>Git 和 Nodejs 和 Hexo 會稍後教大家安裝。</p>
</div>

<hr>
<h1 id="什麼是-Hexo？"><a href="#什麼是-Hexo？" class="headerlink" title="什麼是 Hexo？"></a>什麼是 Hexo？</h1><p>Hexo 是一個快速、簡單且強大的網誌框架。<strong>Hexo 使用 Markdown（或其他標記語言）解析您的文章</strong>，並在幾秒鐘內，透過漂亮的主題產生靜態檔案。</p>
<div class="note warning simple"><p>我用的是 macOS，Windows 用戶可參考 官方文案（但其實與 macOS 的差不多，可作以下內容參考）。<br>以下我的安裝教學是使用 Homebrew，請預必先安裝 Homebrew 以繼續接下來的教學，請到 官方網站 瞭解安裝 Homebrew。</p>
</div>

<hr>
<h1 id="套件安裝"><a href="#套件安裝" class="headerlink" title="套件安裝"></a>套件安裝</h1><ol>
<li>Nodejs: 可到官方下載 Nodejs 軟件包，<a href="http://nodejs.org/">按此下載</a> 。</li>
<li>Git<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brew install git
brew install git-gui</code></pre></li>
<li>Hexo<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install -g hexo-cli</code></pre></li>
</ol>
<hr>
<h1 id="解決-EACCES-權限問題"><a href="#解決-EACCES-權限問題" class="headerlink" title="解決 EACCES 權限問題"></a>解決 EACCES 權限問題</h1><p>不過，如果在嘗試安裝 Hexo 的過程中出現 EACCES 權限錯誤，請遵循由 npmjs 發布的指導修復該問題。官方<strong>強烈建議不要使用 <code>root</code>、<code>sudo</code> 等方法覆蓋權限</strong>。</p>
<div class="note warning simple"><p><strong>通常 macOS 都會出現 EACCES 權限錯誤</strong>，你可以在執行解決方法前<strong>先備份電腦</strong>，以免不慎出錯。<br>就算你真的想逆官方的意願，都有機會是使用 <code>sudo</code> 方法都不可行。</p>
</div>

<p>在執行 <code>npx install -g hexo-cli</code> 時會報錯：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Error: EACCES: permission denied, access &#39;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#39;
npm ERR!  &#123; Error: EACCES: permission denied, access &#39;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#39;
npm ERR!   stack: &#39;Error: EACCES: permission denied, access \&#39;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules\&#39;&#39;,
npm ERR!   errno: -13,
npm ERR!   code: &#39;EACCES&#39;,
npm ERR!   syscall: &#39;access&#39;,
npm ERR!   path: &#39;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#39; &#125;
npm ERR!
npm ERR! Please try running this command again as root&#x2F;Administrator.
npm ERR! A complete log of this run can be found in:
npm ERR!     &#x2F;Users&#x2F;nieyuling&#x2F;.npm&#x2F;_logs&#x2F;2019-02-14T07_10_39_923Z-debug.log</code></pre>

<p>簡而言之，因為沒有權限，這裏有簡單的解決方法：在終端機輸入。</p>
<ol>
<li>首先，先在根目錄裏建立新資料夾 <code>npm-global</code>。<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir ~&#x2F;.npm-global</code></pre></li>
<li>然後把新資料夾 <code>npm-global</code> 設定為 npm 預設路徑。<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">NPM_CONFIG_PREFIX&#x3D;~&#x2F;.npm-global</code></pre></li>
</ol>
<p>詳情可見 <a href="https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally">npmjs 指導</a> 。</p>
<hr>
<h1 id="安裝-VSCode-擴充套件"><a href="#安裝-VSCode-擴充套件" class="headerlink" title="安裝 VSCode 擴充套件"></a>安裝 VSCode 擴充套件</h1><p>雖然<strong>官方比較建議 macOS 用戶使用 XCode</strong>，但我堅決不把它下載下來，因為。。它有 7.8GB 之多啊。。。（其實我下載過，不過後來把它刪除了哈哈）。</p>
<p>而我是較常用 VSCode 的，所以就推薦大家用 VSCode，何況 VSCode 有 Hexo 擴充套件，何樂而不為呢？</p>
<p>到 VSCode 擴充套件庫下載 <code>vscode-hexo</code>，或<a href="vscode:extension/codeyu.vscode-hexo">按此下載</a> 。</p>
<hr>
<h1 id="開始建置-Hexo"><a href="#開始建置-Hexo" class="headerlink" title="開始建置 Hexo"></a>開始建置 Hexo</h1><ol>
<li>首先在理想檔案路徑建立新資料夾，如命名為 <code>Hexo</code><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir hexo</code></pre></li>
<li>前往所建資料夾，再進 npx 界面<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd hexo
npx</code></pre></li>
</ol>
<h2 id="Hexo-指令"><a href="#Hexo-指令" class="headerlink" title="Hexo 指令"></a>Hexo 指令</h2><div class="note info simple"><p>指令建議在 npx 界面進行輸入。</p>
</div>

<h3 id="初始化網誌"><a href="#初始化網誌" class="headerlink" title="初始化網誌"></a>初始化網誌</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo init [資料夾名稱]</code></pre>

<p>例：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo init my-blog</code></pre>

<h3 id="新增文章"><a href="#新增文章" class="headerlink" title="新增文章"></a>新增文章</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new [文章名稱]</code></pre>

<p>例：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new &quot;HelloWorld&quot;</code></pre>

<div class="note warning simple"><p>文章名稱是將會應用並命名到檔案名稱，所以請以英文為主，<strong>慎防和遲免程式因亂碼出錯</strong>，還有<strong>不需要加上副檔名</strong>，因為會自動以 <code>.md</code> 格式生成，例如 <code>HelloWorld.md</code>。</p>
</div>

<hr>
<h4 id="文章的-Front-matter"><a href="#文章的-Front-matter" class="headerlink" title="文章的 Front-matter"></a>文章的 Front-matter</h4><p>Front-matter 是檔案最上方以 <code>---</code> 分隔的區域，用於指定個別檔案的變數，簡而言之，就是<strong>為文章進行配置上的設定</strong>。舉例來說：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">---
title: 文章標題
date: 2022-12-24 00:13:26
---

文章內容由此處開始</code></pre>

<div class="note info simple"><p><code>title</code>：文章的標題<br><code>date</code>：文章的建立日期，如果你是透過使用 <code>hexo new</code> 指令新增文章的話，建立日期是自動生成的。<br><code>updated</code>：文章的修改 &#x2F; 更新日期<br><code>id</code>：文章的特別編號<br><code>comment</code>：為文章啟用留言區 - <code>on</code> 為啟用；<code>off</code> 為關閉。<br><code>tags</code>：文章的標籤（每篇文章可設定多個標籤）<br><code>categories</code>：文章的類別 (每篇文章只可以設定一個類別) ，但隨着 Hexo 的更新，現在可以多種類別，做法如下：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">categories:
    - [&quot;category1&quot;, &quot;category2&quot;]</code></pre>
<p>我會怎樣運用它們？ 我會把類別當作範疇，例如 Android 開發、網頁開發，這些都是獨立的範疇；而我會用程式語言來作標籤，因為程式語言與這些範疇是環環相扣的。 或許你不是像我一樣撰寫編程類型的網誌文章，但希望你可以參考一下。</p>
</div>

<p>例如：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">---
id: 123
title: Hello World
date: 2022-12-24 00:13:26
categories:
    - Red Fruits
tags:
    - Apple
    - Strawberry
    - Red berry
---
文章內容由此處開始</code></pre>

<p>這裏有一個應用例子：取自這個評論 。</p>
<div calss="anzhiyu-tag-link"><a class="tag-Link" target="_blank" href="http://disq.us/p/1u9nad0">
    <div class="tag-link-tips">引用站外地址</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style>
          <i class="anzhiyufont anzhiyu-icon-link" style></i>
        </div>
        <div class="tag-link-right">
            <div class="tag-link-title">應用例子</div>
            <div class="tag-link-sitename"> 並列分類及子分類應用</div>
        </div>
        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>
    </div>
    </a></div>

<div class="note info simple"><p>並列分類：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">categories:
    - [Linux]
    - [Tools]</code></pre>
<p>並列 + 子分類：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">categories:
    - [Linux, Hexo]
    - [Tools, PHP]</code></pre></div>

<h3 id="部署文章"><a href="#部署文章" class="headerlink" title="部署文章"></a>部署文章</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo deploy</code></pre>

<h4 id="本機預覽"><a href="#本機預覽" class="headerlink" title="本機預覽"></a>本機預覽</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo server</code></pre>

<p>這樣你便可以經 <code>localhost:4000</code> 本機伺服器看看預覽結果。</p>
<h2 id="部署到-GitHub"><a href="#部署到-GitHub" class="headerlink" title="部署到 GitHub"></a>部署到 GitHub</h2><h3 id="建立-Repository"><a href="#建立-Repository" class="headerlink" title="建立 Repository"></a>建立 Repository</h3><p>進入 GitHub 網頁，點擊 <code>New</code> 按鈕新建專案，把 <code>Repository name</code> 命名為 <code>username.github.io</code>。</p>
<div class="note info simple"><p><code>username</code> 是你的用戶名稱。</p>
</div>

<p>然後按 <code>Create repository</code>。那就成功建立網域 <code>username.github.io</code>。</p>
<h3 id="把檔案推送到-GitHub"><a href="#把檔案推送到-GitHub" class="headerlink" title="把檔案推送到 GitHub"></a>把檔案推送到 GitHub</h3><h4 id="安裝-Git-相關套件"><a href="#安裝-Git-相關套件" class="headerlink" title="安裝 Git 相關套件"></a>安裝 Git 相關套件</h4><p>回到 hexo 資料夾，在終端機輸入：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install hexo-deployer-git --save</code></pre>

<h4 id="修改-config-yml-檔案的-deploy-設定"><a href="#修改-config-yml-檔案的-deploy-設定" class="headerlink" title="修改 _config.yml 檔案的 deploy 設定"></a>修改 <code>_config.yml</code> 檔案的 deploy 設定</h4><div class="note warning simple"><p>這個 <code>_config.yml</code> 是 hexo 根目錄內，並非 <code>hexo/themes/</code> 內那個。</p>
</div>

<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">deploy:
    type: git
    repo: https:&#x2F;&#x2F;github.com&#x2F;username&#x2F;username.github.io.git
    branch: master</code></pre>

<ul>
<li><code>type</code>：選擇部屬模式，這裡填 <code>git</code></li>
<li><code>repo</code>：GitHub repository 的連結，記得將 <code>username</code> 修改成自己的帳號名稱</li>
<li><code>branch</code>：選擇分支，預設為 <code>master</code></li>
</ul>
<h3 id="預覽或部署三部曲"><a href="#預覽或部署三部曲" class="headerlink" title="預覽或部署三部曲"></a>預覽或部署三部曲</h3><p>在每次進行修改後，通常都會做以下三部曲，避免更新不完全。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</code></pre>

<p>如果你是要在本機伺服器預覽：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo cl &amp;&amp; hexo g &amp;&amp; hexo s</code></pre>

<ul>
<li><code>cl</code> 是 <code>clean</code>，清除快取檔案 <code>db.json</code> 和 <code>public</code> 已產生靜態檔案。</li>
<li><code>g</code> 是 <code>generate</code>，產生靜態檔案。</li>
<li><code>d</code> 是 <code>deploy</code>，部署網站。</li>
<li><code>s</code> 是 <code>server</code>，以本機伺服器 <code>localhost:4000</code> 預覽網站。<br>那就可以到 <code>https://username.github.io</code> 造訪網誌了。</li>
</ul>
<div class="note danger simple"><p>取決於網誌文章的數目，在一旦更新網誌內容後，你需要稍等片刻，因為 Github 需要一些時間才能夠成功部署。</p>
</div>

<hr>
<h1 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h1><p>用了 Hexo 後，發現它真的不錯用，沒有後悔推薦你們使用。</p>
<ol>
<li><p>加載速度快<br>這個我是精神為之一振的關鍵，皆因我都深陷了在 Blogspot 的緩慢維度一陣子了，對它尤其難受，有時想回味一下自己寫的文章內容，卻遲遲都不給我加載出來，那刻的雅興即時消逝，甚至會令到我漸漸不想再寫文章了。有了 Hexo，現在我可以「為所欲為」了，大肆寫文不是夢！<br>加載速度快不僅只是有利於我自己，更會有利於看文章的各位，文章加載的快能夠提升讀者的生活質素，而且都不會因為加載時間慢而不再在這個網誌發掘內容。就我而言，如果一些網站加載慢，不僅會讓我浮躁，而且令我有按「上一頁」的衝動，如此看來，如果你的網站加載時間慢，是絕對會令讀者數量流失，即使你寫的內容多麽的精細，都不會有人欣賞和明白你的心思。</p>
</li>
<li><p>支援 Markdown 標示語言<br>對我來說簡直就是一個字，棒！因為 Markdown 的方便程度是遠高於 HTML 的，在我用 Blogspot 的時候，是用 HTML 撰文的，當我要插入程式碼塊，就要用 <code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code>，那大家知道了，<code>&lt;pre&gt;</code> 是不會編製為跳脫字元的，例如要在程式碼塊加入 HTML 碼，它會以 HTML 顯示了出來，但其實我想展示 HTML 碼給讀者，那這樣就要另外解析，雖然網上都有一鍵解析的工具，但是都是很不方便。<br>不說插入程式碼，其實要定義一般標示都是不方便的，因為大部分的標示都是開閉式的，所以在我寫文的時候，常精都要注意 HTML 的語法，整體感覺不良好。相較之下 Markdown 就方便多了，尤其是我要編製程式碼塊，用 <code>```</code> 語法就可以把一整段程式碼展示出來，不需要理會跳脫字元的問題。另外，因為 Hexo 是終端架設工具，所以檔案是在自己電腦裏，就可以用 VSCode 打開並修改 Markdown 語法的文章，配合快捷鍵的運用，更是事半功倍。</p>
</li>
<li><p>支援內建外掛<br>網誌的文章是你隨心而寫的，因此你寫的內容可能很寛廣的，涉及的東西很多元化，有時可能都要借助一些插件來完成，Hexo 是支援外建外掛的，那可以令到你的網誌不但多元性，而且增加趣味性，例如可以額外擴增日曆、提示塊等。</p>
</li>
<li><p>支援內建主題<br>文章的內容是最重要，而網誌的主題是次要，雖然是次要，但主題能吸引讀者的眼球，主題並不只是說你的網誌主題樣式，還會說排版，有一個好看的版面，就不會令讀者迷失。另外，主題都能反映你的個人風格，當你選擇了一個適合你的主題，便會深深「入坑」。</p>
</li>
</ol>
<p>Hexo 提供了許多主題樣式，有復古的，現代的等等不同風格的主題，重點是，都是免費的！</p>
<p>好了教學到這了，希望大家學會用 Hexo 建立網誌，有問題歡迎在下面留言，下篇文章再見。</p>
]]></content>
      <categories>
        <category>程式編寫</category>
        <category>網頁開發</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
