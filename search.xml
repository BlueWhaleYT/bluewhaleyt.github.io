<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【Android】Firebase 專案初建及配置</title>
    <url>/post/android-firebase-setup-notes.html</url>
    <content><![CDATA[<p>Firebase 是一個由 Google 提供的<strong>綜合性後端開發平台</strong>，它提供一系列的雲端服務及工具，幫助開發者快速構建高品質的應用程式，是一個相當舉足輕重的必要工具之一。</p>
<p>Firebase 提供的服務繁多：</p>
<ul>
<li>身份驗證 (Authentication)：Firebase Authentication 是一個用於用戶身份驗證的服務。它提供了一個簡單且安全的方式，讓開發者可以<strong>輕鬆地管理用戶的註冊、登錄和密碼重置</strong>等功能。Firebase Authentication 支持多種身份驗證方式，包括電子郵件&#x2F;密碼、第三方登錄等。<div calss="anzhiyu-tag-link"><a class="tag-Link" target="_blank" href="/post/jetpack-compose-firebase-auth-notes">
    <div class="tag-link-tips">引用站外地址</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style>
          <i class="anzhiyufont anzhiyu-icon-link" style></i>
        </div>
        <div class="tag-link-right">
            <div class="tag-link-title">身份驗證</div>
            <div class="tag-link-sitename"> 看文章瞭解如何使用 Firebase 進行身份驗證</div>
        </div>
        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>
    </div>
    </a></div></li>
<li>即時資料庫 (Realtime Database)：Firebase Realtime Database 是一個 NoSQL 的<strong>非關聯式資料的雲端數據庫</strong>，它提供了一個實時同步的方式來存儲和同步應用中的數據。開發者可以使用 Firebase Realtime Database 來創建基於事件驅動的應用程序，並實現實時的數據更新。它支持離線緩存，可以在斷網環境下繼續工作，並在網絡連接恢復時自動同步數據。<div calss="anzhiyu-tag-link"><a class="tag-Link" target="_blank" href="/post/jetpack-compose-firebase-auth-notes">
    <div class="tag-link-tips">引用站外地址</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style>
          <i class="anzhiyufont anzhiyu-icon-link" style></i>
        </div>
        <div class="tag-link-right">
            <div class="tag-link-title">即時資料庫</div>
            <div class="tag-link-sitename"> 看文章瞭解如何使用 Firebase 即時資料庫</div>
        </div>
        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>
    </div>
    </a></div></li>
<li>雲端存儲 (Cloud Firestore)：Firebase Cloud Firestore 是一個靈活且可擴展的 NoSQL 文件數據庫，亦是一個 Firebase Realtime Database 的繼代工具。它提供了一個可靠的方式來存儲和同步大規模的結構化數據。Cloud Firestore 支持實時更新，可以在多個平台上保持數據的同步。它還提供了<strong>強大的查詢功能，可以輕鬆地檢索和過濾數據</strong>。</li>
<li>資料分析 (Analytics)：Firebase Analytics 是一個用於應用程式分析的工具。它<strong>可以收集用戶互動和行為數據，並提供有關應用的洞察和指標</strong>。開發者可以使用 Firebase Analytics 來了解用戶的使用情況、用戶行為和應用性能等。它還提供了自定義事件和用戶屬性，以便開發者更好地了解和分析用戶行為。</li>
<li>推播通知 (Cloud Messaging)：Firebase Cloud Messaging (FCM) 是一個強大的推送通知服務。它可以將消息推送到 Android、iOS 和 Web 應用中的用戶。開發者可以使用 FCM 來<strong>向用戶發送即時通知、提醒和促銷訊息</strong>。FCM 還提供了<strong>高度可靠的消息傳遞和自定義的目標設定功能</strong>，可以根據用戶的屬性和行為來定向推送消息。</li>
</ul>
<p>我們瞭解到 Firebase 的強大之處，但有利就必有弊。它雖然具有許多優點，但也有一些潛在的壞處需要考慮：</p>
<div class="table-procons">

<table>
<thead>
<tr>
<th>優點</th>
<th>缺點</th>
</tr>
</thead>
<tbody><tr>
<td>快速開發：Firebase 提供了一個完整的後端解決方案，開發者可以輕鬆地使用它的功能來快速構建應用程序。<strong>不需要自己從頭開始構建和維護後端服務</strong>，可以<strong>節省大量的開發時間和成本。</strong></td>
<td>依賴性：使用 Firebase 意味著開發者將自己的應用程序納入 Google 的生態系統中。這可能使開發者對 Google 的服務和工具產生依賴性，<strong>如果 Firebase 服務發生故障或變更，可能會對應用程序造成影響。</strong></td>
</tr>
<tr>
<td>跨平台支持：Firebase 不僅支持 Android 平台，還支持其他平台，如 iOS、Web 和 Unity 等。這使得開發者可以<strong>使用相同的後端服務和工具來開發多個平台</strong>的應用程序，提高了開發效率。</td>
<td>成本問題：雖然 Firebase 有一個免費的層級，<strong>但某些高級功能和使用量可能需要付費</strong>。如果應用程序的需求超出了免費層級的限制，可能需要支付額外的費用。開發者需要仔細評估他們的預算和需求，以確定是否適合使用 Firebase。</td>
</tr>
<tr>
<td>強大的功能：Firebase 提供了各種強大的功能，包括<strong>數據庫、身份驗證、雲端存儲、應用分發、推送通知和分析</strong>等。這些功能可以幫助開發者解決常見的開發需求，如數據存儲、用戶管理、消息推送和應用監控等。</td>
<td>自定義性限制：Firebase 提供了許多預先建立的功能和工具，但對於一些特定的需求，開發者可能需要進一步自定義和擴展。<strong>Firebase 的功能和工具是有限的，並且可能無法滿足所有開發者的需求</strong>。在使用 Firebase 之前，<strong>開發者應評估其功能是否符合他們的需求</strong>。</td>
</tr>
<tr>
<td>可擴展性：Firebase 的服務是<strong>高度可擴展</strong>的，可以應對大量的用戶和數據。Firebase 的基礎設施由 Google 提供和維護，<strong>開發者不需要擔心服務的可用性和性能問題</strong>。</td>
<td>數據安全性：由於 Firebase 是一個雲端服務，開發者需要注意數據的安全性問題。儘管 Firebase 提供了一些安全功能，如身份驗證和數據庫規則，但<strong>開發者仍需要確保正確配置和使用這些功能</strong>，以保護用戶數據的安全。</td>
</tr>
</tbody></table>
</div>

<div calss="anzhiyu-tag-link"><a class="tag-Link" target="_blank" href="https://firebase.google.com/?gad_source=1&gclid=Cj0KCQiAzoeuBhDqARIsAMdH14E1OZTSpa-Pc_QyB_d8abyoYTb-LUJ-clC4fGEW1lNGnu1lA85eDBMaAkg-EALw_wcB&gclsrc=aw.ds">
    <div class="tag-link-tips">引用站外地址</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style>
          <i class="anzhiyufont anzhiyu-icon-link" style></i>
        </div>
        <div class="tag-link-right">
            <div class="tag-link-title">Firebase</div>
            <div class="tag-link-sitename"> 點擊前往 Firebase 官網，瞭解更多有關 Firebase 的其他功能。</div>
        </div>
        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>
    </div>
    </a></div>

<hr>
<h1 id="建立新的-Firebase-專案"><a href="#建立新的-Firebase-專案" class="headerlink" title="建立新的 Firebase 專案"></a>建立新的 Firebase 專案</h1><p>首先，你需要前往 <a href="https://console.firebase.google.com/">Firebase 主控台</a>新建一個專案。</p>
<p><span class="step" data-step="1" data-title="設置專案名稱"></span></p>
<p>通常，這個新建的 Firebase 專案名稱會根據所開發的應用程式名稱而命名，例如應用程式名稱為 ComposeFirebase，這個專案名稱順理成章都會是 ComposeFirebase，這個是為了方便辨認哪一個 Firebase 專案是屬於何者應用程式使用。</p>
<p><img src="/post/android-firebase-setup-notes/img1.png" alt="新建一個 Firebase 專案"></p>
<div class="note info simple"><p>Firebase 專案的別名 (Alias) 會根據所命名的專案名稱，而在後綴附上額外編號，例如這個範例是 <code>composefirebase-1cc26</code>，從而避免有重複專案的存在。</p>
</div>

<p><span class="step" data-step="2" data-title="註冊應用程式"></span></p>
<p>然後，你需要把這個專案與應用程式產生鏈結，這裏要輸入應用程式的套件名稱及名稱。</p>
<p><img src="/post/android-firebase-setup-notes/img3.png" alt="註冊應用程式"></p>
<p><span class="step" data-step="3" data-title="設置 SHA-1 偵錯簽署憑證"></span></p>
<p>SHA-1（Secure Hash Algorithm 1） 是一種加密演算法，用於正確識別應用程式及身份，<strong>雖然官方指明這個 SHA-1 偵錯簽署憑證是選填的，但我高度建議設置 SHA-1 偵錯簽署憑證</strong>。</p>
<div class="note danger simple"><p>SHA-1 偵錯簽署憑證是一個極為重要的安全性設定，以下事項需要注意：</p>
<ol>
<li>當你<strong>沒有設置 SHA-1 偵錯簽署憑證</strong>，Firebase 預設會<strong>使用應用程式的套件名稱進行識別及驗證</strong>，如果有其他應用程式有相同的套件名稱，它們通通都被視為有效的驗證，這些應用程式可以訪問到用戶的登入資訊，<strong>潛在安全風險</strong>。因此，<strong>設置 SHA-1 偵錯簽署憑證</strong>作為一個指紋，有效可以與應用程式進行相匹配，<strong>防止其他未經驗證的應用程式</strong>試圖訪問用戶的帳號資訊。</li>
<li>另外，當前獲取的 SHA-1 偵錯簽署憑證是根據預設的偵錯模式 (debug mode)，<strong>當你要把應用程式構建發佈模式 (release mode)，你要獲取發佈模式的 Keystore 證書的 SHA-1 偵錯簽署憑證，然後再次下載新的 <code>google-services.json</code> 設定檔。</strong></li>
</ol>
</div>

<p>你有三種方法檢視應用程式的 SHA-1 偵錯簽署憑證：</p>
<ol>
<li>在終端機輸入指令<div class="tabs" id="code-sha-1-check"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="code-sha-1-check-1">MacOS/Linux</button><button type="button" class="tab " data-href="code-sha-1-check-2">Window</button></ul><div class="tab-contents"><div class="tab-item-content active" id="code-sha-1-check-1"><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">keytool -list -v \</span><br><span class="line">-<span class="built_in">alias</span> androiddebugkey -keystore ~/.android/debug.keystore</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="code-sha-1-check-2"><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">keytool -list -v \</span><br><span class="line">-<span class="built_in">alias</span> androiddebugkey -keystore %USERPROFILE%\.android\debug.keystore</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div></li>
<li>在 Android Studio 項目的終端機輸入 <code>gradlew</code>，如果不行，就試 <code>./gradlew</code>。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gradlew signingReport</span><br></pre></td></tr></table></figure></li>
<li>在 Gradle 工作區中的 <code>Tasks</code> &gt; <code>android</code> &gt; <code>signingReport</code> ，雙擊 <code>signingReport</code> 執行程序便會輸出應用程式的 SHA-1 偵錯簽署憑證。<br><img src="/post/android-firebase-setup-notes/img2.png" alt="執行 signingReport 後結果及檢查 SHA-1 偵錯簽署憑證"><div class="note warning simple"><p>如果找不到 <code>signingReport</code> 執行程序：<br><img src="/post/android-firebase-setup-notes/img4.png" alt="找不到 signingReport 執行程序"><br>請在 Android Studio 偏好設定中留意以下設定：</p>
<ul>
<li>較新版本（Hedgehog 或以上）：<strong>勾選</strong> Configure all Gradle tasks during Gradle Sync (this can make Gradle Sync slower)</li>
<li>較舊版本：<strong>取消勾選</strong> Only include test tasks in the Gradle task list generated during Gradle sync</li>
</ul>
</div></li>
</ol>
<p><span class="step" data-step="4" data-title="下載並新增 Google 服務設定檔"></span></p>
<p>你需要把 Firebase 生成的 <code>google-services.json</code> JSON 設定檔下載下來，然後把它放到 <code>app</code> 目錄裏。</p>
<p><img src="/post/android-firebase-setup-notes/img5.png" alt="加入 google-services.json 設定檔"></p>
<div class="note warning simple"><p>需要定時更新 <code>google-services.json</code> 設定檔，以確保所啟用的建構及服務能順利運作。</p>
</div>

<p><span class="step" data-step="5" data-title="植入 Google 服務到應用程式"></span></p>
<p>Firebase 依賴 Google 服務來執行的，你需要在根目錄的 <code>build.gradle.kts</code> 匯入 Google 服務的 classpath（在 <code>plugins</code> 區塊上方）。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">&quot;com.google.gms:google-services:4.4.0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然後在 <code>app</code> 目錄的 <code>build.gradle.kts</code> 引入 Google 服務的插件以及其函式庫。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Suppress(<span class="string">&quot;DSL_SCOPE_VIOLATION&quot;</span>)</span> <span class="comment">// <span class="doctag">TODO:</span> Remove once KTIJ-19369 is fixed</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    id(<span class="string">&quot;com.google.gms.google-services&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="初始化配合使用-Firebase-的應用程式"><a href="#初始化配合使用-Firebase-的應用程式" class="headerlink" title="初始化配合使用 Firebase 的應用程式"></a>初始化配合使用 Firebase 的應用程式</h1><p>完成了創建 Firebase 專案後，現在就要為應用程式與 Firebase 產生聯繫，方能使用 Firebase 的功能。</p>
<p><span class="step" data-step="1" data-title="准許訪問網絡權限"></span></p>
<p>你需要允許應用程式訪問網絡，從而能夠順利使用部分 Firebase 的網絡服務。請在 <code>AndroidManifest.xml</code> 的 <code>&lt;manifest&gt;</code> 區塊內宣告允許網絡權限。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><span class="step" data-step="2" data-title="匯入 Firebase BoM 物料清單"></span></p>
<p>你需要匯入 Firebase 函式庫，我們會使用 BoM (Bill of Materials) 物料清單匯入。因為 Firebase 提供許多不同功能模組，版本經常性需要作修改，假如你在使用許多功能模組，更新時需要手動逐個修改版本號，所有我們會使用 BoM，<strong>這樣只需要指定 BoM 版本，BoM 便會為你自動匯入該功能模組的穩定版</strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation(platform(<span class="string">&quot;com.google.firebase:firebase-bom:32.7.1&quot;</span>))</span><br><span class="line"><span class="comment">// Java</span></span><br><span class="line">implementation(<span class="string">&quot;com.google.firebase:firebase-common&quot;</span>)</span><br><span class="line"><span class="comment">// Kotlin</span></span><br><span class="line">implementation(<span class="string">&quot;com.google.firebase:firebase-common-ktx&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><span class="step" data-step="3" data-title="初始化 Firebase 程式"></span></p>
<p>然後，你要在應用程式的邏輯入口，初始化 Firebase 程序，才可以在往後執行 Firebase 的功能。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">FirebaseApp.initializeApp(context)</span><br></pre></td></tr></table></figure>

<p>以下是簡單範例，說明如何在傳統的 XML 及 Jetpack Compose 程式的入口點，初始化 Firebase 程式。</p>
<div class="tabs" id="code-initialize-firebase"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="code-initialize-firebase-1">Compose</button><button type="button" class="tab " data-href="code-initialize-firebase-2">XML</button></ul><div class="tab-contents"><div class="tab-item-content active" id="code-initialize-firebase-1"><p>在 Jetpack Compose 程式，在可組合項初始化 Firebase 程式都沒有問題。要注意的是需要使用 <code>LocalContext.current</code> 獲取目前的 <code>Context</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">ComponentActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContent &#123;</span><br><span class="line">            AppTheme &#123;</span><br><span class="line">                <span class="keyword">val</span> context = LocalContext.current</span><br><span class="line">                FirebaseApp.initializeApp(context)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="code-initialize-firebase-2"><p>在傳統 XML 程式，你需要在佈局設置完成後，才可初始化 Firebase 程式，使用 <code>this</code> 已經是 <code>Activity</code> (繼承自 <code>Context</code>) 的實例。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        FirebaseApp.initializeApp(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      <categories>
        <category>Android</category>
        <category>Firebase</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Bash</tag>
      </tags>
  </entry>
  <entry>
    <title>【Jetpack Compose】Firebase Authentication 帳號註冊及身份驗證 | 多平台第三方登入</title>
    <url>/post/jetpack-compose-firebase-auth-notes.html</url>
    <content><![CDATA[<p>當我們要編寫及開發一些社交媒體或需要用戶註冊一個帳戶時，許多時候這些的應用程式要求用戶註冊及登入一個新帳戶，這個帳戶是用來<strong>存取屬於該應用程式的帳戶資料及其他資料</strong>，亦用於識別帳戶。用戶除了可以<strong>透過電郵地址&#x2F;密碼來註冊，亦可以使用第三方平台</strong>的帳戶進行登入，如常見的 Google、Facebook 等。</p>
<p>未創建 Firebase 專案的請先看這篇文章：</p>
<div calss="anzhiyu-tag-link"><a class="tag-Link" target="_blank" href="/post/android-firebase-setup-notes">
    <div class="tag-link-tips">引用站外地址</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style>
          <i class="anzhiyufont anzhiyu-icon-link" style></i>
        </div>
        <div class="tag-link-right">
            <div class="tag-link-title">Firebase 專案配置</div>
            <div class="tag-link-sitename"> 看這篇文章瞭解如何配置 Firebase 專案</div>
        </div>
        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>
    </div>
    </a></div>

<hr>
<h1 id="初始化-Firebase-Authentication"><a href="#初始化-Firebase-Authentication" class="headerlink" title="初始化 Firebase Authentication"></a>初始化 Firebase Authentication</h1><p>Firebase Authentication 是 Firebase 其中一個常用的功能建構，它可以為應用程式實現身份驗證及第三方登入的程序。</p>
<p><span class="step" data-step="1" data-title="匯入 Firebase Authentication 函式庫"></span></p>
<p>首先，Firebase Authentication 是一個 Firebase 延伸的功能模組，對應模組名是 <code>firebase-auth</code>，你需要匯入 Firebase Authentication 函式庫才可使用相關的 API 程式碼。</p>
<div class="note info simple"><p>這裏使用 Firebase BoM 物料清單匯入。</p>
</div>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation(<span class="string">&quot;com.google.android.gms:play-services-auth:20.7.0&quot;</span>)</span><br><span class="line">implementation(<span class="string">&quot;com.google.firebase:firebase-auth&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><span class="step" data-step="2" data-title="宣告及初始化 FirebaseAuth 實例"></span></p>
<div class="tabs" id="code-init-firebaseauth"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="code-init-firebaseauth-1">Kotlin</button><button type="button" class="tab " data-href="code-init-firebaseauth-2">Java</button></ul><div class="tab-contents"><div class="tab-item-content active" id="code-init-firebaseauth-1"><p>在 Kotlin，我們可以使用 <code>Firebase</code> 實例中的 <code>auth</code> 屬性來獲取 <code>FirebaseAuth</code> 實例。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> auth = Firebase.auth</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="code-init-firebaseauth-2"><p>在 Java，我們需要使用 <code>FirebaseAuth</code> 實例中的 <code>getInstance()</code> 方法來獲取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FirebaseAuth</span> <span class="variable">auth</span> <span class="operator">=</span> FirebaseAuth.getInstance();</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>

<hr>
<h1 id="基本使用-Firebase-Authentication"><a href="#基本使用-Firebase-Authentication" class="headerlink" title="基本使用 Firebase Authentication"></a>基本使用 Firebase Authentication</h1><p>完成好 Firebase Authentication 的初始化工序後，接下來我們所宣告的 <code>auth</code> 變量將會經常被使用，因為大部分的身份驗證 API 程式碼都需要 <code>FirebaseAuth</code> 實例。</p>
<h2 id="註冊新用戶"><a href="#註冊新用戶" class="headerlink" title="註冊新用戶"></a>註冊新用戶</h2><p>在用戶初始使用應用程式時，通常都沒有現有帳戶的，所以這個註冊工序是必須的。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">auth.createUserWithEmailAndPassword(email, password)</span><br><span class="line">    .await()</span><br></pre></td></tr></table></figure>

<div class="note info simple"><p>以上方法只適用於以電郵地址&#x2F;密碼進行註冊帳戶。</p>
</div>

<h2 id="登入現有用戶"><a href="#登入現有用戶" class="headerlink" title="登入現有用戶"></a>登入現有用戶</h2><p>通常用戶註冊完後，接下來就是登入帳戶，就算<strong>用戶清空了或刪除了應用程式及資料</strong>，用戶仍可透過 Firebase Authentication <strong>所儲存的帳戶再次登入</strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">auth.signInWithEmailAndPassword(email, password)</span><br><span class="line">    .await()</span><br></pre></td></tr></table></figure>

<div class="note info simple"><p>以上方法只適用於以電郵地址&#x2F;密碼進行登入帳戶。</p>
</div>

<h2 id="登出帳戶"><a href="#登出帳戶" class="headerlink" title="登出帳戶"></a>登出帳戶</h2><p>當用戶想登出帳戶時，可能是更換其他帳戶、再次註冊新帳戶等程序，這個時候登出帳戶就重要了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">auth.signOut()</span><br></pre></td></tr></table></figure>

<div class="note info simple"><p>使用第三方登入的程式碼都是使用以上方法進行登出帳戶。</p>
</div>

<h2 id="檢查目前的身份驗證狀態"><a href="#檢查目前的身份驗證狀態" class="headerlink" title="檢查目前的身份驗證狀態"></a>檢查目前的身份驗證狀態</h2><p>許多時候，你會想<strong>用戶一旦完成登入帳戶後，用戶不需再進行登入多次</strong>，進入登入後的主介面，所以這個檢查身份驗證狀態是必要的，通常就是檢查用戶是否已登入。如果用戶已登入，則可以直接進入主介面，否則則會進行註冊&#x2F;登入介面。</p>
<p>原來，我們可以使用 <code>FirebaseAuth</code> 的 <code>getCurrentUser()</code> 方法，檢查如果這個獲取的 <code>currentUser</code> 是空的話，就代表用戶尚未登入。</p>
<div class="tabs" id="code-check-user-auth-status"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="code-check-user-auth-status-1">Kotlin</button><button type="button" class="tab " data-href="code-check-user-auth-status-2">Java</button></ul><div class="tab-contents"><div class="tab-item-content active" id="code-check-user-auth-status-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> isUserSignedIn = auth.currentUser != <span class="literal">null</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="code-check-user-auth-status-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isUserSignedIn</span> <span class="operator">=</span> auth.getCurrentUser() != <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>

<h3 id="存取用戶資訊"><a href="#存取用戶資訊" class="headerlink" title="存取用戶資訊"></a>存取用戶資訊</h3><p>當你確認好用戶已完成登入，你可以使用 <code>currentUser</code> 來獲取當前已登入用戶的資訊。</p>
<div class="note warning simple"><p>因為當前用戶 (<code>currentUser</code>) 需要時間獲取的，所以它有可能一開始時是空的。</p>
</div>

<p>你可以從這個 <code>FirebaseUser</code> 實例中，獲取以下資訊：</p>
<ul>
<li><code>displayName</code>：用戶的顯示名稱</li>
<li><code>email</code>：用戶的電郵地址</li>
<li><code>photoUrl</code>：用戶的頭像圖片 URL 鏈結</li>
<li><code>isEmailVerified</code>：檢查用戶的電郵地址是否有效</li>
<li><code>uid</code>：用戶唯一的獨有 ID，但<strong>通常不建議在後端使用</strong>，官方建議使用 <code>FirebaseUser#getIdToken()</code></li>
</ul>
<div class="tabs" id="code-get-currentuser-info"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="code-get-currentuser-info-1">Kotlin</button><button type="button" class="tab " data-href="code-get-currentuser-info-2">Java</button></ul><div class="tab-contents"><div class="tab-item-content active" id="code-get-currentuser-info-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> user = auth.currentUser</span><br><span class="line">user?.let &#123;</span><br><span class="line">    <span class="keyword">val</span> name = it.displayName</span><br><span class="line">    <span class="keyword">val</span> email = it.email</span><br><span class="line">    <span class="keyword">val</span> photoUrl = it.photoUrl</span><br><span class="line">    <span class="keyword">val</span> emailVerified = it.isEmailVerified</span><br><span class="line">    <span class="keyword">val</span> uid = it.uid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="code-get-currentuser-info-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FirebaseUser</span> <span class="variable">user</span> <span class="operator">=</span> auth.getCurrentUser();</span><br><span class="line"><span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> user.getDisplayName();</span><br><span class="line">    <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> user.getEmail();</span><br><span class="line">    <span class="type">Uri</span> <span class="variable">photoUrl</span> <span class="operator">=</span> user.getPhotoUrl();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">emailVerified</span> <span class="operator">=</span> user.isEmailVerified();</span><br><span class="line">    <span class="type">String</span> <span class="variable">uid</span> <span class="operator">=</span> user.getUid();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>

<hr>
<h1 id="建立-Firebase-Authentication-介面及第三方登入處理"><a href="#建立-Firebase-Authentication-介面及第三方登入處理" class="headerlink" title="建立 Firebase Authentication 介面及第三方登入處理"></a>建立 Firebase Authentication 介面及第三方登入處理</h1><p>你看到<strong>大部分應用程式都不是使用單一的登入方式</strong>的，它們會允許用戶以電郵地址&#x2F;密碼及第三方登入，如支援登入方式如下：</p>
<ul>
<li>電郵地址&#x2F;密碼</li>
<li>Google</li>
<li>Facebook</li>
<li>更多..</li>
</ul>
<p><img src="/post/jetpack-compose-firebase-auth-notes/img6.png" alt="Firebase Authentication 支援的第三方平台"></p>
<p>通常，這些登入方式萬變不離其宗，都會有以下功能：</p>
<ul>
<li>註冊&#x2F;登入帳戶</li>
<li>登出帳戶</li>
<li>用戶是否已登入</li>
</ul>
<p>那麼，我們可以編寫一個 <code>Authenticator</code> 介面，包含這些描象功能，再在實質的類別中實現相關程式碼。</p>
<div class="note info simple"><p>因為 <code>signOut()</code>（登出帳戶）及 <code>isSignedIn()</code>（判斷用戶是否已登入）的功能實現方式一樣，所以它們會作為預設程式碼，至於 <code>signUp()</code>（註冊新帳戶） 及 <code>signIn()</code>（登入現有帳戶）的程式碼<strong>視乎不同的登入方式而決定</strong>。</p>
</div>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Authenticator</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> auth: FirebaseAuth</span><br><span class="line">        <span class="keyword">get</span>() = Firebase.auth</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">signUp</span><span class="params">()</span></span> = run &#123;  &#125;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">signIn</span><span class="params">()</span></span> = run &#123;  &#125;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">signOut</span><span class="params">()</span></span> = run &#123; auth.signOut() &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isSignedIn</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> = auth.currentUser != <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="電郵地址-x2F-密碼"><a href="#電郵地址-x2F-密碼" class="headerlink" title="電郵地址&#x2F;密碼"></a>電郵地址&#x2F;密碼</h2><p>處理電郵地址&#x2F;密碼的登入方式，我們會新建一個名為 <code>EmailAndPasswordAuthenticator</code> 類別，該類別會繼承 <code>Authenticator</code> 介面，但要求 <code>email</code> 及 <code>password</code> 作為參數。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EmailAndPasswordAuthenticator</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> email: String = <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> password: String = <span class="string">&quot;&quot;</span></span><br><span class="line">) : Authenticator &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">signUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        auth.createUserWithEmailAndPassword(email, password)</span><br><span class="line">            .await()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">signIn</span><span class="params">()</span></span> &#123;</span><br><span class="line">        auth.signInWithEmailAndPassword(email, password)</span><br><span class="line">            .await()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Google-登入"><a href="#Google-登入" class="headerlink" title="Google 登入"></a>Google 登入</h2><p><span class="step" data-step="1" data-title="啟用 Google 登入供應商"></span></p>
<p>你需要在 Firebase Authentication 啟用 Google 登入供應商，方可使用 Google 登入。</p>
<p><span class="step" data-step="2" data-title="獲取並設置網絡用戶端 ID"></span></p>
<p>然後，把網絡用戶端 ID 複製下來。把這個網絡用戶端 ID 貼上到 <code>strings.xml</code>，如命名為 <code>web_client_id</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;web_client_id&quot;</span>&gt;</span>XXX<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/post/jetpack-compose-firebase-auth-notes/img12.png" alt="把網絡用戶端 ID 複製下來"></p>
<p>我們同樣編寫一個 <code>GoogleAuthenticator</code> 類別，但 Google 登入提供了兩種登入方式，所以除了使用介面提供的 <code>signIn()</code> 抽象函數，還需要額外使用 <code>oneTapSignIn()</code> 函數。</p>
<p>在這個類別，我們會<strong>要求兩種供不同活動合約使用的啟動器，因為兩種登入方式使用的啟動器並不一樣</strong>，分別是 <code>legacyLauncher</code> 及 <code>oneTapLauncher</code>，顧名思義，前者是處理普通登入方式的啟動器，後者則處理One Tap方式的啟動器。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GoogleAuthenticator</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> context: Context,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> legacyLauncher: ManagedActivityResultLauncher&lt;Intent, ActivityResult&gt;? = <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> oneTapLauncher: ActivityResultLauncher&lt;IntentSenderRequest&gt;? = <span class="literal">null</span></span><br><span class="line">) : Authenticator &#123;</span><br><span class="line">    <span class="comment">// 實現的程式碼..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="舊版登入"><a href="#舊版登入" class="headerlink" title="舊版登入"></a>舊版登入</h3><div class="note warning simple"><p>雖然官方<strong>不再支援對舊版登入作出往後的更新及維護</strong>，但你仍然可以使用。</p>
</div>

<p>實現這個舊版的 Google 登入方式，我們會新建一個 <code>rememberGoogleSignInLauncher()</code> 可組合函式，該函式會是整個 <code>rememberLauncherForActivityResult()</code> 函式的封裝。</p>
<ul>
<li>啟動器型別：<code>ManagedActivityResultLauncher&lt;Intent, ActivityResult&gt;</code></li>
<li>活動合約：<code>ActivityResultContracts.StartActivityForResult()</code></li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">rememberGoogleSignInLauncher</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    onAuthComplete: ((<span class="type">AuthResult</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    onAuthError: ((<span class="type">ApiException</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: ManagedActivityResultLauncher&lt;Intent, ActivityResult&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> scope = rememberCoroutineScope()</span><br><span class="line">    <span class="keyword">return</span> rememberLauncherForActivityResult(</span><br><span class="line">        contract = ActivityResultContracts.StartActivityForResult(),</span><br><span class="line">        onResult = &#123; result -&gt;</span><br><span class="line">            <span class="keyword">val</span> task = GoogleSignIn.getSignedInAccountFromIntent(result.<span class="keyword">data</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> account = task.getResult(ApiException::<span class="keyword">class</span>.java)!!</span><br><span class="line">                <span class="keyword">val</span> credential = GoogleAuthProvider.getCredential(account.idToken!!, <span class="literal">null</span>)</span><br><span class="line">                scope.launch &#123;</span><br><span class="line">                    <span class="keyword">val</span> authResult = Firebase.auth.signInWithCredential(credential).await()</span><br><span class="line">                    onAuthComplete?.invoke(authResult)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: ApiException) &#123;</span><br><span class="line">                onAuthError?.invoke(e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至於 <code>signIn()</code> 函數的程式碼，會用 <code>GoogleSignInOptions</code> 進行登入，並呼喚 <code>legacyLauncher</code> 啟動器。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">signIn</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)</span><br><span class="line">        .requestIdToken(context.getString(R.string.web_client_id))</span><br><span class="line">        .requestEmail()</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">val</span> googleSignInClient = GoogleSignIn.getClient(context, gso)</span><br><span class="line"></span><br><span class="line">    legacyLauncher?.launch(googleSignInClient.signInIntent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是一個點擊登入按鈕後進行舊版登入的使用範例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> scope = rememberCoroutineScope()</span><br><span class="line"><span class="keyword">val</span> authenticator = GoogleAuthenticator(</span><br><span class="line">    legacyLauncher = rememberGoogleSignInLauncher()</span><br><span class="line">)</span><br><span class="line">Button(</span><br><span class="line">    onClick = &#123;</span><br><span class="line">        scope.launch &#123;</span><br><span class="line">            authenticator.signIn()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="One-Tap"><a href="#One-Tap" class="headerlink" title="One Tap"></a>One Tap</h3><p>而 One Tap 方式是依賴 Google 新推出的 <a href="https://developers.google.com/identity">Identity API</a>，基本上現在大部分網頁、應用程式都已經改用 One Tap。</p>
<ul>
<li>啟動器型別：<code>ActivityResultLauncher&lt;IntentSenderRequest&gt;</code></li>
<li>活動合約：<code>ActivityResultContracts.StartIntentSenderForResult()</code></li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><img src="/post/jetpack-compose-firebase-auth-notes/img14.png" alt="One Tap"></td>
<td><img src="/post/jetpack-compose-firebase-auth-notes/img15.jpeg" alt="One Tap（確認）"></td>
<td><img src="/post/jetpack-compose-firebase-auth-notes/img16.jpeg" alt="One Tap（登入中）"></td>
</tr>
</tbody></table>
<p>我們會同樣編寫一個 <code>rememberGoogleOneTapSignInLauncher()</code> 可組合函式。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">rememberGoogleOneTapSignInLauncher</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">/* TODO */</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: ActivityResultLauncher&lt;IntentSenderRequest&gt; &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這個 <code>oneTapSignIn()</code> <strong>不屬於 <code>Authenticator</code> 介面提供的抽象函數</strong>，但是它是 Google 的另類登入方式，所以會在 <code>GoogleAuthenticator</code> 額外定義。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">oneTapSignIn</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info simple"><p>因技術性錯誤，暫時無法提供完整程式碼。</p>
</div>

<h2 id="Facebook-登入"><a href="#Facebook-登入" class="headerlink" title="Facebook 登入"></a>Facebook 登入</h2><p>除了常見的 Google 登入，使用 Facebook 登入都是一個經常支援的平台，在 Android 開發，我們需要<strong>構建 Facebook 開發應用程式</strong>，配合 <strong>Facebook SDK 軟件開發工具包</strong>實現 Facebook 登入程序。</p>
<p><span class="step" data-step="1" data-title="建立 Facebook 開發應用程式"></span></p>
<p>首先，你需要前往 <a href="https://developers.facebook.com/">Facebook 開發人員中心</a>，建立一個新的 Facebook 開發應用程式，並選擇「使用 Facebook 登入，驗證用戶並向他們索取資料」選項。</p>
<p><img src="/post/jetpack-compose-firebase-auth-notes/img7.png" alt="建立新的開發應用程式"></p>
<p>你需要設置 Facebook 開發應用程式的名稱，例如沿用 Android 應用程式名稱 <code>ComposeFirebase</code>。</p>
<p><img src="/post/jetpack-compose-firebase-auth-notes/img8.png" alt="完成開發應用程式的設置"></p>
<p><span class="step" data-step="2" data-title="連接應用程式編號及密鑰"></span></p>
<p>現在，你需要在 Firebase Authentication 啟用 Facebook 登入供應商，並從剛創建的 Facebook 開發應用程式中，複製應用程式 ID 及應用程式密鑰，把它們貼上到 Firebase 的相應位置。</p>
<div class="note info simple"><p>應用程式密鑰需要先按「顯示」，再進行複製。</p>
</div>

<p><img src="/post/jetpack-compose-firebase-auth-notes/img10.png" alt="複製應用程式編號及應用程式密鑰"></p>
<p><span class="step" data-step="3" data-title="設置 OAuth 重新導向 URI"></span></p>
<p>你需要把 Firebase 提供的 OAuth 重新導向 URI 設置於 Facebook 的開發應用程式設定內。</p>
<p><img src="/post/jetpack-compose-firebase-auth-notes/img9.png" alt="Firebase 提供的 OAuth 重新導向 URI"></p>
<p>請於該開發應用程式的 Facebook 登入設定中，設置有效的 OAuth 重新導向 URI。</p>
<p><img src="/post/jetpack-compose-firebase-auth-notes/img11.png" alt="貼上 OAuth 重新導向 URI"></p>
<p><span class="step" data-step="4" data-title="匯入 Facebook SDK 軟體開發套件"></span></p>
<p>你需要匯入 Facebook SDK 軟體開發套件方可使用 Facebook 登入實現的 API 程式碼。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation(<span class="string">&quot;com.facebook.android:facebook-android-sdk:16.0.0&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><span class="step" data-step="5" data-title="宣告 Facebook 元數據"></span></p>
<p>接着，在 <code>AndroidManifest.xml</code> 的 <code>&lt;application&gt;</code> 區塊內宣告 Facebook 元數據設定。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;com.facebook.sdk.ApplicationId&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:value</span>=<span class="string">&quot;@string/facebook_app_id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;com.facebook.sdk.ClientToken&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:value</span>=<span class="string">&quot;@string/facebook_client_token&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<div class="note info simple"><p>你需要把 Facebook 開發<strong>應用程式的 ID</strong> 及<strong>用戶端憑證</strong>複製下來，並貼上到 <code>strings.xml</code> 作為字串資源。</p>
<p>請到開發應用程式的進階設定中，於安全性區域複製用戶端憑證。</p>
<p><img src="/post/jetpack-compose-firebase-auth-notes/img18.png" alt="複製用戶端憑證"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;facebook_app_id&quot;</span>&gt;</span>XXX<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;client_token&quot;</span>&gt;</span>XXX<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><span class="step" data-step="6" data-title="設置金鑰雜湊"></span></p>
<p>你需要獲取應用程式的金鑰雜湊，在偵錯模式 (debug mode) 中，我們可以透過以下程式碼獲取金鑰雜湊。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    PackageInfo info = getPackageManager().getPackageInfo(getPackageName() , PackageManager.GET_SIGNATURES);</span><br><span class="line">    <span class="keyword">for</span>(Signature signature:info.signatures)&#123;</span><br><span class="line">        MessageDigest md = MessageDigest.getInstance(<span class="string">&quot;SHA&quot;</span>);</span><br><span class="line">        md.update(signature.toByteArray());</span><br><span class="line">        Log.i(<span class="string">&quot;Signature&quot;</span>, Base64.encodeToString(md.digest(), Base64.DEFAULT));<span class="comment">// &lt;--- signature</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然後在開發應用程式的基本設定中，選擇 Android，加入一個應用程式商店，例如使用 Google Play 商店，並把金鑰雜湊設置。</p>
<p><img src="/post/jetpack-compose-firebase-auth-notes/img20.png" alt="設置金鑰雜湊"></p>
<p><span class="step" data-step="7" data-title="啟用電郵地址的權限"></span></p>
<p>在使用案例中，新增 <code>email</code> 權限。</p>
<p><img src="/post/jetpack-compose-firebase-auth-notes/img19.png" alt="新增 email 權限"></p>
<h3 id="使用-Facebook-的-LoginButton-組件"><a href="#使用-Facebook-的-LoginButton-組件" class="headerlink" title="使用 Facebook 的 LoginButton 組件"></a>使用 Facebook 的 <code>LoginButton</code> 組件</h3><p>顧名思義，這個是 Facebook 軟體開發套件提供的 Facebook 登入按鈕組件，它不僅只是一個按鈕，更是<strong>擁有 Facebook 登入回調的程序處理</strong>。目前，<code>LoginButton</code> 只支援 XML 佈局使用，我們需要配合 <code>AndroidView</code> 來應用於 Jetpack Compose。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">AndroidView(</span><br><span class="line">    factory = &#123; context -&gt;</span><br><span class="line">        LoginButton(context).apply &#123;</span><br><span class="line">            <span class="comment">// 實現的程式碼..</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<div class="note danger simple"><p>如果沒有完成 Facebook SDK 所有配置，<code>LoginButton</code> 不會顯示任何文字！<br>如果完成了，若用戶尚未登入，則顯示「繼續使用 Facebook 登入」，若已登入，則顯示「登出」。</p>
</div>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">AndroidView(</span><br><span class="line">    factory = &#123; context -&gt;</span><br><span class="line">        LoginButton(context).apply &#123;</span><br><span class="line">            <span class="keyword">val</span> callbackManager = CallbackManager.Factory.create()</span><br><span class="line">            setPermissions(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;public_profile&quot;</span>)</span><br><span class="line">            registerCallback(callbackManager, <span class="keyword">object</span> : FacebookCallback&lt;LoginResult&gt; &#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCancel</span><span class="params">()</span></span> &#123;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(error: <span class="type">FacebookException</span>)</span></span> &#123;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(result: <span class="type">LoginResult</span>)</span></span> &#123;</span><br><span class="line">                    scope.launch &#123;</span><br><span class="line">                        <span class="keyword">val</span> token = result.accessToken.token</span><br><span class="line">                        <span class="keyword">val</span> credential = FacebookAuthProvider.getCredential(token)</span><br><span class="line">                        <span class="keyword">val</span> authResult = Firebase.auth.signInWithCredential(credential).await()</span><br><span class="line">                        <span class="keyword">if</span> (authResult.user != <span class="literal">null</span>) &#123;</span><br><span class="line">                            </span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Could not sign in with Firebase&quot;</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>LoginButton</code> 會為你實現登入及登出功能。</p>
<h3 id="使用-Authenticator-介面"><a href="#使用-Authenticator-介面" class="headerlink" title="使用 Authenticator 介面"></a>使用 <code>Authenticator</code> 介面</h3><p>但是以上程式碼並非使用我們所使用的 <code>Authenticator</code> 介面，實際上如果不使用 <code>LoginButton</code> 來實現 Facebook 登入是絕對可行的。<strong>Facebook 登入程式背後都是使用啟動器的</strong>。 </p>
<ul>
<li>啟動器型別：<code>ManagedActivityResultLauncher&lt;Collection&lt;String&gt;, CallbackManager.ActivityResultParameters&gt;</code></li>
<li>活動合約：無特定類別，需要以函數獲取。</li>
</ul>
<p>一如既往，編寫 <code>FacebookAuthenticator</code> 類別，接受一個 <code>launcher</code> 參數。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FacebookAuthenticator</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> launcher: ManagedActivityResultLauncher&lt;Collection&lt;String&gt;, CallbackManager.ActivityResultParameters&gt;? = <span class="literal">null</span></span><br><span class="line">) : Authenticator &#123;</span><br><span class="line">    <span class="comment">// 實現的程式碼..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是 <code>rememberFacebookSignInLauncher()</code> 可組合函式實現程式碼。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">rememberFacebookSignInLauncher</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    onAuthComplete: ((<span class="type">AuthResult</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    onAuthError: ((<span class="type">Exception</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: ManagedActivityResultLauncher&lt;Collection&lt;String&gt;, CallbackManager.ActivityResultParameters&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> loginManager = LoginManager.getInstance()</span><br><span class="line">    <span class="keyword">val</span> callbackManager = remember &#123;</span><br><span class="line">        CallbackManager.Factory.create()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 獲取的活動合約</span></span><br><span class="line">    <span class="keyword">val</span> contract = loginManager.createLogInActivityResultContract(callbackManager, <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">val</span> scope = rememberCoroutineScope()</span><br><span class="line"></span><br><span class="line">    DisposableEffect(<span class="built_in">Unit</span>) &#123;</span><br><span class="line">        loginManager.registerCallback(callbackManager, <span class="keyword">object</span> : FacebookCallback&lt;LoginResult&gt; &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCancel</span><span class="params">()</span></span> &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(error: <span class="type">FacebookException</span>)</span></span> &#123;</span><br><span class="line">                onAuthError?.invoke(error)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(result: <span class="type">LoginResult</span>)</span></span> &#123;</span><br><span class="line">                scope.launch &#123;</span><br><span class="line">                    <span class="keyword">val</span> token = result.accessToken.token</span><br><span class="line">                    <span class="keyword">val</span> credential = FacebookAuthProvider.getCredential(token)</span><br><span class="line">                    <span class="keyword">val</span> authResult = Firebase.auth.signInWithCredential(credential).await()</span><br><span class="line">                    <span class="keyword">if</span> (authResult.user != <span class="literal">null</span>) &#123;</span><br><span class="line">                        onAuthComplete?.invoke(authResult)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        onAuthError?.invoke(IllegalStateException(<span class="string">&quot;Unable to sign in with Facebook&quot;</span>))</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        onDispose &#123;</span><br><span class="line">            loginManager.unregisterCallback(callbackManager)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rememberLauncherForActivityResult(</span><br><span class="line">        contract = contract,</span><br><span class="line">        onResult = &#123;</span><br><span class="line">            <span class="comment">// 不需要執行任何程式碼，因為會在 FacebookCallback 執行</span></span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至於執行登入程序很簡單，直接呼喚這個 <code>launcher</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">signIn</span><span class="params">()</span></span> &#123;</span><br><span class="line">    launcher?.launch(listOf(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;public_profile&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Github-登入"><a href="#Github-登入" class="headerlink" title="Github 登入"></a>Github 登入</h2><p>通常，一些屬於技術性或編程的應用程式，都會支援 Github 登入，因為支援 Github 登入，意味着用戶可以與其他 Github 開放源碼有所聯繫。例如編寫一個整合開發環境 IDE 應用程式，你需要允許用戶以 Github 帳戶登入，方能執行相關檔案及存儲庫處理。</p>
<p><span class="step" data-step="1" data-title="建立 Github 開發應用程式"></span></p>
<p>啟用 Github 登入供應商，並前往<a href="https://github.com/settings/applications/new">開發人員設定</a>建立一個 Github 開發應用程式。裏面的 Homepage URL 和 Authorization callback URL 都是輸入 Firebase 提供的授權回呼網址。</p>
<p><img src="/post/jetpack-compose-firebase-auth-notes/img21.png" alt="建立應用程式"></p>
<p><span class="step" data-step="2" data-title="設置 Client ID 及 Client secrets"></span></p>
<p>建立完成後，把 Client ID 及 Client secrets 複製下來。</p>
<p><img src="/post/jetpack-compose-firebase-auth-notes/img22.png" alt="複製 Client ID 及 Client secrets"></p>
<p>再把它們設置到 Firebase 的相應位置。</p>
<p><img src="/post/jetpack-compose-firebase-auth-notes/img23.png" alt="設置 Client ID 及 Client secrets"></p>
<div class="note info simple"><p>因技術性錯誤，暫時無法提供完整程式碼。</p>
</div>]]></content>
      <categories>
        <category>Jetpack Compose</category>
        <category>Firebase</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>【Jetpack Compose】Firebase Cloud Firestore 雲端存儲庫 | 企業級資料庫</title>
    <url>/post/jetpack-compose-firebase-cloud-firestore-notes.html</url>
    <content><![CDATA[<p>Firebase Cloud Firestore 是一個較 Realtime Database 更為靈活的資料庫，它不再以樹狀結構形式顯示資料，而是以分欄的形式顯示，從而可以掌握資料的關聯性。</p>
<p>未創建 Firebase 專案及未瞭解 Realtime Database 的請先看這些文章：</p>
<div calss="anzhiyu-tag-link"><a class="tag-Link" target="_blank" href="/post/android-firebase-setup-notes">
    <div class="tag-link-tips">引用站外地址</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style>
          <i class="anzhiyufont anzhiyu-icon-link" style></i>
        </div>
        <div class="tag-link-right">
            <div class="tag-link-title">Firebase 專案配置</div>
            <div class="tag-link-sitename"> 看這篇文章瞭解如何配置 Firebase 專案</div>
        </div>
        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>
    </div>
    </a></div>
<div calss="anzhiyu-tag-link"><a class="tag-Link" target="_blank" href="/post/jetpack-compose-firebase-realtime-database-notes">
    <div class="tag-link-tips">引用站外地址</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style>
          <i class="anzhiyufont anzhiyu-icon-link" style></i>
        </div>
        <div class="tag-link-right">
            <div class="tag-link-title">Firebase Realtime Database 即時資料庫</div>
            <div class="tag-link-sitename"> 看這篇文章瞭解如何使用 Realtime Database</div>
        </div>
        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>
    </div>
    </a></div>

<hr>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Realtime Database</th>
<th align="center">Cloud Firestore Database</th>
</tr>
</thead>
<tbody><tr>
<td align="center">使用目的</td>
<td align="center">基本查詢同步資料</td>
<td align="center">高級查詢、排序和事務</td>
</tr>
<tr>
<td align="center">資料結構</td>
<td align="center">簡單的 JSON 樹</td>
<td align="center">文檔整理為集合</td>
</tr>
<tr>
<td align="center">資料庫用量</td>
<td align="center">經常發生更改的幾 GB 或更少的資料</td>
<td align="center">大小為數百 GB 到 TB，且讀取頻率比更改頻率高得多的資料</td>
</tr>
<tr>
<td align="center">可用性需求</td>
<td align="center">保證正常運行時間至少達到 99.95%</td>
<td align="center">99.999% 的極高正常運行時間保證</td>
</tr>
<tr>
<td align="center">資料庫實例數</td>
<td align="center">一個或許多</td>
<td align="center">一個</td>
</tr>
<tr>
<td align="center">在無法連接的設備上執行查詢的頻率</td>
<td align="center">極少或從不</td>
<td align="center">頻繁、極少或從不</td>
</tr>
</tbody></table>
<p>遷移至 Cloud Firestore 後，你可以使用以下功能，並留意以下細項：</p>
<ul>
<li>增加了集合 (Collection) 概念。資料庫的根 (Root) 為多個集合，每個集合可裝載多個文件 (Document)，每個文件實體中也可包含集合。</li>
<li>支援了更多資料型別，比如：<code>object</code>、<code>array</code>、<code>geopoint</code>、<code>reference</code>。其中 <code>reference</code> 可指定到特定節點的文件實體。</li>
<li>可自定義索引 (index)，支援 multi-key index。可以簡易做到混合 (compound) 的排序 (sorting) 和條件過濾 (filtering)。</li>
</ul>
<hr>
<h1 id="建立資料庫"><a href="#建立資料庫" class="headerlink" title="建立資料庫"></a>建立資料庫</h1><p>首先，你需要在 Firebase 主控台啟用 Firestore Database 建構，並建立資料庫。</p>
<p><span class="step" data-step="1" data-title="匯入 Firebase Cloud Firestore 函式庫"></span></p>
<p>你需要匯入 Firebae Firestore Database 建構功能 <code>firebase-firestore</code> 的函式庫。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation(<span class="string">&quot;com.google.firebase:firebase-firestore&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><span class="step" data-step="2" data-title="選擇雲端存儲庫位置"></span></p>
<p>根據你所位於的地區，選擇較為合適的地區作為資料庫存放的位置。Cloud Firestore 支援的地區更廣泛。</p>
<p><span class="step" data-step="3" data-title="設定安全性規則"></span></p>
<p>我們需要設定安全性規則，安全性規則是一個用來保護資料庫的機制，限制存取權限。它預設有正式模式及測試模式啟動。</p>
<p>先暫時選擇任一模式，然後更新安全性規則。</p>
<div class="note danger simple"><p>當你正式使用資料庫時，你需要編寫更嚴格的安全性規則，把讀取 (<code>read</code>) 及寫入 (<code>write</code>) 權限長期設置為 <code>true</code> 相當危險，<strong>以下安全性規則僅作測試用途！</strong></p>
</div>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rules_version = &#x27;2&#x27;;</span><br><span class="line"></span><br><span class="line">service cloud.firestore &#123;</span><br><span class="line">  match /databases/&#123;database&#125;/documents &#123;</span><br><span class="line">    match /&#123;document=**&#125; &#123;</span><br><span class="line">      allow read, write: if true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Jetpack Compose</category>
        <category>Firebase</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>【Jetpack Compose】Firebase Realtime Database 即時資料庫 | 初階級資料庫</title>
    <url>/post/jetpack-compose-firebase-realtime-database-notes.html</url>
    <content><![CDATA[<p>Firebase Realtime Database 是一個儲存資料的資料庫，雖然它已經被鮮少開發者使用，大部分的開發者都紛紛遷移到使用 Cloud Firestore 雲端存儲庫，但是這個 Firebase Realtime Database 至今仍然還有存在價值的。</p>
<p>未創建 Firebase 專案的請先看這篇文章：</p>
<div calss="anzhiyu-tag-link"><a class="tag-Link" target="_blank" href="/post/android-firebase-setup-notes">
    <div class="tag-link-tips">引用站外地址</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style>
          <i class="anzhiyufont anzhiyu-icon-link" style></i>
        </div>
        <div class="tag-link-right">
            <div class="tag-link-title">Firebase 專案配置</div>
            <div class="tag-link-sitename"> 看這篇文章瞭解如何配置 Firebase 專案</div>
        </div>
        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>
    </div>
    </a></div>

<hr>
<h1 id="建立資料庫"><a href="#建立資料庫" class="headerlink" title="建立資料庫"></a>建立資料庫</h1><p>首先，你需要在 Firebase 主控台啟用 Realtime Database 建構，並建立資料庫。</p>
<p><span class="step" data-step="1" data-title="匯入 Firebase Realtime Database 函式庫"></span></p>
<p>你需要匯入 Firebae Realtime Database 建構功能 <code>firebase-database</code> 的函式庫。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation(<span class="string">&quot;com.google.firebase:firebase-database&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><span class="step" data-step="2" data-title="選擇即時資料庫位置"></span></p>
<p>根據你所位於的地區，選擇較為合適的地區作為資料庫存放的位置，這裏推薦選擇美國 (us-central1)。</p>
<p><span class="step" data-step="3" data-title="設定安全性規則"></span></p>
<p>我們需要設定安全性規則，安全性規則是一個用來保護資料庫的機制，限制存取權限。它預設有鎖定模式及測試模式啟動。</p>
<ul>
<li>鎖定模式：資料是私人資料，不公開。</li>
<li>測試模式：資料是公開，但必須在 30 天內更新安全性規則，方可長期啟用用戶端讀取及寫入權限。</li>
</ul>
<p>先暫時選擇任一模式，然後更新安全性規則。</p>
<div class="note danger simple"><p>當你正式使用資料庫時，你需要編寫更嚴格的安全性規則，把讀取 (<code>read</code>) 及寫入 (<code>write</code>) 權限長期設置為 <code>true</code> 相當危險，<strong>以下安全性規則僅作測試用途！</strong></p>
</div>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;.write&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;.read&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="新增並儲存資料"><a href="#新增並儲存資料" class="headerlink" title="新增並儲存資料"></a>新增並儲存資料</h1><p>現在，我們會編寫程式碼，將用戶所提供的資料儲存到資料庫中。預設情況下，資料庫是空的。</p>
<p><img src="/post/jetpack-compose-firebase-realtime-database-notes/img1.png" alt="預設的資料庫是空的"></p>
<p><span class="step" data-step="1" data-title="建立數據類"></span></p>
<p>我們會建立一個數據類，把用戶可提供的資料以一個數據類包裝起來。例如，用戶可以為筆記提供以下內容：</p>
<ul>
<li>作者：<strong>這個不需要用戶手動輸入</strong>，當用戶已完成登入，系統便會自動獲取該帳戶的顯示名稱</li>
<li>標題：用戶為特定筆記指定的標題</li>
<li>內文：用戶為特定筆記指定的內容</li>
</ul>
<div class="tabs" id="code-note"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="code-note-1">數據類</button><button type="button" class="tab " data-href="code-note-2">狀態容器</button></ul><div class="tab-contents"><div class="tab-item-content active" id="code-note-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Note</span>(</span><br><span class="line">    <span class="keyword">val</span> author: String?,</span><br><span class="line">    <span class="keyword">val</span> title: String?,</span><br><span class="line">    <span class="keyword">val</span> content: String?</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="code-note-2"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">NoteState</span>(</span><br><span class="line">    <span class="keyword">val</span> title: MutableState&lt;String&gt;? = mutableStateOf(<span class="string">&quot;&quot;</span>),</span><br><span class="line">    <span class="keyword">val</span> content: MutableState&lt;String&gt;? = mutableStateOf(<span class="string">&quot;&quot;</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>

<p><span class="step" data-step="2" data-title="宣告 NoteState 狀態"></span></p>
<p>我們會使用這個 <code>NoteState</code> 狀態容器獲取 <code>title</code> 及 <code>content</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> state = remember &#123; NoteState() &#125;</span><br></pre></td></tr></table></figure>

<p><span class="step" data-step="3" data-title="為每一筆資料賦予獨一無二的 ID"></span></p>
<p>在儲存數據的時候要注意，我們需要<strong>附加一個用於辨識筆記的獨一無二的 ID</strong>，我們可以使用 <code>UUID.randomUUID()</code> 程式碼獲取隨機的 UUID 作為獨一無二的 ID。<strong>如果不附上獨一無二的 ID，筆記的資料無法被正確辨識，其資料或會被取代！</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> FirebaseDatabase.<span class="title">saveData</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    path: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    value: <span class="type">Any</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = Firebase.auth.currentUser</span><br><span class="line">    user?.run &#123;</span><br><span class="line">        <span class="keyword">val</span> ref = Firebase.database.reference</span><br><span class="line">        <span class="keyword">val</span> userIdRef = ref</span><br><span class="line">            .child(path)</span><br><span class="line">            .child(UUID.randomUUID().toString()) <span class="comment">// 隨機生成的 UUID 作為每一項資料獨一無二的 ID</span></span><br><span class="line">        userIdRef.setValue(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如，點擊按鈕後把用戶所輸入的資料儲存到資料庫。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Firebase.database.saveData(</span><br><span class="line">    path = <span class="string">&quot;notes&quot;</span>,</span><br><span class="line">    value = Note(</span><br><span class="line">        author = Firebase.auth.currentUser?.displayName.toString(),</span><br><span class="line">        title = state.title?.value,</span><br><span class="line">        content = state.content?.value</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>你會看到這兩筆資料成功儲存至資料庫裏。</p>
<p><img src="/post/jetpack-compose-firebase-realtime-database-notes/img2.png" alt="儲存了兩筆資料到資料庫"></p>
<hr>
<h1 id="讀取資料"><a href="#讀取資料" class="headerlink" title="讀取資料"></a>讀取資料</h1><p>剛說過，要辨識筆記需要在新增筆記時提供一個獨一無二的 ID，現在，我們便<strong>可以利用這個獨一無二的 ID 跟蹤並讀取筆記的資料</strong>。</p>
<p>例如，我們會從資料庫讀取 ID 為 <code>71ecf645-cae3-4901-bd99-4ec2a94f3bc9</code> 的筆記資料。</p>
<h2 id="一次性讀取"><a href="#一次性讀取" class="headerlink" title="一次性讀取"></a>一次性讀取</h2><p>一次性讀取 (One-time Read) 是從資料庫中<strong>讀取一次資料</strong>，讀取後資料<strong>不會被自動更新</strong>，其後不會再被讀取。我們可以使用 <code>addOnSuccessListener</code> 回調獲取一次讀取的資料。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> FirebaseDatabase.<span class="title">readDataOneTime</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    type: <span class="type">GenericTypeIndicator</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    path: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    id: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    onSuccess: ((<span class="type">T</span>?) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    onFailure: ((<span class="type">Exception</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = Firebase.auth.currentUser</span><br><span class="line">    user?.run &#123;</span><br><span class="line">        <span class="keyword">val</span> ref = Firebase.database.reference</span><br><span class="line">        <span class="keyword">val</span> userIdRef = ref</span><br><span class="line">            .child(path)</span><br><span class="line">            .child(id)</span><br><span class="line">        userIdRef.<span class="keyword">get</span>().apply &#123;</span><br><span class="line">            addOnSuccessListener &#123; snapshot -&gt;</span><br><span class="line">                <span class="keyword">val</span> <span class="keyword">data</span> = snapshot.getValue(type)</span><br><span class="line">                onSuccess?.invoke(<span class="keyword">data</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            addOnFailureListener &#123; e -&gt;</span><br><span class="line">                onFailure?.invoke(e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如，點擊按鈕後，讀取該 ID 的筆記內容資料。</p>
<div class="note info simple"><p>因為 <code>Note</code> 是一個數據類 <code>data class</code>，在 Kotlin 及 Java 的 Getter Setter，我們需要使用 <code>GenericTypeIndicator</code> 宣告泛型數據源。</p>
</div>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Firebase.database.readDataOneTime(</span><br><span class="line">    type = <span class="keyword">object</span> : GenericTypeIndicator&lt;Note&gt;() &#123;&#125;,    <span class="comment">// 宣告泛型數據源</span></span><br><span class="line">    path = <span class="string">&quot;notes&quot;</span>,</span><br><span class="line">    id = <span class="string">&quot;71ecf645-cae3-4901-bd99-4ec2a94f3bc9&quot;</span>,</span><br><span class="line">    onSuccess = &#123; <span class="keyword">data</span> -&gt;</span><br><span class="line">        output = <span class="keyword">data</span>?.content.toString()</span><br><span class="line">    &#125;,</span><br><span class="line">    onFailure = &#123; error -&gt;</span><br><span class="line">        output = <span class="string">&quot;error: <span class="variable">$error</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="持續性讀取"><a href="#持續性讀取" class="headerlink" title="持續性讀取"></a>持續性讀取</h2><p>持續性讀取 (Continuous Read) 是在資料庫<strong>設置監聽器</strong>，當資料有更新及有變化時，就會觸發監聽器，從而<strong>追蹤到資料的更新</strong>。</p>
<div class="note info simple"><p>資料庫有更新，<strong>介面會實時更新獲取後的資料！</strong>適合用於即時更新，如伺服器驅動介面 (Server Driven UI)。</p>
</div>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> FirebaseDatabase.<span class="title">readDataContinuous</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    type: <span class="type">GenericTypeIndicator</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    path: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    id: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    onSuccess: ((<span class="type">T</span>?) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    onFailure: ((<span class="type">DatabaseError</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = Firebase.auth.currentUser</span><br><span class="line">    user?.run &#123;</span><br><span class="line">        <span class="keyword">val</span> ref = Firebase.database.reference</span><br><span class="line">        <span class="keyword">val</span> userIdRef = ref</span><br><span class="line">            .child(path)</span><br><span class="line">            .child(id)</span><br><span class="line">        userIdRef.addValueEventListener(<span class="keyword">object</span> : ValueEventListener &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDataChange</span><span class="params">(snapshot: <span class="type">DataSnapshot</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">val</span> <span class="keyword">data</span> = snapshot.getValue(type)</span><br><span class="line">                onSuccess?.invoke(<span class="keyword">data</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCancelled</span><span class="params">(error: <span class="type">DatabaseError</span>)</span></span> &#123;</span><br><span class="line">                onFailure?.invoke(error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="遍歷資料"><a href="#遍歷資料" class="headerlink" title="遍歷資料"></a>遍歷資料</h1><p>通常，顯示及遍歷資料，許多時候，資料與介面是實時更新的，所以這裏以持續性讀取作範例。</p>
<h2 id="遍歷單一資料"><a href="#遍歷單一資料" class="headerlink" title="遍歷單一資料"></a>遍歷單一資料</h2><p>一如既往，我們會使用 ID 來追蹤資料的變化，並列出該 ID 的資料所有內容。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> FirebaseDatabase.<span class="title">listData</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    type: <span class="type">GenericTypeIndicator</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    path: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    id: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    onSuccess: ((<span class="type">T</span>?) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    onFailure: ((<span class="type">DatabaseError</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> : SnapshotStateList&lt;T?&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> list = mutableStateListOf&lt;T?&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> user = Firebase.auth.currentUser</span><br><span class="line">    user?.run &#123;</span><br><span class="line">        <span class="keyword">val</span> ref = Firebase.database.reference</span><br><span class="line">        <span class="keyword">val</span> userIdRef = ref</span><br><span class="line">            .child(path)</span><br><span class="line">            .child(id)</span><br><span class="line">        userIdRef.addValueEventListener(<span class="keyword">object</span> : ValueEventListener &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDataChange</span><span class="params">(snapshot: <span class="type">DataSnapshot</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">val</span> <span class="keyword">data</span> = snapshot.getValue(type)</span><br><span class="line">                list.add(<span class="keyword">data</span>)</span><br><span class="line">                onSuccess?.invoke(<span class="keyword">data</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCancelled</span><span class="params">(error: <span class="type">DatabaseError</span>)</span></span> &#123;</span><br><span class="line">                onFailure?.invoke(error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在這個範例中，我們會使用 <code>LazyColumn</code> 列出所有資料。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list = Firebase.database.listAllData(</span><br><span class="line">    type = <span class="keyword">object</span> : GenericTypeIndicator&lt;Note&gt;() &#123;&#125;,</span><br><span class="line">    path = <span class="string">&quot;notes&quot;</span></span><br><span class="line">)</span><br><span class="line">LazyColumn &#123;</span><br><span class="line">    itemsIndexed(list) &#123; i, <span class="keyword">data</span> -&gt;</span><br><span class="line">        NoteItem(</span><br><span class="line">            author = <span class="keyword">data</span>?.author.toString(),</span><br><span class="line">            title = <span class="keyword">data</span>?.title.toString(),</span><br><span class="line">            content = <span class="keyword">data</span>?.content.toString()</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遍歷所有資料"><a href="#遍歷所有資料" class="headerlink" title="遍歷所有資料"></a>遍歷所有資料</h2><p>至於遍歷所有資料，我們不需要用到 ID，因為我們全部資料都要讀取。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> FirebaseDatabase.<span class="title">listAllData</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    type: <span class="type">GenericTypeIndicator</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    path: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    onSuccess: ((<span class="type">T</span>?) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    onFailure: ((<span class="type">DatabaseError</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> : SnapshotStateList&lt;T?&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> list = mutableStateListOf&lt;T?&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> user = Firebase.auth.currentUser</span><br><span class="line">    user?.run &#123;</span><br><span class="line">        <span class="keyword">val</span> ref = Firebase.database.reference</span><br><span class="line">        <span class="keyword">val</span> dataRef = ref.child(path)</span><br><span class="line">        dataRef.addValueEventListener(<span class="keyword">object</span> : ValueEventListener &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDataChange</span><span class="params">(snapshot: <span class="type">DataSnapshot</span>)</span></span> &#123;</span><br><span class="line">                list.clear()</span><br><span class="line">                <span class="keyword">for</span> (childSnapshot <span class="keyword">in</span> snapshot.children) &#123;</span><br><span class="line">                    <span class="keyword">val</span> <span class="keyword">data</span> = childSnapshot.getValue(type)</span><br><span class="line">                    list.add(<span class="keyword">data</span>)</span><br><span class="line">                    onSuccess?.invoke(<span class="keyword">data</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCancelled</span><span class="params">(error: <span class="type">DatabaseError</span>)</span></span> &#123;</span><br><span class="line">                onFailure?.invoke(error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但這樣做，有一個問題，就是我們<strong>無法獲取並顯示筆記的 ID</strong>，這個時候，需要改寫一下程式碼，你可以有以下對策：</p>
<ol>
<li>直接把 <code>id</code> 作為 <code>Note</code> 數據類的其中一項資料</li>
<li>使用 <code>Pair</code> 把 ID 及資料組分開獲取。<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> FirebaseDatabase.<span class="title">listAllData</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    type: <span class="type">GenericTypeIndicator</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    path: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    onSuccess: ((<span class="type">T</span>?) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    onFailure: ((<span class="type">DatabaseError</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> : SnapshotStateList&lt;Pair&lt;String?, T?&gt;?&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> list = mutableStateListOf&lt;Pair&lt;String?, T?&gt;?&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> user = Firebase.auth.currentUser</span><br><span class="line">    user?.run &#123;</span><br><span class="line">        <span class="keyword">val</span> ref = Firebase.database.reference</span><br><span class="line">        <span class="keyword">val</span> dataRef = ref.child(path)</span><br><span class="line">        dataRef.addValueEventListener(<span class="keyword">object</span> : ValueEventListener &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDataChange</span><span class="params">(snapshot: <span class="type">DataSnapshot</span>)</span></span> &#123;</span><br><span class="line">                list.clear()</span><br><span class="line">                <span class="keyword">for</span> (childSnapshot <span class="keyword">in</span> snapshot.children) &#123;</span><br><span class="line">                    <span class="keyword">val</span> id = childSnapshot.key <span class="comment">// 獲取子節點的 ID</span></span><br><span class="line">                    <span class="keyword">val</span> <span class="keyword">data</span> = childSnapshot.getValue(type)</span><br><span class="line">                    list.add(Pair(id, <span class="keyword">data</span>)) <span class="comment">// 將 ID 和資料組成一個 Pair 並加入列表</span></span><br><span class="line">                    onSuccess?.invoke(<span class="keyword">data</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCancelled</span><span class="params">(error: <span class="type">DatabaseError</span>)</span></span> &#123;</span><br><span class="line">                onFailure?.invoke(error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
然後，回到 <code>LazyColumn</code> 部分，這個傳出的 <code>data</code> 參數已經屬於 <code>Pair</code> 型別，這裏要注意：</li>
</ol>
<ul>
<li><code>Pair</code> 第一項是獲取 ID</li>
<li><code>Pair</code> 第二項是獲取資料組<br>所以，程式碼應該要改成：<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">LazyColumn &#123;</span><br><span class="line">    itemsIndexed(list) &#123; i, <span class="keyword">data</span> -&gt;</span><br><span class="line">        <span class="keyword">val</span> id = <span class="keyword">data</span>?.first.toString()</span><br><span class="line">        <span class="keyword">val</span> noteData = <span class="keyword">data</span>?.second</span><br><span class="line">        NoteItem(</span><br><span class="line">            id = id,</span><br><span class="line">            author = noteData?.author.toString(),</span><br><span class="line">            title = noteData?.title.toString(),</span><br><span class="line">            content = noteData?.content.toString()</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Jetpack Compose</category>
        <category>Firebase</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>【Jetpack Compose】Android 13 相片挑選工具 API | 舊型裝置向後相容處理</title>
    <url>/post/jetpack-compose-photo-picker-for-android-13.html</url>
    <content><![CDATA[<p>Android 13 的推出以來，有一個 API 功能是對我們作為應用程式開發者來說尤其重要，就是讓用戶能夠從我們的應用程式中選擇要使用的圖像或影像。</p>
<p>等等。。！你可能會問，不是可以使用相冊 (Gallery) 來選擇圖像嗎？沒錯，但這需要向用戶存取檔案權限，而這一個 Android 13 新推出的 Photo Picker API 是<strong>不需要向用戶存取檔案權限的，所以能夠確保並保障資料安全性</strong>。</p>
<table>
<thead>
<tr>
<th>官方演示</th>
<th>單選媒體</th>
<th>多選媒體</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/post/jetpack-compose-photo-picker-for-android-13/img2.gif" alt="相片挑選工具提供直覺易用的使用者介面，方便您與應用程式分享相片"></td>
<td><img src="/post/jetpack-compose-photo-picker-for-android-13/img3.jpeg" alt="單選媒體"></td>
<td><img src="/post/jetpack-compose-photo-picker-for-android-13/img4.jpeg" alt="多選媒體"></td>
</tr>
</tbody></table>
<div calss="anzhiyu-tag-link"><a class="tag-Link" target="_blank" href="https://developer.android.com/training/data-storage/shared/photopicker?hl=zh-tw">
    <div class="tag-link-tips">引用站外地址</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style>
          <i class="anzhiyufont anzhiyu-icon-link" style></i>
        </div>
        <div class="tag-link-right">
            <div class="tag-link-title">Photo Picker API 相片挑選工具</div>
            <div class="tag-link-sitename"> 這裏有關相片挑選工具的官方文案</div>
        </div>
        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>
    </div>
    </a></div>

<p>Android 13 的相片挑選工具特點如下：</p>
<ul>
<li><strong>不需要詢問及允許任何運行時權限</strong></li>
<li>提供更好的 UI 及 UX 介面供用戶選擇媒體</li>
<li>支援從雲端存取的媒體 (<code>CloudMediaProvider</code> API)</li>
<li>支援向後相容，<strong>低版本裝置仍可透過向後移植版本使用</strong></li>
</ul>
<hr>
<h1 id="適當選擇使用相冊或相片挑選工具"><a href="#適當選擇使用相冊或相片挑選工具" class="headerlink" title="適當選擇使用相冊或相片挑選工具"></a>適當選擇使用相冊或相片挑選工具</h1><p>雖然在 Android 13 推出了一個很好用的相片挑選工具，輕鬆選擇圖像，但是<strong>它並不是萬能的</strong>。這裏簡單指出了應在什麼情況，適當選擇使用相冊及照相機 (Gallery &amp; Camera) 和相片挑選工具 (Photo Picker API)。</p>
<table>
<thead>
<tr>
<th align="center">情況</th>
<th align="center">相冊及照相機</th>
<th align="center">相片挑選工具</th>
</tr>
</thead>
<tbody><tr>
<td align="center">從相冊中選擇照片</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
</tr>
<tr>
<td align="center">選擇多張照片</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
</tr>
<tr>
<td align="center">拍攝新照片</td>
<td align="center">✔️</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">詢問及存取檔案權限</td>
<td align="center">✔️</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">設定照片選擇器的選項和行為</td>
<td align="center">❌</td>
<td align="center">✔️</td>
</tr>
</tbody></table>
<hr>
<h1 id="使用相片挑選工具-API"><a href="#使用相片挑選工具-API" class="headerlink" title="使用相片挑選工具 API"></a>使用相片挑選工具 API</h1><p>接下來，我們就會使用相片挑選工具 API 來選擇單張或多張圖片，然後把選擇了的圖片顯示在介面上。</p>
<h2 id="預備一個存放已選擇的圖片-Uri-列表的狀態"><a href="#預備一個存放已選擇的圖片-Uri-列表的狀態" class="headerlink" title="預備一個存放已選擇的圖片 Uri 列表的狀態"></a>預備一個存放已選擇的圖片 <code>Uri</code> 列表的狀態</h2><p>在這個範例中，我們會使用一組可變的 <code>List&lt;Uri?&gt;</code> 存放選擇了的圖片，<strong>預設是沒有選擇任何圖片</strong>，所以初始值為 <code>emptyList()</code>，即為空列表。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> selectedImagesUris = remember &#123;</span><br><span class="line">    mutableStateOf&lt;List&lt;Uri?&gt;&gt;(emptyList())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info simple"><p>如果你只是想實現選擇單張圖片，而<strong>沒有選擇多張圖片的必要</strong>，可以直接用 <code>Uri?</code> 作為狀態：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> selectedImageUri = remember &#123; mutableStateOf&lt;Uri?&gt;(<span class="literal">null</span>) &#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="設計一個開啟相片挑選工具的呼叫按鈕"><a href="#設計一個開啟相片挑選工具的呼叫按鈕" class="headerlink" title="設計一個開啟相片挑選工具的呼叫按鈕"></a>設計一個開啟相片挑選工具的呼叫按鈕</h2><p>我們會加入一個按鈕，供用戶開啟相片挑選工具來選擇相片。</p>
<h3 id="實現單選及多選的活動結果合約"><a href="#實現單選及多選的活動結果合約" class="headerlink" title="實現單選及多選的活動結果合約"></a>實現單選及多選的活動結果合約</h3><p>首先，我們會分別為單選及多選編寫 <code>ActivityResultLauncher</code>：</p>
<p>處理單選或多選需要使用不同的 Jetpack Activity 活動結果合約：</p>
<ul>
<li><code>PickVisualMedia</code>：用於選取單一圖片或影片。</li>
<li><code>PickMultipleVisualMedia</code>：用於選取多個圖片或影片。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> singleImageLauncher = rememberLauncherForActivityResult(</span><br><span class="line">    contract = ActivityResultContracts.PickVisualMedia(),</span><br><span class="line">    onResult = &#123; uri -&gt;</span><br><span class="line">        selectedImagesUris.value = listOf(uri)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">val</span> multipleImagesLauncher = rememberLauncherForActivityResult(</span><br><span class="line">    contract = ActivityResultContracts.PickMultipleVisualMedia(</span><br><span class="line">        maxItems = <span class="keyword">if</span> (maxSelectionCount &gt; <span class="number">1</span>) maxSelectionCount <span class="keyword">else</span> <span class="number">2</span></span><br><span class="line">    ),</span><br><span class="line">    onResult = &#123; uris -&gt;</span><br><span class="line">        selectedImagesUris.value = uris</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<div class="note info simple"><p>同樣道理，如果只是實現單選圖片，只需要 <code>singleImageLauncher</code>，而且 <code>onResult</code> 回調中只需執行：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">selectedImageUri.value = uri</span><br></pre></td></tr></table></figure></div>

<h3 id="根據情況呼叫相應-ActivityResultLauncher"><a href="#根據情況呼叫相應-ActivityResultLauncher" class="headerlink" title="根據情況呼叫相應 ActivityResultLauncher"></a>根據情況呼叫相應 <code>ActivityResultLauncher</code></h3><p>在這個範例中，我們會靈活使用 <code>maxSelectionCount</code> 變數，來判斷應該要使用單選或多選的行為，可以在可組合項函式內編寫一個 <code>launchImagePicker()</code> 嵌套函式呼叫 <code>ActivityResultLauncher</code> 。</p>
<div class="note info simple"><p>設置 <code>PickVisualMedia.ImageOnly</code> 僅允許用戶選擇圖像。</p>
</div>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">launchImagePicker</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> mediaType = ActivityResultContracts.PickVisualMedia.ImageOnly,</span><br><span class="line">    <span class="keyword">if</span> (maxSelectionCount &gt; <span class="number">1</span>)</span><br><span class="line">        multipleImagesLauncher.launch(PickVisualMediaRequest(mediaType))</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        singleImageLauncher.launch(PickVisualMediaRequest(mediaType))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完成按鈕視覺佈局"><a href="#完成按鈕視覺佈局" class="headerlink" title="完成按鈕視覺佈局"></a>完成按鈕視覺佈局</h3><p>把 <code>launchImagePicker()</code> 嵌套函式作為 <code>Button</code> 的點擊事件處理，並根據 <code>maxSelectionCount</code> 動態化處理選擇圖片數量的文字描述。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Button(</span><br><span class="line">    onClick = &#123;</span><br><span class="line">        launchImagePicker()</span><br><span class="line">    &#125;,</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">val</span> flag = <span class="keyword">if</span> (maxSelectionCount &gt; <span class="number">1</span>) <span class="string">&quot;<span class="variable">$maxSelectionCount</span> images&quot;</span></span><br><span class="line">        <span class="keyword">else</span> <span class="string">&quot;1 image&quot;</span></span><br><span class="line">    Text(text = <span class="string">&quot;Select <span class="variable">$flag</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="顯示已選擇圖片的-LazyColumn-列表"><a href="#顯示已選擇圖片的-LazyColumn-列表" class="headerlink" title="顯示已選擇圖片的 LazyColumn 列表"></a>顯示已選擇圖片的 <code>LazyColumn</code> 列表</h2><p>首先，由於相片挑選工具都屬於一個 <code>ActivityResultLauncher</code>，意昧着回傳的結果都是 <code>Uri</code>，而 Jetpack Compose 是<strong>無法根據 <code>Uri</code> 來顯示相應圖像</strong>的，這個時候就要使用 Coil 庫進行異步圖像載入。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation(<span class="string">&quot;io.coil-kt:coil-compose:2.5.0&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>我們會使用 Coil 函式庫提供的 <code>ImageRequest.Builder</code> 定義要使用的 <code>model</code>，並傳入已選擇圖片的 <code>Uri</code> 作為資料來源，再使用 <code>rememberAsyncImagePainter</code> 來異步載入圖片。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">LazyColumn(</span><br><span class="line">    modifier = Modifier.fillMaxSize(),</span><br><span class="line">    horizontalAlignment = Alignment.CenterHorizontally</span><br><span class="line">) &#123;</span><br><span class="line">    itemsIndexed(selectedImagesUris.value) &#123; _, uri -&gt;</span><br><span class="line">        <span class="keyword">val</span> model = ImageRequest.Builder(LocalContext.current)</span><br><span class="line">            .<span class="keyword">data</span>(uri)</span><br><span class="line">            .size(Size.ORIGINAL)</span><br><span class="line">            .crossfade(<span class="literal">true</span>)</span><br><span class="line">            .build()</span><br><span class="line">        Image(</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .fillMaxWidth()</span><br><span class="line">                .padding(vertical = <span class="number">8.</span>dp),</span><br><span class="line">            painter = rememberAsyncImagePainter(model = model),</span><br><span class="line">            contentDescription = <span class="literal">null</span>,</span><br><span class="line">            contentScale = ContentScale.FillWidth</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info simple"><p>Coil 函式庫亦提供了 <code>AsyncImage</code> 可組合項，這個方式亦可處理異步載入：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">AsyncImage(</span><br><span class="line">    model = model,</span><br><span class="line">    contentDescription = <span class="literal">null</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<h2 id="最後介面佈局參考"><a href="#最後介面佈局參考" class="headerlink" title="最後介面佈局參考"></a>最後介面佈局參考</h2><p>這裏是整個介面佈局的參考實作，在 <code>LaunchImagePickerButton</code> 可組合項函式的 <code>maxSelectionCount</code> 參數設置為 <code>4</code>，代表開啟相片挑選工具時，用戶<strong>最多可選擇</strong> 4 張圖片。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MainScreen</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> selectedImagesUris = remember &#123;</span><br><span class="line">        mutableStateOf&lt;List&lt;Uri?&gt;&gt;(emptyList())</span><br><span class="line">    &#125;</span><br><span class="line">    Column(</span><br><span class="line">        modifier = Modifier.fillMaxSize()</span><br><span class="line">    ) &#123;</span><br><span class="line">        LaunchImagePickerButton(</span><br><span class="line">            selectedImagesUris = selectedImagesUris,</span><br><span class="line">            maxSelectionCount = <span class="number">4</span></span><br><span class="line">        )</span><br><span class="line">        ImageList(</span><br><span class="line">            selectedImagesUris = selectedImagesUris</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="舊型裝置向後相容處理"><a href="#舊型裝置向後相容處理" class="headerlink" title="舊型裝置向後相容處理"></a>舊型裝置向後相容處理</h1><p>使用相片挑選工具的裝置必須要至少 Android 11 以上版本，如果要進行向後相容 (backward compatibility)，兼容低版本 (<strong>最低僅至到 Android 4.4 版本</strong>) 的裝置，有兩種方案：</p>
<ol>
<li>不支援相片挑選工具的裝置，預設會使用系統內置的檔案選擇器，選擇型別為 <code>ACTION_OPEN_DOCUMENT</code>，選擇任一媒體檔案。</li>
<li>為舊型裝置<strong>自動安裝</strong>相片挑選工具的向後移植版本，在 <code>AndroidManifest.xml</code> 的 <code>&lt;application&gt;</code> 加上 <code>ModuleDependencies</code>，讓系統為應用程式從外部安裝相片挑選工具的模塊：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Trigger Google Play services to install the backported photo picker module. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">&quot;com.google.android.gms.metadata.ModuleDependencies&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:enabled</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">tools:ignore</span>=<span class="string">&quot;MissingClass&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.google.android.gms.metadata.MODULE_DEPENDENCIES&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;photopicker_activity:0:required&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<div class="note info simple"><p>搭載 Android 4.4 (API 級別 19) 至 Android 10 (API 級別 29) 版本的舊型裝置，以及搭載 Android 11 或 12 版本且支援 Google Play 服務的 Android Go 裝置，皆可安裝相片挑選工具的向後移植版本。</p>
</div>

<hr>
<h1 id="根據圖像的調色盤進行樣式化"><a href="#根據圖像的調色盤進行樣式化" class="headerlink" title="根據圖像的調色盤進行樣式化"></a>根據圖像的調色盤進行樣式化</h1><p>如果你覺得選擇了的圖像，該圖像的色調，與應用程式的樣式風格格格不入，可以使用 Palette API 來<strong>根據圖像來獲取一系列的調色</strong>。首先需要匯入 Palette API 庫：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation(<span class="string">&quot;androidx.palette:palette-ktx:1.0.0&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>定義一個獲取調色盤的狀態，稍後用來擷取該調色盤執行個體的顏色設定檔。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> palette = remember &#123; mutableStateOf&lt;Palette?&gt;(<span class="literal">null</span>) &#125;</span><br></pre></td></tr></table></figure>

<p>更新 <code>singleImageLauncher</code> 的 <code>onResult</code> 回調，根據所選擇圖像來生成一個調色盤，把調色盤執行個體存放到 <code>palette</code> 狀態。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> inputStream = uri?.let &#123;</span><br><span class="line">    context.contentResolver.openInputStream(it)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> bitmap = BitmapFactory.decodeStream(inputStream)</span><br><span class="line">palette.value = Palette.from(bitmap).generate()</span><br></pre></td></tr></table></figure>

<div class="note info simple"><p>如果你想都支援 <code>multipleImageLauncher</code>，那麼你<strong>就要決定使用哪一張圖片來生成調色盤</strong>，比如，使用第一張圖片：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> inputStream = uris?.first()?.let &#123;</span><br><span class="line">    context.contentResolver.openInputStream(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="可用的顏色設定檔"><a href="#可用的顏色設定檔" class="headerlink" title="可用的顏色設定檔"></a>可用的顏色設定檔</h2><table>
<thead>
<tr>
<th>顏色設定檔</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Dominant Swatch（主要色彩）</td>
<td>調色盤中最主要的顏色，代表整個圖像的主要色彩。</td>
</tr>
<tr>
<td>Vibrant Swatch（活躍色彩）</td>
<td>調色盤中最活躍且飽和的顏色，通常是一個鮮豔的色彩。</td>
</tr>
<tr>
<td>Light Vibrant Swatch（淺色活躍色彩）</td>
<td>調色盤中較為淺色且活躍的顏色。</td>
</tr>
<tr>
<td>Dark Vibrant Swatch（深色活躍色彩）</td>
<td>調色盤中較為深色且活躍的顏色。</td>
</tr>
<tr>
<td>Muted Swatch（柔和色彩）</td>
<td>調色盤中較為柔和和淡化的顏色。</td>
</tr>
<tr>
<td>Light Muted Swatch（淺色柔和色彩）</td>
<td>調色盤中較為淺色且柔和的顏色。</td>
</tr>
<tr>
<td>Dark Muted Swatch（深色柔和色彩）</td>
<td>調色盤中較為深色且柔和的顏色。</td>
</tr>
</tbody></table>
<p>每個顏色設定檔都可以獲取其 <code>rgb</code>、<code>hsl</code>、<code>titleTextColor</code> 及 <code>bodyTextColor</code> 屬性。</p>
<p><img src="/post/jetpack-compose-photo-picker-for-android-13/img1.png" alt="指定調色盤預設色彩數量上限 (16) 的範例圖片及其擷取的色彩設定檔"></p>
<div class="note warning simple"><p>要注意的是，<strong>並非每一張圖片都能擁有及擷取以上所有顏色設定檔</strong>。</p>
</div>

<p>例如，我們可以為 <code>Button</code> 根據圖片的調色盤而使用的顏色。</p>
<ul>
<li><code>containerColor</code>：使用 <code>darkVibrantSwatch</code> 的 <code>rgb</code> 顏色值</li>
<li><code>contentColor</code>：使用 <code>darkVibrantSwatch</code> 的 <code>bodyTextColor</code> 顏色值</li>
</ul>
<p>如果沒有選擇圖像，預設的容器顏色 <code>containerColor</code> 及內容顏色 <code>contentColor</code> 分別會沿用預設的 Primary 及 OnPrimary 色彩。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> containerColor = palette.value?.darkVibrantSwatch?.let &#123;</span><br><span class="line">    Color(it.rgb)</span><br><span class="line">&#125; ?: MaterialTheme.colorScheme.primary</span><br><span class="line"><span class="keyword">val</span> contentColor = palette.value?.darkVibrantSwatch?.let &#123;</span><br><span class="line">    Color(it.bodyTextColor)</span><br><span class="line">&#125; ?: MaterialTheme.colorScheme.onPrimary</span><br><span class="line"></span><br><span class="line">Button(</span><br><span class="line">    onClick = &#123;</span><br><span class="line">        launchImagePicker()</span><br><span class="line">    &#125;,</span><br><span class="line">    colors = ButtonDefaults.buttonColors(</span><br><span class="line">        containerColor = containerColor,</span><br><span class="line">        contentColor = contentColor</span><br><span class="line">    )</span><br><span class="line">) &#123; ... &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Jetpack Compose</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
</search>
